#!/usr/bin/env bash

# Global Def
PATH_ESOP="/usr/local/esop/agent"
PATH_APP="$PATH_ESOP/app"
PATH_BIN="$PATH_APP/bin"
PATH_RUN="$PATH_ESOP/run"
PATH_OPT="$PATH_ESOP/opt"
PATH_OPT_SBIN="$PATH_OPT/sbin"

PATH_MOLE="${PATH_ESOP}/mole"
PATH_MOLE_RUN="${PATH_MOLE}/run"

PIDF_GMOND="$PATH_RUN/esop_gmond.pid"
PIDF_PHPTD="$PATH_RUN/esop_phptd.pid"
PIDF_MOLE="$PATH_MOLE_RUN/esop_mole.pid"

ARRAY_COMPONENT=(
    "gmond"	"esop_gmond"	"${PIDF_GMOND}"
    "phptd" 	"esop_phptd"	"${PIDF_PHPTD}"
    "mole"  	"esop_mole"	"${PIDF_MOLE}"
)

EXEC_USER="eyou"
CMD_SUDO_EYOU="sudo -u $EXEC_USER"


#
### Func Def
#

# Terminal color
#
echo_green() {
  local content=$*
  echo -e "\033[1;32m${content}\033[0m\c "
}
echo_yellow() {
  local content=$*
  echo -e "\033[1;33m${content}\033[0m\c "
}
echo_red() { 
  local content=$* 
  echo -e "\033[1;31m${content}\033[0m\c "
}

### Help
##
show_help(){
cat << EOF

   $(echo_green "Help:")
	help
	start
	stop
	status
	restart
	

EOF
exit 0
}

# $1 contains $2 or not
# Usage:        sub_str "strings" "str"
#
sub_str() {  
  [ "${1#*$2*}" == "$1" ] && echo no || echo yes  
}

# get pid from pidfile
# usage:	get_pid {pid_file}
# return:	0 | 1 | 2
#
get_pid(){
  local fpid=$1
  local pid=

  if [ -f "${fpid}" -a -r "${fpid}" ]; then
	pid=$(awk '{print $1;exit;}' "${fpid}" 2>&-)
	[ -z "${pid}" -o ! -z "${pid//[0-9]}" ] && {
		return 2	# pidfile exists but pid invalid
	} 
  else
	return 1		# pidfile not exist
  fi

  echo "${pid}"			# pidfile exists and pid normal
  return 0
}

# get pid running status
# usage:	ps_status {pid_file} {pname}
# return:	0 running | 1 dead | 2 dead with pidfile left | 3 fake?
#
ps_status(){
  local fpid=$1 pname=$2
  local pid= rc=
  
  pid=$(get_pid "${fpid}")
  rc=$?
  if [ "$rc" == "0" ]; then
  	if [ -d "/proc/${pid}/" ]; then
		local cmdline=$(cat "/proc/${pid}/cmdline" 2>&-)
		if [ "$(sub_str "${cmdline}" "${pname}")" == "yes" ]; then
			return 0	# running
		else
			return 3	# fake?
		fi
  	fi
  elif [ "$rc" == "1" ]; then
	return 1			# dead
  elif [ "$rc" == "2" ]; then
	return 2			# dead with pidfile left
  fi
}

start_gmond(){
  $CMD_SUDO_EYOU $PATH_OPT_SBIN/gmond -p $PIDF_GMOND
}

start_phptd(){
  $CMD_SUDO_EYOU $PATH_BIN/etm_phptd -p $PIDF_PHPTD
}

start_mole(){
  ${PATH_MOLE}/mole start
}

stop_phptd(){
  kill $(get_pid ${PIDF_PHPTD})
}

stop_gmond(){
  kill $(get_pid ${PIDF_GMOND})
}

stop_mole(){
  ${PATH_MOLE}/mole stop
}


start(){
  local name=  disname=  fpid=

  for ((i=0;i<${#ARRAY_COMPONENT[*]};i++))
  do
	if (($i%3 == 0)); then
		name=${ARRAY_COMPONENT[$i]}
	elif (($i%3 == 1)); then
		disname=${ARRAY_COMPONENT[$i]}
	elif (($i%3 == 2)); then
		fpid=${ARRAY_COMPONENT[$i]}
		start_${name}; wait
		ps_status "${fpid}" "${name}"; wait
	fi
  done

}

#
### Main Body Begin
#

# check root privileges or not ?
if [ "$(id -u)" != "0" ]; then
  echo_red "root privilege required!";echo
  exit 1
fi

# check sudo user exist or not ?
if (id "${EXEC_USER}") >/dev/null 2>&1; then
  :
else
  echo_red "user ${EXEC_USER} not exists!";echo
  exit 1
fi

case "$#" in  
"1")
        arg1=$1;
        case "$arg1" in
        "help"|"h")
                show_help    			;;
	"start")
		start				;;
	"stop")
		stop				;;
	"status"|"s")
		status				;;
	"restart")
		stop
		sleep 1
		start				;;
	esac
	;;
"2")
	arg1=$1; arg2=$2
        [ -z "${arg2//[ ]}" ] && {
                echo_yellow "need arguments"; echo
                exit 1
        }

	case "$arg1" in
	"start")
						;;
	"stop")
						;;
	"status"|"s")
						;;
	"restart")
						;;
	esac
	;;
*)
	show_help
	;;
esac
