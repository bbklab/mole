#!/usr/bin/perl

BEGIN {
	$| = 1;
}

use strict;
use warnings;
use POSIX;
use File::Spec::Functions qw(rel2abs);
use File::Basename qw(dirname);
use Socket;
use IO::Select;
use IO::Socket;
use IO::Socket::INET;
use IO::Socket::UNIX;
use Tie::RefHash;
use Smart::Comments;

# Define Constant
use constant RCVBUFSIZE => POSIX::BUFSIZ * 2;
use constant PATH_BASE => dirname(dirname(rel2abs(__FILE__)));
use constant PATH_CONF => PATH_BASE . '/conf';
use constant PATH_LIB  => PATH_BASE . '/lib';
use constant PATH_LOG  => PATH_BASE . '/log';
use constant PATH_SBIN => PATH_BASE . '/sbin';
use constant PATH_TMP  => PATH_BASE . '/tmp';
use constant PATH_RUN  => PATH_BASE . '/run';
use constant PATH_TEST => PATH_BASE . '/t';
use constant CONFIG_FILENAME => 'proxy.ini';
use constant FILE_CONF => PATH_CONF . '/' . CONFIG_FILENAME;
use constant LOG_FILENAME => 'proxy.log';
use constant FILE_LOG  => PATH_LOG  . '/' . LOG_FILENAME;
use constant PID_FILENAME => 'proxy.pid';
use constant FILE_PID  => PATH_RUN  . '/' . PID_FILENAME;
use constant SOCK_FILENAME => 'queue.sock';
use constant FILE_SOCK => PATH_TMP . '/' . SOCK_FILENAME;

# Use our module 
use lib PATH_LIB;
use EsopLib;

# Define Global Vars
our %Config = &load_configs;		# proxy config
our %Accept_Children = (); 		# current accept children, only used in parent process
our %Sender_Children = ();		# current sender children, only used in parent process
our %Queue_Children = ();		# current queue children, only used in parent process
our $debug = $Config{'debug'};

# Establish server socket, bind and listen.
our $listen_socket = IO::Socket::INET->new(
	LocalHost	=> $Config{'listen_addr'},
	LocalPort	=> $Config{'listen_port'},
	Proto		=> 'tcp',
	Type		=> SOCK_STREAM,
	Listen		=> SOMAXCONN,
	Resuse		=> 1,
	Timeout		=> $Config{'accept_timeout'},
);
unless (defined $listen_socket) {
	&log (FILE_LOG, "CRIT proxy create socket error: $@");
	exit (1);
}
&log (FILE_LOG, "INFO proxy listening on $Config{'listen_addr'}:$Config{'listen_port'}, ready for connection ...");


# Install Signal Handler: Child Reaper
$SIG{'CHLD'} = sub {
  # a non-blocking(WNOHANG) wait for all(-1) pending zombie processes.
  while((my $pid = waitpid(-1, WNOHANG)) >0) {
	if (exists $Accept_Children{$pid}) {
		my $runtime = time - $Accept_Children{$pid}{'starton'};
		&log (FILE_LOG,
		"INFO proxy reape accept child $pid, has been running for $runtime seconds");
		delete $Accept_Children{$pid};

	} elsif (exists $Sender_Children{$pid}) {
		my $runtime = time - $Sender_Children{$pid}{'starton'};
		&log (FILE_LOG,
		"INFO proxy reape sender child $pid, has been running for $runtime seconds");
		delete $Sender_Children{$pid};

	} elsif (exists $Queue_Children{$pid}) {
		my $runtime = time - $Queue_Children{$pid}{'starton'};
		&log (FILE_LOG,
		"INFO proxy reape queue child $pid, has been running for $runtime seconds");
		delete $Queue_Children{$pid};
	
	} else {
		&log (FILE_LOG,
		"NOTE proxy reape unknown child $pid, should be either accept or sender child");
	}
  }
};

# Install Signal Handler: Exit Clean
$SIG{'TERM'} = $SIG{'INT'} = sub {
	&log (FILE_LOG, "NOTE proxy caught signal TERM/INT, exiting..."); 
	local ($SIG{'CHLD'}) = 'IGNORE';
	kill 'TERM', keys %Accept_Children;
	kill 'TERM', keys %Sender_Children;
	kill 'TERM', keys %Queue_Children;
	unlink FILE_SOCK if -S FILE_SOCK;
	unlink FILE_PID if -s FILE_PID;
	&log (FILE_LOG, "NOTE proxy finished."); 
	exit (0);
};


=head1

# Run as a Daemon
my $child = fork(); 
unless (defined $child) {
	&log (FILE_LOG, "CRIT proxy fork failed, $!");
	exit (1);
}

# father exit
if ($child) {
	exit (0);
}
     
# close STDIN/STDOUT/STDERR
for my $handle (*STDIN, *STDOUT, *STDERR) {
	unless ( open ($handle, "+<", "/dev/null") ) {
		&log (FILE_LOG, "CRIT proxy reopen $handle to /dev/null error: $!");
		die "$!\n";
	}
}
 
# child become leader
POSIX::setsid() ||  die "$!\n";

# chaning into /
chdir '/' || die "$!\n";

# set umask
umask(022) || die "$!\n";

# set ENV
$ENV{'PATH'} = '/sbin:/bin:/usr/sbin:/usr/bin';
 
# save daemon pid
unless ( open (FPID,">",FILE_PID) ) {
	&log (FILE_LOG, "CRIT proxy save daemon pid failed, $!");
	die "$!\n";
}
unless (print FPID $$) {
	&log (FILE_LOG, "CRIT proxy save daemon pid failed, $!");
	die "$!\n";
}
close FPID;
&log (FILE_LOG, "INFO proxy daemon $$ running ...");

=cut

# On Startup Initial
# Fork Off Our Queue -> Sender -> Accept Children
# start only one queue child
&make_new_queue_child;
die "$@\n" if ($@);

# start only one sender child
&make_new_sender_child;
die "$@\n" if ($@);

# start serveral accept children
for (1 .. $Config{'start_child'}) {
	&make_new_accept_child;
}
die "$@\n" if ($@);

# Main Daemon LOOP
while (1) {

	# maintain children population
	if (scalar keys %Queue_Children eq 0) {
		&make_new_queue_child;
	}
	if (scalar keys %Sender_Children eq 0)  {
		&make_new_sender_child;
	}
	for (my $i = scalar keys %Accept_Children; $i < $Config{'start_child'}; $i++) {
		&make_new_accept_child;
	}

	# wait for a signal (i.e., child's death SIGCHLD will wake up it)
	sleep;
}




#
# Sub Definations
#

sub make_new_accept_child {
	# block signal for fork
	my $sigset = POSIX::SigSet->new(SIGHUP,SIGINT,SIGTERM,SIGCHLD);
	POSIX::sigprocmask(SIG_BLOCK, $sigset);

	# fork off a child, parent return none-zero, child return zero
	my $pid = fork;

	# Trouble
	if (not defined $pid ){
		&log (FILE_LOG, "CRIT accept child fork failed: $!");
		return undef;

	# Parent
	} elsif ($pid) {
		# unblock signal
		POSIX::sigprocmask(SIG_UNBLOCK, $sigset);

		# records the child's birth and return.
		&log (FILE_LOG, "INFO accept child $pid starting");
		$Accept_Children{$pid}{'starton'} = time; 

	# Child
	} else {
		# this is child process, pls do *NOT* return from this subroutine.
		# must do exit instead of return. If it does, the child will return become a parent, 
		# and spawn off its own children. Your system will fill up with processes util death.

		my $child_pid = $$;

		# recovery SIGHUP,SIGINT,SIGTERM,SIGCHLD
		$SIG{'HUP'} = $SIG{'INT'} = $SIG{'TERM'} = $SIG{'CHLD'} = 'DEFAULT'; 

		# unblock signal
		POSIX::sigprocmask(SIG_UNBLOCK, $sigset);

		# init processed request number {maxrequest_perchild}
		my $i = 0;
		my $handle;
		my $inbuffer;
		my $rv;

		# init empty client connect hash
		my %client_inbuffer = ();
		my %client_outbuffer = ();
		my %client_ready = ();

		# create select object with {listen_socket}
		my $select = IO::Select->new( $listen_socket );

		while ( $i <= $Config{'maxrequest_perchild'} ) {

			my ($header, $data, $childinfo) = (undef, undef, "$child_pid-($i)");

			# accept connect or read socket data
			foreach $handle ( $select->can_read(1) ) {
				### %client_inbuffer

				# accept a new connection
				if ($handle eq $listen_socket) {
					### accetp_child_got_new_client: $child_pid
					my ($sockdata,$client) = $handle->accept();
					# check src address allow or not ?
					my ($client_port,$client_ip) = sockaddr_in ($client);
					my $client_ipaddr            = inet_ntoa   ($client_ip);
					my $client_detail	     = $client_ipaddr . ':' . $client_port;
					unless (&is_sub ($client_ipaddr, @{$Config{'src_allow'}})) {
						$sockdata->close();		# directly close connection
						&log (FILE_LOG,
						"NOTE accept child $childinfo deny connection from client $client_detail");
					} else {
						$sockdata->autoflush(1);	# autoflush is must for server after accept()
						$sockdata->send( "+OK ready\r\n" );
						$select->add($sockdata);	# add allowed connect into SELECT_SET
						$i ++; 				# add processed request number {maxrequest_perchild}
						&log (FILE_LOG,
						"INFO accept child $childinfo accept connection from client $client_detail");
					}
					next;
				} 

				# read socket data
				$inbuffer = '';
				$rv = $handle->recv($inbuffer, RCVBUFSIZE, 0);
				unless ( defined $rv ) {	# recv error
					### recv_error
					goto READERR_END;
				}
				unless ( length $inbuffer ) {	# recv end
					### recv_0_byte
					goto READERR_END;
				}

				$client_inbuffer{$handle} .= $inbuffer;
				### add_in_buffer_hash: $inbuffer
				### %{inbuffer}_after_add_in: %client_inbuffer

				if ( length $client_inbuffer{$handle} > $Config{'maxlen_accept'} ) {
					$handle->send( "-ERR message too long\r\n", 0 );
					&log (FILE_LOG,
					"CRIT accept child $child_pid-($i) receive message length exceed");
					goto READERR_END;
				}

				if ($client_inbuffer{$handle} =~ m/(.*)\r\n/) {
					### receive_whole_line: $1
					push @{$client_ready{$handle}{'request'}}, $1;
					delete $client_inbuffer{$handle};
					### %{ready}_after_receive_aline: %client_ready
					### %{inbuffer}_after_receive_aline: %client_inbuffer
					next;
				}

				READERR_END: {
					delete $client_inbuffer{$handle} if exists $client_inbuffer{$handle};
					delete $client_outbuffer{$handle} if exists $client_outbuffer{$handle};
					delete $client_ready{$handle} if exists $client_ready{$handle};
					$handle->close();
					$select->remove($handle);
					next;
				}
			}

			# process all full-line request saved in %client_ready
			# and write response to {output_buffer}
			foreach $handle (keys %client_ready) {
				### %client_ready_on_dohandle: %client_ready
				if ( scalar @{$client_ready{$handle}{'request'}} eq 1 ) {
					if ( $client_ready{$handle}{'processing'} )  {
						next;			# do **NOT** write to {output_buffer} repeatly
					}
					if ( $client_ready{$handle}{'request'}[0] =~ m/\AHEAD\s+(\w+,\S+,\S+)\Z/i ) {
						$header = $1;
						&log (FILE_LOG,
						"INFO accept child $childinfo receive header [$header]");
						$client_outbuffer{$handle} = "+OK recorded\r\n";
						$client_ready{$handle}{'processing'} = 1;	# mark as processing
						next;						# do **NOT** delete myself
					} else {
						$client_outbuffer{$handle} = "-ERR HEAD message first\r\n";
					}

				} elsif ( scalar @{$client_ready{$handle}{'request'}} eq 2 ) {
					if ( $client_ready{$handle}{'request'}[0] =~ m/\AHEAD\s+(\w+,\S+,\S+)\Z/i ) {
						$header = $1;
						$data = $client_ready{$handle}{'request'}[1];
						&log (FILE_LOG,
						"INFO accept child $childinfo receive data, length " . length $data . ", header [$header]");
						&log (FILE_LOG,
						"DEBUG accept child $childinfo receive data [$data]") if $debug;
						if ( &write_queue($childinfo, $header, $data) ) {
							&log (FILE_LOG,
							"INFO accept child $childinfo write data into queue succeed, header [$header]");
							$client_outbuffer{$handle} = "+OK accepted\r\n";
						} else {
							&log (FILE_LOG,
							"CRIT accept child $childinfo write data into queue failed, header [$header]");
							$client_outbuffer{$handle} = "-ERR write queue fail\r\n";
						}
					} else {
						$client_outbuffer{$handle} = "-ERR HEAD message first\r\n";
					}
				} 
				# if go here, delete myself
				delete $client_ready{$handle};
			}

			# response to client
			foreach $handle ( $select->can_write(1) ) {
				### %client_outbuffer_on_output: %client_outbuffer
				unless ( exists $client_outbuffer{$handle} ) {
					next;
				}

				$rv = $handle->send( $client_outbuffer{$handle}, 0 );
				unless ( defined $rv ) {
					goto WRITEERR_END;
				}
				unless ( $rv eq length $client_outbuffer{$handle}
					|| $! eq POSIX::EWOULDBLOCK ) {
					goto WRITEERR_END;
				}

				substr( $client_outbuffer{$handle}, 0, $rv ) = '';	
				unless ( length $client_outbuffer{$handle} ) {
					delete $client_outbuffer{$handle};
					if ( $client_ready{$handle}{'processing'} ) {
						next;				# interactive not finished, continue
					} else {
						goto WRITEERR_END;		# interactive finished, close client
					}
				}

				WRITEERR_END: {
					delete $client_inbuffer{$handle} if exists $client_inbuffer{$handle};
					delete $client_outbuffer{$handle} if exists $client_outbuffer{$handle};
					delete $client_ready{$handle} if exists $client_ready{$handle};
					$select->remove($handle);
					$handle->close();
					next;
				}
			}
		}

		# tidy up gracefully and finish

		# this exit is VERY important, otherwise the child will become
		# a parent producer of more and more children, forking util death.
		&log (FILE_LOG,
		"INFO accept child $child_pid finish its job, will exit");
		exit (0);
	}
}

sub make_new_sender_child {
	# block signal for fork
	my $sigset = POSIX::SigSet->new(SIGHUP,SIGINT,SIGTERM,SIGCHLD);
	POSIX::sigprocmask(SIG_BLOCK, $sigset);

	# fork off a child, parent return none-zero, child return zero
	my $pid = fork;

	# Trouble
	if (not defined $pid ){
		&log (FILE_LOG, "CRIT sender child fork failed: $!");
		return undef;

	# Parent
	} elsif ($pid) {
		# unblock signal
		POSIX::sigprocmask(SIG_UNBLOCK, $sigset);

		# records the child's birth and return.
		&log (FILE_LOG, "INFO sender child $pid starting");
		$Sender_Children{$pid}{'starton'} = time; 
		return 1;

	# Child
	} else {
		# this is child process, pls do *NOT* return from this subroutine.
		# must do exit instead of return. If it does, the child will return become a parent, 
		# and spawn off its own children. Your system will fill up with processes util death.

		my $child_pid = $$;

		# recovery SIGHUP,SIGINT,SIGTERM,SIGCHLD
		$SIG{'HUP'} = $SIG{'INT'} = $SIG{'TERM'} = $SIG{'CHLD'} = 'DEFAULT'; 

		# unblock signal
		POSIX::sigprocmask(SIG_UNBLOCK, $sigset);

		while (1) {

			# read queue
			$_ = &read_queue($child_pid);

			# remove \r\n
			if (defined) {
				chomp; s/[\r\n]//g;
			}

			# sleep for a while if empty queue or failed
			unless (defined && length >0) {
				sleep (1);		# prevent from nonstop connecting (for example, delete FILE_SOCK)
				next;
			}
			&log (FILE_LOG,
			"DEBUG sender child $child_pid SHIFT message from queue succeed.") if $debug;

			&log (FILE_LOG,
			"DEBUG sender child $child_pid SHIFT message [$_]") if $debug;

			# split data
			unless (m/\A(\S+?) (.+)\Z/) {
				&log (FILE_LOG,
				"NOTE sender child $child_pid read misform message from queue, SKIP");
				next;		# skip misform data
			}

			my ($header, $data) = ($1, $2);
			my $data_length = length $data;
			&log (FILE_LOG,
			"INFO sender child $child_pid read message (length=$data_length) from queue. header [$header]");

			eval {
				local $SIG{'ALRM'} = sub { die 'Send Timed Out'; };
				alarm($Config{'sender_timeout'});
			
				my $dest_detail = "$Config{'dest_addr'}:$Config{'dest_port'}";
				my $post_connect = IO::Socket::INET->new(
					PeerAddr		=>  $Config{'dest_addr'},
					PeerPort		=>  $Config{'dest_port'},
					Proto			=>  'tcp',
				);
				unless (defined $post_connect) {
					&log (FILE_LOG,
					"CRIT sender child $child_pid connect $dest_detail failed [$@]. header [$header]");
					die 'connect dest failed';
				}
				&log (FILE_LOG,
				"DEBUG sender child $child_pid connect $dest_detail succeed. header [$header] ") if $debug;

				if (print $post_connect "$data\r\n") {;
					&log (FILE_LOG,
					"INFO sender child $child_pid send data to remote host succeed. header [$header]");
				} else {
					&log (FILE_LOG,
					"CRIT sender child $child_pid send data to remote host failed. header [$header]");
					die 'send data failed';
				}

				my $response = <$post_connect> if ($post_connect);
				if (defined $response && length $response) {
					chomp $response;
					&log (FILE_LOG,
					"INFO sender child $child_pid receive response from remote host [$response]. header [$header]");
				} else {
					&log (FILE_LOG,
					"NOTE sender child $child_pid didn't receive any response from remote host. header [$header]");
				}

				$post_connect->close() if ($post_connect);

				alarm(0);
			};
			alarm(0);

			if ($@) {
				if ($@ =~ m/Send Timed Out/) {
					&log (FILE_LOG,
					"CRIT sender child $child_pid send data timeout. header [$header]");
				} else {
					$@ =~ s/[\r\n]//g;
					&log (FILE_LOG,
					"CRIT sender child $child_pid send data error [$@]. header [$header]");
				}
			}
		}

		# tidy up gracefully and finish

		# this exit is VERY important, otherwise the child will become
		# a parent producer of more and more children, forking util death.
		&log (FILE_LOG,
		"NOTE sender child $child_pid finish its loop, exit");
		exit (0);
	}
}

sub make_new_queue_child {
	# block signal for fork
	my $sigset = POSIX::SigSet->new(SIGHUP,SIGINT,SIGTERM,SIGCHLD);
	POSIX::sigprocmask(SIG_BLOCK, $sigset);

	# fork off a child, parent return none-zero, child return zero
	my $pid = fork;

	# Trouble
	if (not defined $pid ){
		&log (FILE_LOG, "CRIT queue child fork failed: $!");
		return undef;

	# Parent
	} elsif ($pid) {
		# unblock signal
		POSIX::sigprocmask(SIG_UNBLOCK, $sigset);

		# records the child's birth and return.
		&log (FILE_LOG, "INFO queue child $pid starting");
		$Queue_Children{$pid}{'starton'} = time; 
		return 1;

	# Child
	} else {
		# this is child process, pls do *NOT* return from this subroutine.
		# must do exit instead of return. If it does, the child will return become a parent, 
		# and spawn off its own children. Your system will fill up with processes util death.

		my $child_pid = $$;

		# initial data queue
		my @queue_data = ();

		# recovery SIGHUP,SIGINT,SIGTERM,SIGCHLD
		$SIG{'HUP'} = $SIG{'INT'} = $SIG{'TERM'} = $SIG{'CHLD'} = 'DEFAULT'; 

		# unblock signal
		POSIX::sigprocmask(SIG_UNBLOCK, $sigset);

		# set umask for rw-------
		umask (0117);

		# create unix domain socket	
		unlink FILE_SOCK if -S FILE_SOCK;
		my $unix_socket = IO::Socket::UNIX->new(
			Local		=> FILE_SOCK,
			Listen          => SOMAXCONN,
			Type		=> SOCK_STREAM,
		);
		unless (defined $unix_socket) {
			&log (FILE_LOG, "CRIT queue child $child_pid create unix domain socket error: [$!]");
			sleep (3);		# prevent from nonstop restarting
			exit (1);
		}
		&log (FILE_LOG, "INFO queue child $child_pid create unix domain socket succeed");

		while (1) {

			# accept request
		 	my $sockdata = $unix_socket->accept();
			&log (FILE_LOG, "DEBUG queue child $child_pid accept request") if $debug;
			
			# read request
			$_ = <$sockdata> if ($sockdata);

			# remove \r\n
			if (defined) {
				chomp; s/[\r\n]//g;
			}

                        # skip if empty request
			unless (defined && length >0) {
				&log (FILE_LOG,
				"CRIT queue child $child_pid skip empty request.") if $debug;
                        	goto CONNEND;
                        }   
                        &log (FILE_LOG,
                        "DEBUG queue child $child_pid accept request $_") if $debug;

			# process PUSH
			if (m/\APUSH (.+)\Z/) {
				my $queue_number = scalar @queue_data;
				if ($queue_number > $Config{'queue_maxlen'}) {
					&log (FILE_LOG,
					"NOTE queue child $child_pid queue number $queue_number reached uplimit, auto SHIFT");
					my $oldest = shift @queue_data;
					if ($oldest =~ m/\A(\S+?) (.+)\Z/) {
						&log (FILE_LOG,
						"NOTE queue child $child_pid remove oldest data, header [$1]");
					} else {
						&log (FILE_LOG,
						"NOTE queue child $child_pid remove oldest data, header unknown");
					}
				} 
				unless (push @queue_data, $1) {
					&log (FILE_LOG,
					"CRIT queue child $child_pid push data into queue failed.");
					goto CONNEND;
				}
				&log (FILE_LOG,
				"DEBUG queue child $child_pid push data into queue succeed.") if $debug;

			# process SHIFT
			} elsif (m/\ASHIFT\Z/) {
				unless (scalar @queue_data > 0) {
					&log (FILE_LOG,
					"DEBUG queue child $child_pid has empty queue, return nothing") if $debug;
					goto CONNEND;
				}
				unless (print $sockdata (shift @queue_data) . "\r\n") {
					&log (FILE_LOG,
					"CRIT queue child $child_pid return first data in queue failed");
					goto CONNEND;
				}
				&log (FILE_LOG,
				"DEBUG queue child $child_pid return first data in queue succeed") if $debug;

			# ignore other
			} else {
				goto CONNEND;
			}

			CONNEND: {
				$sockdata->close() if ($sockdata);
				next;
			}
		}

		# tidy up gracefully and finish
		$unix_socket->close() if ($unix_socket);
		unlink FILE_SOCK if -S FILE_SOCK;

		# this exit is VERY important, otherwise the child will become
		# a parent producer of more and more children, forking util death.
		&log (FILE_LOG,
		"NOTE queue child $child_pid finish its loop, exit");
		exit (0);
	}
}


sub load_configs {
	my %Config = (
		'debug'				=> 	['global','debug',0],
		'listen_addr'			=> 	['accept','listen_addr','0.0.0.0'],
		'listen_port'			=> 	['accept','listen_port',8548],
		'src_allow'			=>	['accept','src_allow','127.0.0.1'],
		'maxlen_accept'			=>	['accept','maxlen_accept',131072],
		'start_child'			=>	['accept','start_child',5],
		'maxrequest_perchild'		=>	['accept','maxrequest_perchild',2000],
		'accept_timeout'		=>	['accept','accept_timeout',10],
		'dest_addr'			=>	['sender','dest_addr','mole.eyousop.com'],
		'dest_port'			=>	['sender','dest_port',8538],
		'sender_timeout'		=>	['sender','sender_timeout',30],
		'queue_maxlen'                  =>      ['queue','queue_maxlen',1000],
	);

	# load proxy ini configs
	foreach my $config (keys %Config) {
		my ($section,$key,$default) = @{$Config{$config}};
		my ($value, $error) = &read_ini($section,$key,FILE_CONF);
		if (defined $value) {
			$Config{$config} = $value;
			&log (FILE_LOG, "INFO load config $config = $value");
		} else {
			&log (FILE_LOG, "NOTE load config $config error: $error, load default ($default)");
			$Config{$config} = $default;
		}
	}

	# use anoymous array ref
	$Config{'src_allow'} = [ split(/\s*,\s*/, $Config{'src_allow'}) ];

	return %Config;
}

sub write_queue {

	my ($child, $header, $data) = @_;
	
	unless (defined $child && length $child) {
		$child = 'Null-(N/A)';
	}

	unless (defined $data && length $data) {
		&log(FILE_LOG,
		"CRIT accept child $child write queue error: data not defined");
		return undef;
	}

	unless (defined $header && length $header) {
		&log(FILE_LOG,
		"CRIT accept child $child write queue error: header not defined");
		return undef;
	}

	my $unix_socket = IO::Socket::UNIX->new(
		Type		=> SOCK_STREAM,
		Peer		=> FILE_SOCK,
	);
	unless ($unix_socket) {
		&log(FILE_LOG,
		"CRIT accept child $child connect unix domain socket error [$@]");
		return undef;
	}
	&log (FILE_LOG,
		"DEBUG accept child $child connect unix domain socket succeed.") if $debug;

	unless (print $unix_socket "PUSH $header $data\r\n") {
		&log (FILE_LOG,
		"CRIT accept child $child write message into queue failed.");
		return undef;
	}

	$unix_socket->close() if ($unix_socket);

	1;
}

sub read_queue {

	my ( $child )  = @_;
	my $data = undef;

	unless (defined $child && length $child) {
		$child = 'Null-(N/A)';
	}

	my $unix_socket = IO::Socket::UNIX->new(
		Type            => SOCK_STREAM,
		Peer            => FILE_SOCK,
	);
	unless ($unix_socket) {
		&log(FILE_LOG,
		"CRIT sender child $child connect unix domain socket error [$@].");
		return undef;
	}
	&log (FILE_LOG,
		"DEBUG sender child $child connect unix domain socket succeed.") if $debug;

	unless (print $unix_socket "SHIFT\r\n") {
		&log (FILE_LOG,
		"CRIT sender child $child request SHIFT message from queue failed.");
		return undef;
	}

	$data = <$unix_socket> if ($unix_socket);

	$unix_socket->close() if ($unix_socket);

	return $data;
}

__END__
