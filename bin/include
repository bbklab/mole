#!/bin/bash
#
#
# =======================================================================================
#  This File Contains Global Variables and Public Functions Used by MOLE and Plugins. 
# =======================================================================================
#
#



# BASE_DIR DEF
[ -z ${BASE_DIR} ] && { 
        path=$( cd $(dirname $0) && pwd)
        BASE_DIR=${path%/*}
}

# for debug
# BASE_DIR="/usr/local/esop/agent/mole"



####################################
#				   #
#  --*--< Global Variables >--*--  #
#			           #
####################################

# VER DEF
MOLE_VERSION="1.0.1"

# DIR DEF
BIN_DIR="${BASE_DIR}/bin"
SBIN_DIR="${BASE_DIR}/sbin"
CONF_DIR="${BASE_DIR}/conf"
HANDLER_DIR="${BASE_DIR}/handler"
OPT_DIR="${BASE_DIR}/opt"
TPL_DIR="${OPT_DIR}/tpl"
OPT_BINDIR="${OPT_DIR}/bin"
PLUGIN_DIR="${BASE_DIR}/plugin"
INNER_DIR="${PLUGIN_DIR}/.inner"
TMP_DIR="${BASE_DIR}/tmp"
RUN_DIR="${TMP_DIR}/run"
LOG_DIR="${BASE_DIR}/log"
BACK_DIR="${LOG_DIR}/backup"
SNAPSHOT_DIR="${LOG_DIR}/snapshot"
SHARE_DIR="${BASE_DIR}/share"
LOCALE_DIR="${SHARE_DIR}/locale"
PLLIB_DIR="${OPT_DIR}/plmods"

# SH DEF
PRECHECK_SH="${BIN_DIR}/precheck"
AUTOCONF_SH="${BIN_DIR}/autoconf"
UPDATE_SH="${BIN_DIR}/update"
REPORT_SH="${BIN_DIR}/report"
CHECKCONF_SH="${BIN_DIR}/checkconf"
POSTLOG_SH="${HANDLER_DIR}/postlog"
TAKESNAP_SH="${HANDLER_DIR}/takesnap"
SENDMAIL="${HANDLER_DIR}/sendmail"
SENDEMAIL="${OPT_DIR}/sendEmail"
MAKEDIR_SH="${BIN_DIR}/makedir"
SETINIT_SH="${BIN_DIR}/setinit"
SAVECONF_SH="${BIN_DIR}/saveconf"

# UTIL DEF
UTIL_IOSTAT="${OPT_BINDIR}/iostat"
UTIL_MPSTAT="${OPT_BINDIR}/mpstat"

# MAIL_TPL DEF
TPL_MAIL="${TPL_DIR}/notify_mail.tpl"

# PERL UTIL DEF
PLUTIL="${BIN_DIR}/util.pl"

# LOG DEF
MOLE_LOG="${LOG_DIR}/mole.log"
INNER_LOG="${LOG_DIR}/inner.log"
PRECHECK_LOG="${LOG_DIR}/precheck.log"
POSTLOG_LOG="${LOG_DIR}/postlog.log"
TAKESNAP_LOG="${LOG_DIR}/takesnap.log"
UPDATE_LOG="${LOG_DIR}/update.log"
SENDMAIL_LOG="${LOG_DIR}/sendmail.log"
AUTOCONF_LOG="${LOG_DIR}/autoconf.log"
ERRLOG="${LOG_DIR}/error.log"

# CFG DEF
CONFIG_FILE="${CONF_DIR}/.mole.ini"

# UUID DEF
UUID_FILE="${CONF_DIR}/.mole.uuid"

# INC DEF
INCLUDE_FILE="${BIN_DIR}/include"

# MOLE DEF
MOLE_FILE="${SBIN_DIR}/mole"

# PID DEF
PID_FILE="${RUN_DIR}/esop_mole.pid"

# TMP FILE DEF
TMP_LASTRUN="${TMP_DIR}/.lastrun.dat"
TMP_NEXTRUN="${TMP_DIR}/.nextrun.dat"
TMP_REPEAT="${TMP_DIR}/.repeat.dat"
TMP_STATUS="${TMP_DIR}/.status.dat"
TMP_HEAPUPRC="${TMP_DIR}/.heapuprc.dat"
TMP_HEAPUPNOTIFY="${TMP_DIR}/.heapupnotify.dat"
SMTPHOST_STATUS="${TMP_DIR}/.smtphost.status"
POSTHOST_STATUS="${TMP_DIR}/.posthost.status"

# ESOP SAVEOLD DIR DEF
ESOP_PATH="/usr/local/esop/agent"
PROXY_CONF_PATH="${ESOP_PATH}/etc"
MOLE_CONF_PATH="${CONF_DIR}"
ESOP_SAVEOLD_DIR="/var/tmp/esop_rpmpreun_saveold"


### PLUGIN BASE CONFIG NAME
ARRAY_BASE_CONFIG=(
  enable
  comment
  frequency
  exec_tmout
  maxerr_times
  take_snapshot
  mail_notify
  mail_policy
  sms_notify
  sms_policy
  post_notify
  mail_receviers
  sms_receviers
  attsnap_mail
  auto_handle
  auto_handler
  locale
  debug
)

### CONFIG SECTION IN MAIN CONFIG
###  -- Exclude INNER PLUGINS
ARRAY_GLOBAL_SECTION=(
  global
  default
  postlog
  sendmail
  takesnap
)

### SUPPORTED NOTIFY TYPES
ARRAY_NOTIFY_TYPE=(
  mail
  sms
)

### INNER PLUGIN BEGINNER DEF
INNER_BEGIN="^mole_"

### PLACE HOLDER STRING
PLACE_HOLDER="_PLUGIN_"

### CONIFG METHOD MAPS
ARRAY_CONF_GET_MAPS=(
  # config		# method

  # global config
  "g_parter_id"		"get_parter_id"
  "g_mole_id"		"get_mole_id"
  "g_global_name"	"get_global_name"
  "g_scan_interval"	"get_scan_interval"
  "g_attach_ini_mail"	"get_attach_ini_mail"
  "g_sysload_uplimit"	"get_sysload_uplimit"
  "g_max_kidsnum"	"get_max_kidsnum"
  "g_plugin_maxlen"	"get_plugin_maxlen"
  "g_handler_maxlen"	"get_handler_maxlen"
  "g_notify_onmisform"  "get_notify_onmisform"
  "g_locale"		"get_global_locale"

  # plugin config	# replace ${PLACE_HOLDER} as real plugin
  "p_enable"		"get_enable ${PLACE_HOLDER}"
  "p_comment"		"get_comment ${PLACE_HOLDER}"
  "p_frequency"		"get_frequency ${PLACE_HOLDER}"
  "p_exec_tmout"	"get_exec_tmout ${PLACE_HOLDER}"
  "p_maxerr_times"	"get_maxerr_times ${PLACE_HOLDER}"
  "p_take_snapshot"	"get_action_type ${PLACE_HOLDER} take_snapshot"
  "p_mail_notify"	"get_action_type ${PLACE_HOLDER} mail_notify"
  "p_sms_notify"	"get_action_type ${PLACE_HOLDER} sms_notify"
  "p_post_notify"	"get_action_type ${PLACE_HOLDER} post_notify"
  "p_auto_handle"	"get_action_type ${PLACE_HOLDER} auto_handle"
  "p_mail_receviers"	"get_mail_receviers ${PLACE_HOLDER}"
  "p_sms_receviers"	"get_sms_receviers ${PLACE_HOLDER}"
  "p_attsnap_mail"	"get_attsnap_mail ${PLACE_HOLDER}"
  "p_auto_handler"	"get_auto_handler ${PLACE_HOLDER}"
  "p_locale"		"get_locale ${PLACE_HOLDER}"
  "p_debug"		"get_debug ${PLACE_HOLDER}"
)

### PLUGIN RETRUN CODE MAPS
ARRAY_RCSTATUS_MAPS=(
  0 succ
  1 warn
  2 crit
  3 unkn
  4 noop
  5 notify
)

### VALID ACTION CONFIG
# all     = crit warn unkn succ notify recovery tmout
# default = crit warn unkn notify recovery tmout
# none	  = none
VALID_ACTION_CONFIG="crit warn unkn succ notify recovery tmout all default none "




####################################
#				   #
#  --*--< Public Functions >--*--  #
#				   #
####################################



# Terminal color
echo_green() {
  local content=$*
  echo -e "\033[1;32m${content}\033[0m\c "
}
echo_yellow() {
  local content=$*
  echo -e "\033[1;33m${content}\033[0m\c "
}
echo_red() { 
  local content=$* 
  echo -e "\033[1;31m${content}\033[0m\c "
}

# HTML color
html_green() {
  local content=$*
  echo -e "<font color=green>${content}</font> \c "
}
html_yellow() {
  local content=$*
  echo -e "<font color=yellow>${content}</font> \c "
}
html_red() {
  local content=$*
  echo -e "<font color=red>${content}</font> \c "
}

# Random Number in specified range
# Usage:	random_num  min  max
#
random_num() {
  local min=$1 max=$2 tmp=$(echo "$2-$1" | bc 2>&-) base=$(date +%N%s)
  echo "${base} % ${tmp} + ${min} " | bc 2>&-
}

# $1 contains $2 or not
# Usage:	sub_str "strings" "str"
#
sub_str() {  
  [ "${1#*$2*}" == "$1" ] && echo no || echo yes  
}

# Check item is subset of sets or not ?
# Usge:		is_sub "item" "sets"
# Return:	0,1 | yes,no
#
is_sub() {
        local item="$1"  sets="$2"
        if [ "$(echo -e "${sets}" | grep -E -o -w "${item}")" == "" ]; then
                return 1
        else
                return 0
        fi  
}

# Check item is int or not ? 
# Usage:	is_int "item"
# Return:	0,1 | yes,no
#
is_int() {
	local item="$1"
	if [ -z "${item}" -o ! -z "${item//[0-9]}" ]; then
		return 1
	else
		return 0
	fi
}

# Check item is float or not ?
# Usage:	is_float "item"
# Return	0,1 | yes,no
#
is_float() {
	local item="$1"	float_regex="^[0-9]*\.[0-9]+$"
	if [[ "${item}" =~ ${float_regex} ]]; then
		return 0
	else
		return 1
	fi
}

# Check item is between {min} and {max} or not ?
# Usage:	is_between {item} {min} {max}
# Return:	0,1 | yes,no
#
is_between() {
	echo $1 $2 $3 | /bin/awk '{if($1>=$2 && $1<=$3){exit 0;} else{exit 1;}}' 2>&-
}

# Convert string as int
# Usage:	cto_int {stuff}
#
cto_int() {
	echo -en "${1//[!0-9]}"
}

# Get InetName by Priority 
#
get_inetorder() {
	local netfile="/proc/net/dev"	result=
	local biosdevname="/sbin/biosdevname"

	local i_new1="em"  i_new2="p"  i_old="eth"	new_mode=0	# old naming schema first
	local array_inet=()
	if [ -f "${netfile}" ]; then
		array_inet=( $( awk -F: '(NF!=2){next;} ($1~/\<lo\>/){next;} {print $1,$2}' "${netfile}" 2>&- |\
			awk '($2!=0 && $3!=0){print $1;}')  )		# active inet name list (exclude lo)
		if [ "${#array_inet[*]}" == "0" ]; then
			:
		elif [ "${#array_inet[*]}" == "1" ]; then
			result="${array_inet[0]}"
		else
			if [ -f "${biosdevname}" -a -x "${biosdevname}" ]; then
				new_mode=1				# new naming schema first
			fi

			local inetname=  ainew1=  ainew2=  aiold=  aiother=
			for((i=0;i<${#array_inet[*]};i++))
			do
				inetname="${array_inet[$i]}"
				if (echo -e "${inetname}" | grep -E "^${i_new1}") >/dev/null 2>&1; then
					ainew1="${ainew1}\n${inetname}"
				elif (echo -e "${inetname}" | grep -E "^${i_new2}") >/dev/null 2>&1; then
					ainew2="${ainew2}\n${inetname}"
				elif (echo -e "${inetname}" | grep -E "^${i_old}") >/dev/null 2>&1; then
					aiold="${aiold}\n${inetname}"
				else
					aiother="${aiother}\n${inetname}"
				fi 
			done
			if [ -n "${ainew1}" ]; then
				ainew1=$(echo -en "${ainew1}\n" | sort -n)
			fi
			if [ -n "${ainew2}" ]; then
				ainew2=$(echo -en "${ainew2}\n" | sort -n)
			fi
			if [ -n "${aiold}" ]; then
				aiold=$(echo -en "${aiold}\n" | sort -n)
			fi
			if [ -n "${aiother}" ]; then
				aiother=$(echo -en "${aiother}\n" | sort -n)
			fi

			if [ "${new_mode}" == "1" ]; then
				result="${ainew1} ${ainew2} ${aiold} ${aiother}"		
			else
				result="${aiold} ${ainew1} ${ainew2} ${aiother}"
			fi
		fi
			
	fi

	echo -en "${result}" | tr '\n\t ' ' '
}

# Write log
# Usage1:	1: set {_LOG} and ${_DEBUG} before you call this function.
# Usage2:	2: -f path/to/log/file     Note: this pattern will ignore ${_DEBUG} flag.
# Example1:	export _LOG=/tmp/log DEBUG=1 && write_log any stuff you want to log && unset _LOG
# Example2:	write_log -f /tmp/log  any stuff you want to log.
#
write_log() {
  local logfile=  content=
  [ "$1" == "-f" ] && {
	logfile="$2" ; shift 2
	content=$*
  } || {
  	[ "${_DEBUG}" != "1" ] && return 0
  	[ -z "${_LOG}" ] &&  logfile="${MOLE_LOG}" || logfile="${_LOG}"
 	content=$*
  }
  echo "$(date +%s)" "$(date +%F_%T)" "${content}"  >> ${logfile} 2>&-
}

# Return Code and Return Level is Matched or not, According to ARRAY_RCSTATUS_MAPS
# Usage:	is_match  succ 1
# Output:	yes | no
# Example:	is_match  {level} {rc}
#
is_match() {
  local level=$1  rc=$2  result=

  for ((i=0;i<=${#ARRAY_RCSTATUS_MAPS[@]}-1;i++))
  do
	if [ "${ARRAY_RCSTATUS_MAPS[${i}]}" == "${rc}" ]; then
		local i2=$((${i}+1))
		[ "${ARRAY_RCSTATUS_MAPS[${i2}]}" == "${level}" ] && result="yes" || result="no"
		break
	fi
  done
  
  echo -en "${result}"
}

# According to input pidfile, output process state.
# Usage:	check_ps_on_pid_file  {pid_file}
# Return: 	0 1 2 3  ==>  Running | Missing arguments | Dead but pid file exists | Dead
#
check_ps_by_pid_file() {
  local pid_file=$1  pid=
  [ -z "${pid_file}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 check_ps_by_pid_file error:"\
		 "missing arguments, fpid=[${fpid}]";
	return 1
  }
  [ -f "${pid_file}" -a -s "${pid_file}" ] && {
  	read line < ${pid_file}
	for x in `echo ${line}`; do
  		[ -z "${x//[0-9]/}" -a -d "/proc/${x}" ] && pid="${pid} ${x}"
  	done
  	[ ! -z "${pid//[ ]}" ] && return 0 || return 2
  }
  return 3
}

# According to input ppid, search all of kid pids, output by reverse order.
# Usage:        get_pidkids_bypid {father_pid}
# Example:      get_pidkids_bypid 1876
#
get_pidkids_bypid() {
  local father_pid=$1
  local array_result=()
  # if empty, pstree will output all kid pids of init(1)
  [ -z "${father_pid}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 get_pidkids_bypid error:"\
		"missing arguments, father_pid=[${father_pid}]";
	return 2
  }
  if [ -z "${father_pid//[0-9]}" ]; then
	array_result=( $(/usr/bin/pstree -p ${father_pid} |\
			 grep -E -o "\([0-9]+\)" |\
			 tr -d '[\(\)]' | tail -n +2 |\
			 tr '\n\r' ' ') )
  else
	write_log -f "${MOLE_LOG}" "E0000000 get_pidkids_bypid error:"\
		"input father_pid must be interger: [${father_pid}]";
	return 1
  fi
  
  for ((i=${#array_result[@]}-1;i>=0;i--))  ; do
     echo -n "${array_result[$i]} "
  done
  unset array_result
}

# According to input ppid, output kids number
# Usage:	get_kidsnum {father_pid}
# Example:	get_kidsnum 1876
#
get_kidsnum() {
  local father_pid=$1
  local result=
  # if empty, pstree will output all kid pids of init(1)
  [ -z "${father_pid}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_kidsnum error:"\
                "missing arguments, father_pid=[${father_pid}]";
        return 2
  }
  if [ -z "${father_pid//[0-9]}" ]; then
	result=$(/usr/bin/pstree -p ${father_pid} | grep -E -o -c "\([0-9]+\)")
  else
	write_log -f "${MOLE_LOG}" "E0000000 get_kidsnum error:"\
		"input father_pid must be interger: [${father_pid}]";
	return 1
  fi
  echo "${result}"
}

# Check the file is plugin config file or not, retun plugin-name if valid file.
# Conditions: 
#   1. filename like {plugin-name}.ini
#   2. headline of file like  [plugin-name]
#   3. filesize must less than 1048576 bytes.(1M)
#   4. filetype must be like Text
#   5. plugin-name length less than 64
#   6. plugin-name only allowed chars: [a-zA-Z0-9_-]
# Output:  plugin-name | no  (blank space will be trimed)
# Example:  is_plugin_conifgfile "/dev/mcelog"
# Example:  is_plugin_configfile "/etc/abc.ini"
#
is_plugin_configfile(){
  local filepath=$1  result=
  local ftype=$(echo "${filepath}" | LANG=C /usr/bin/perl -ne 'chomp;print -T "$_"?"text":"nontext";' 2>&-)
  if [ "${ftype}" != "text" ]; then
	result="no"
  else
	# local fsize=$(echo "${filepath}" | LANG=C /usr/bin/perl -ne 'chomp;$size=-s;print "$size"' 2>&-)
	local fsize=$(/usr/bin/stat -c "%s" "${filepath}" 2>&-)
	if ! is_int "${fsize}"; then
		result="no"
  	elif [ ${fsize} -ge 1048576 ]; then
		result="no"
	else
  		local pname=$(echo "${filepath##*/}" |LANG=C /usr/bin/perl -ne 'if(m/\A(\S+)\.ini\Z/i){print "$1"};' 2>&-)
  		local hname=$(head -n1 "${filepath}" |LANG=C /usr/bin/perl -ne 'if(m/\A\s*\[\s*(\S+)\s*\]\s*/){print "$1"};' 2>&-)
  		if [ -z "${pname}" -o -z "${hname}" ]; then
			result="no"
  		elif [ "${pname}" != "${hname}" ]; then
			result="no"
  		else
			if ! is_between "${#pname}" 0 64; then
				result="no"
			elif [ -n "${pname//[a-zA-Z0-9_-]}" ]; then
				result="no"
			else
				result="${pname}"
			fi
		fi
	fi
  fi
  echo "${result}"
}

# List all registered plugins exclude inners.  		
# Note: 	blank space will be trimed
#
list_plugin_section() {
  local config_files_arr=  result=
  config_files_arr=( $(ls "${CONF_DIR}/"*.ini 2>&-) )
  for((i=0;i<=${#config_files_arr[*]};i++));
  do
	filepath="${config_files_arr[$i]}"
	pluginname="$(is_plugin_configfile "${filepath}")"
	if [ "${pluginname}" != "no" ]; then
		result="${result} ${pluginname}"
	fi
  done
  echo "${result}"
}

# List all inner plugins.		
# Note: 	blank space will be trimed
#
list_inner_plugin_section() {
  local result=
  # Do NOT pass widechars such as chinese input to sed, which will lead to hangup in some circumstances.
  result=$( cat ${CONFIG_FILE} | grep -E -v "^[ \t]*;" | tr -d ' \t' |\
		sed -e '/^\[mole_.*\]$/!d; s/^\[//; s/\]$//;' 2>&- |\
		tr '\r\n' ' ')
  echo "${result}"
}

# List all section name.
# Note: 	(each plugin_name) + (section_name in mole.ini)
# Note: 	blank space will be trimed
#
list_all_section() {
  local result=
  # Do NOT pass widechars such as chinese input to sed, which will lead to hangup in some circumstances.
  result=$( cat ${CONFIG_FILE} | grep -E -v "^[ \t]*;" | tr -d ' \t' |\
  		sed -e '/^\[.*\]$/!d;/^\[[ \t]*\]$/d;s/^\[//;s/\]$//;' 2>&- |\
  		tr '\r\n' ' ')
  result="${result} $(list_plugin_section)"
  echo "${result}"
}

# List single section's key name
#
list_section_keys(){
  local section=$1  result=  config_file=
  [ -z "${section}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 list_section_keys error:"\
		"missing section name";
        return 1
  }
  # set config file
  if is_sub "${section}" "${ARRAY_GLOBAL_SECTION[*]}"; then
	config_file="${CONFIG_FILE}"
  elif [[ "${section}" =~ ${INNER_BEGIN} ]]; then
	config_file="${CONFIG_FILE}"
  else
	config_file="${CONF_DIR}/${section}.ini"
  fi
  [ -f "${config_file}" -a -s "${config_file}" ] || {
	write_log -f "${MOLE_LOG}" "E0000000 list_section_keys error:"\
		"section=[${section}], but config file [${config_file}] not exists or empty.";
	return 1
  }
  result=$(cat ${config_file} | tr '\t' ' ' |\
		awk -F"=" '\
			($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next} \
			( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit} \
			(k==1 && x==1 && $0!~/^[ \t]*$/ && $0!~/^[ \t]*;/){print $1}' |\
		sed -e 's/^[ \t]*//; s/[ \t]*$//; s/^\"//; s/\"$//' 2>&-)
  echo -e "${result}"
}

# According to input plugin-name, output matched plugin-name in plugin config file.
# Example:	read_plugin_section  check_sysload
# Return:	0 1:  OK | Missing arguments
#
read_plugin_section(){
  local section=$1
  if [ -z "${section}" ]; then 
	write_log -f "${MOLE_LOG}" "E0000000 read_plugin_section error:"\
		"missing arguments, section=[${section}]";
	return 1
  else
        config_file="${CONF_DIR}/${section}.ini"
	if [ "$(is_plugin_configfile "${config_file}")" == "${section}" ]; then
		echo "${section}"
		return 0
	fi
  fi
}

# According to input section-name, output matched section-name in mole config file.
# Example:	read_mole_section   mole_iam_alive
# Return:	0 1 2 3 :  OK | Missing arguments | ${config_file} empty / not exist | Null
#
read_mole_section() {
  local section=$1  value= config_file=
  if [ -z "${section}" ]; then 
        write_log -f "${MOLE_LOG}" "E0000000 read_mole_section error:"\
                "missing arguments, section=[${section}]";
        return 1
  else 
	config_file="${CONFIG_FILE}"
        if [ ! -f "${config_file}" -o ! -s "${config_file}" ]; then 
                write_log -f "${MOLE_LOG}" "E0000000 read_mole_section error:"\
                        "config file [${config_file}] not exists or empty.";
                return 2
        else 
                value=$(cat ${config_file} |\
                        grep -E -v "^[ \t]*;" | tr -d ' \t' |\
                        sed -e '/^\['${section}'\]$/!d; s/^\[//; s/\]$//;' 2>&-)
                if [ -n "${value}" ]; then 
                        echo "${value}" 
                        return 0
                else 
                        return 3
                fi   
        fi   
  fi
}

# According to input plugin-name config-name, output matched config-value in config file.
# Usage:  	read_mole_config [ -f  {config_file_path} ] {plugin-name} {config-name}
# Example:  	read_mole_config [ -f /tmp/.mole.ini.saveold] check_sysload  enable
# Return:	0 1 2 3 :  OK | Missging arguments | ${config_file} empty / not exist | Null
#
read_mole_config(){
  local Mode=0		# 0: auto  |   1: specified config file

  if [ "$1" == "-f" ]; then
	Mode=1
	local specified_file="$2"; shift 2
	local section=$1  key=$2  value=
  else
	Mode=0
  	local section=$1  key=$2  value=  config_file=
  fi

  if [ -z "${section}" -o -z "${key}" ]; then
	write_log -f "${MOLE_LOG}" "E0000000 read_mole_config error:"\
		"missing arguments, section=[${section}] key=[${key}]";
	return 1
  else
	if [ "${Mode}" == "0" ]; then		# automatic set {config_file}
		if is_sub "${section}" "${ARRAY_GLOBAL_SECTION[*]}"; then
			config_file="${CONFIG_FILE}"
  		elif [[ "${section}" =~ ${INNER_BEGIN} ]]; then
        		config_file="${CONFIG_FILE}"
  		else 
        		config_file="${CONF_DIR}/${section}.ini"
  		fi
	elif [ "${Mode}" == "1" ]; then		# set {config_file} according by specified file
		config_file="${specified_file}"
	fi

	if [ -f "${config_file}" -a -s "${config_file}" ]; then
		# this is too slow
		# value=$( ${PLUTIL} read_config "${section}" "${key}" "${config_file}" 2>&- |\
			 #sed -e 's/^[ \t]*//; s/[ \t]*$//;' 2>&- )
                value=$( cat ${config_file} | tr '\t' ' ' |\
                        awk -F"=" '\
                                ($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next}\
                                ( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit}\
                                ( k==1 && x==1 && $1~/^'${key}'\>/ ){gsub("^'${key}' *=","",$0);print;exit;}' 2>&- |\
                         sed -e 's/^[ \t]*//; s/[ \t]*$//;' 2>&- )
		if [ -n "${value}" ]; then
			echo "${value}" && return 0 
		else
			return 3
		fi
	else
		write_log -f "${MOLE_LOG}" "E0000000 read_mole_config error:"\
			"config file [${config_file}] not exists or empty.";
		return 2
	fi
  fi
}

# According to exist plugin-name/key and input value, update matched value in config file.
# Usage:	update_mole_config [force] {plugin-name} {config-name} {value}
# Example:	update_mole_config 	       check_sysload enable no
# Return:	
# 0 : Update OK
# 1 : Update ERROR
# 2 : No Need, Nothing to do (nower value equals what you want to set)
# 3 : Missging arguments
# 4 : ${config_file} empty / not exist 
# 5 : [section].key not exist
# 9 : WARN -> update global.id global.name global.parter_id
# LogFlag:      CHNG0000
# 
update_mole_config() {
  local mode=$1 
  if [ "${mode}" == "force" ]; then   ### only called by bin/setinit
 	local section=$2 key=$3 ; shift 3 ; local value=$*
  else
  	local section=$1 key=$2 ; shift 2 ; local value=$*
  fi
  local errinfo=  config_file=
  if [ -z "${section}" -o -z "${key}" -o -z "${value}" ]; then
        write_log -f "${MOLE_LOG}" "E0000000 update_mole_config error:"\
		"missing arguments, section=[${section}] key=[${key}] value=[${value}]";
        return 3
  else
	# return 9(warn) if global.id global.name
	if [ "${section}" == "global" -a "${key}" == "id" -a "${mode}" != "force" ]; then
		return 9
	elif [ "${section}" == "global" -a "${key}" == "name" -a "${mode}" != "force" ]; then
		return 9
        elif [ "${section}" == "global" -a "${key}" == "parter_id" -a "${mode}" != "force" ]; then                
                return 9
	fi
	# set config_file
	if is_sub "${section}" "${ARRAY_GLOBAL_SECTION[*]}"; then
        	config_file="${CONFIG_FILE}"
  	elif [[ "${section}" =~ ${INNER_BEGIN} ]]; then
        	config_file="${CONFIG_FILE}"
  	else 
        	config_file="${CONF_DIR}/${section}.ini"
  	fi

	if [ -f "${config_file}" -a -s "${config_file}" ]; then
  		local linenum=$( cat ${config_file} | tr '\t' ' ' |\
				 awk -F"=" '\
					($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next}\
					( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit}\
					( k==1 && x==1 && $1~/^'${key}'\>/ ){print NR;exit;}' )
  		if [ -z "${linenum}" ]; then
			write_log -f "${MOLE_LOG}" "CHNG0000 update_mole_config notice:"\
				"section=[${section}] key=[${key}] not found in config file."
			return 5
  		else
			local nowvalue=$(read_mole_config "${section}" "${key}")
			if [ "${value}" != "${nowvalue}" ]; then
				write_log -f "${MOLE_LOG}" "CHNG0000 update_mole_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					 "line-number=[${linenum}], nower value=[${nowvalue}],"\
					 "trying to change as [${value}]"
			else
				write_log -f "${MOLE_LOG}" "CHNG0000 update_mole_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					"line-number=[${linenum}], nower value=[${nowvalue}],"\
					"no need to change as [${value}], nothing to do."
				return 2
			fi
                        ### '"${value}"' is important, if ${value} is multi part or cotains invalid chars, sed won't complain
                        ### '${value}' is wrong.
			### sed command c to replace the whole line.
			errinfo=$(\
			    sed -i ''${linenum}'c'"${key}"' = '"${value}"'' "${config_file}" 2>&1 1>/dev/null)
			if [ "$?" == "0" ]; then
				write_log -f "${MOLE_LOG}" "CHNG0000 update_mole_config change"\
					"section=[${section}] key=[${key}] value=[${value}] line-number=[${linenum}]"\
					"success"
				return 0
			else
				write_log -f "${MOLE_LOG}" "CHNG0000 update_mole_config error:"\
					"section=[${section}] key=[${key}] value=[${value}] line-number=[${linenum}]"\
					"errinfo=[${errinfo}]" 
				return 1
			fi
  		fi
	else
		write_log -f "${MOLE_LOG}" "E0000000 update_mole_config error:"\
			"config file [${config_file}] not exists or empty.";
		return 4
	fi
  fi
}

# Clear value of specified plugin-name/key in config file.
# Usage:	clear_mole_config [force] {plugin-name} {config-name}
# Example:	clear_mole_config 	       check_sysload enable
# Return:	
# 0 : Clear OK
# 1 : Clear ERROR
# 2 : No Need, Nothing to do (nower value is already empty)
# 3 : Missging arguments
# 4 : ${config_file} empty / not exist 
# 5 : [section].key not exist
# 9 : WARN -> clear global.id global.name global.parter_id
# LogFlag:      CLER0000
# 
clear_mole_config() {
  local mode=$1 
  if [ "${mode}" == "force" ]; then   ### only called by bin/setinit
 	local section=$2 key=$3
  else
  	local section=$1 key=$2
  fi
  local errinfo=  config_file=
  if [ -z "${section}" -o -z "${key}" ]; then
        write_log -f "${MOLE_LOG}" "E0000000 clear_mole_config error:"\
		"missing arguments, section=[${section}] key=[${key}]";
        return 3
  else
	# return 9(warn) if global.id global.name
	if [ "${section}" == "global" -a "${key}" == "id" -a "${mode}" != "force" ]; then
		return 9
	elif [ "${section}" == "global" -a "${key}" == "name" -a "${mode}" != "force" ]; then
		return 9
        elif [ "${section}" == "global" -a "${key}" == "parter_id" -a "${mode}" != "force" ]; then                
                return 9
	fi
	# set config_file
	if is_sub "${section}" "${ARRAY_GLOBAL_SECTION[*]}"; then
        	config_file="${CONFIG_FILE}"
  	elif [[ "${section}" =~ ${INNER_BEGIN} ]]; then
        	config_file="${CONFIG_FILE}"
  	else 
        	config_file="${CONF_DIR}/${section}.ini"
  	fi

	if [ -f "${config_file}" -a -s "${config_file}" ]; then
  		local linenum=$( cat ${config_file} | tr '\t' ' ' |\
				 awk -F"=" '\
					($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next}\
					( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit}\
					( k==1 && x==1 && $1~/^'${key}'\>/ ){print NR;exit;}' )
  		if [ -z "${linenum}" ]; then
			write_log -f "${MOLE_LOG}" "CLER0000 clear_mole_config notice:"\
				"section=[${section}] key=[${key}] not found in config file."
			return 5
  		else
			local nowvalue=$(read_mole_config "${section}" "${key}")
			if [ -n "${nowvalue}" ]; then
				write_log -f "${MOLE_LOG}" "CLER0000 clear_mole_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					 "line-number=[${linenum}], nower value=[${nowvalue}],"\
					 "trying to clear it"
			else
				write_log -f "${MOLE_LOG}" "CLER0000 clear_mole_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					"line-number=[${linenum}], nower value=[${nowvalue}],"\
					"no need to clear it, nothing to do."
				return 2
			fi
			errinfo=$(\
			    sed -i ''${linenum}'c'"${key}"' =' "${config_file}" 2>&1 1>/dev/null)
			if [ "$?" == "0" ]; then
				write_log -f "${MOLE_LOG}" "CLER0000 clear_mole_config clear"\
					"section=[${section}] key=[${key}] line-number=[${linenum}]"\
					"success"
				return 0
			else
				write_log -f "${MOLE_LOG}" "CLER0000 clear_mole_config error:"\
					"section=[${section}] key=[${key}] line-number=[${linenum}]"\
					"errinfo=[${errinfo}]" 
				return 1
			fi
  		fi
	else
		write_log -f "${MOLE_LOG}" "E0000000 clear_mole_config error:"\
			"config file [${config_file}] not exists or empty.";
		return 4
	fi
  fi
}

# According to exist plugin-name and input key/value , add key = value into config file.
# Usage:        add_mole_config [force] {plugin-name} {config-name} {value}
# Example:      add_mole_config 	    check_sysload enable no
# Return:       
# 0 : ADD OK
# 1 : ADD ERROR
# 2 : No Need, Nothing to do (key already exist)
# 3 : Missging arguments
# 4 : ${config_file} empty / not exist 
# 5 : [section] not exist
# 9 : WARN -> add global.id global.name global.parter_id
# LogFlag:      ADDC0000
# 
add_mole_config() {
  local mode=$1 
  if [ "${mode}" == "force" ]; then   ### only called by bin/setinit
        local section=$2 key=$3 ; shift 3 ; local value=$*
  else 
        local section=$1 key=$2 ; shift 2 ; local value=$*
  fi
  local errinfo=  config_file=
  if [ -z "${section}" -o -z "${key}" -o -z "${value}" ]; then 
        write_log -f "${MOLE_LOG}" "E0000000 add_mole_config error:"\
                "missing arguments, section=[${section}] key=[${key}] value=[${value}]";
        return 3
  else 
	if [ "${section}" == "global" -a "${key}" == "id" -a "${mode}" != "force" ]; then
		return 9
	elif [ "${section}" == "global" -a "${key}" == "name" -a "${mode}" != "force" ]; then
		return 9
	elif [ "${section}" == "global" -a "${key}" == "parter_id" -a "${mode}" != "force" ]; then
		return 9
	fi
	# set config_file 
	if is_sub "${section}" "${ARRAY_GLOBAL_SECTION[*]}"; then
        	config_file="${CONFIG_FILE}"
  	elif [[ "${section}" =~ ${INNER_BEGIN} ]]; then
        	config_file="${CONFIG_FILE}"
  	else 
        	config_file="${CONF_DIR}/${section}.ini"
  	fi

	if [ -f "${config_file}" -a -s "${config_file}" ]; then
		local section_linenum=$( cat ${config_file} | tr '\t' ' ' |\
					awk '($0~/^ *\[ *'${section}' *\] *$/){print NR;exit;}' )
		if [ -z "${section_linenum}" ]; then
			write_log -f "${MOLE_LOG}" "ADDC0000 add_mole_config notice:"\
				"section=[${section}] not found in config file."
                        return 5
		else
			local flag=0
			for k in `list_section_keys "${section}"`
			do
				if [ "${key}" != "${k}" ]; then
					continue
				else
					flag=1; break
				fi
			done
			if [ "${flag}" == "0" ]; then
                                write_log -f "${MOLE_LOG}" "ADDC0000 add_mole_config notice:"\
                                        "key=[${key}] for section=[${section}] not found in config file,"\
                                        "trying to add config [${key}] for [${section}]"\
					"under line [${section_linenum}]"
			else
                                write_log -f "${MOLE_LOG}" "ADDC0000 add_mole_config notice:"\
                                        "key=[${key}] for section=[${section}] already exists in config file,"\
                                        "no need to add config [${key}] for [${section}], nothing to do."
				return 2
			fi
			### '"${value}"' is important, if ${value} is multi part or cotains invalid chars, sed won't complain
			### '${value}' is wrong.
			### sed command a to add newline under specified line.
			errinfo=$(\
				sed -i ''${section_linenum}'a'"${key}"' = '"${value}"'' "${config_file}" 2>&1 1>/dev/null)
                        if [ "$?" == "0" ]; then 
                                write_log -f "${MOLE_LOG}" "ADDC0000 add_mole_config add"\
                                        "config [${key} = ${value}] for section [${section}] under [${section_linenum}]"\
                                        "success"
                                return 0
                        else 
                                write_log -f "${MOLE_LOG}" "ADDC0000 add_mole_config error: [${errinfo}]" 
                                return 1
                        fi
		fi
	else
                write_log -f "${MOLE_LOG}" "E0000000 add_mole_config error:"\
                        "config file [${config_file}] not exists or empty.";
                return 4
	fi
  fi
}

# According to exist plugin-name and input key , delete plugin's key from config file.
# Usage:        del_mole_config {plugin-name} {config-name}
# Example:      del_mole_config check_sysload enable
# Return:
# 0 : DEL OK
# 1 : DEL ERROR
# 2 : No Need, Nothing to do (key already not exist)
# 3 : Missging arguments
# 4 : ${config_file} empty / not exist 
# 5 : [section] not exist
# 9 : WARN -> del global.id global.name global.parter_id
# LogFlag:	DELC0000
#
del_mole_config() {
  local section=$1 key=$2 config_file=
  local errinfo=
  if [ -z "${section}" -o -z "${key}" ]; then
        write_log -f "${MOLE_LOG}" "DELC0000 del_mole_config error:"\
		"missing arguments, section=[${section}] key=[${key}]";
        return 3
  else
	# return 9(warn) if global.id global.name
	if [ "${section}" == "global" -a "${key}" == "id" ]; then
		return 9
	elif [ "${section}" == "global" -a "${key}" == "name" ]; then
		return 9
	elif [ "${section}" == "global" -a "${key}" == "parter_id" ]; then
		return 9
	fi
	# set config_file 
	if is_sub "${section}" "${ARRAY_GLOBAL_SECTION[*]}"; then
        	config_file="${CONFIG_FILE}"
  	elif [[ "${section}" =~ ${INNER_BEGIN} ]]; then
        	config_file="${CONFIG_FILE}"
  	else 
        	config_file="${CONF_DIR}/${section}.ini"
  	fi

	if [ -f "${config_file}" -a -s "${config_file}" ]; then
		local section_linenum=$( cat ${config_file} | tr '\t' ' ' |\
					awk '($0~/^ *\[ *'${section}' *\] *$/){print NR;exit;}' )
		if [ -z "${section_linenum}" ]; then 
			write_log -f "${MOLE_LOG}" "DELC0000 del_mole_config notice:"\
				"section=[${section}] not found in config file."
			return 5
  		else
			local nowvalue=$(read_mole_config "${section}" "${key}")
			local flag=0
			for k in `list_section_keys "${section}"`
			do
				if [ "${key}" != "${k}" ]; then
					continue
				else
					flag=1; break
				fi
			done
			if [ "${flag}" == "1" ]; then
  				local linenum=$( cat ${config_file} | tr '\t' ' ' |\
				 	awk -F"=" '\
						($0~/^ *\[ *'${section}' *\] *$/){k=1;x=1;next}\
						( x==1 && $0~/^ *\[ *.* *\] *$/ && $0!~/^ *\[ *'${section}' *\] *$/ ){exit}\
						( k==1 && x==1 && $1~/^'${key}'\>/ ){print NR;exit;}' )
				write_log -f "${MOLE_LOG}" "DELC0000 del_mole_config notice:"\
					"section=[${section}] key=[${key}] found in config file,"\
					 "line-number=[${linenum}], nower value=[${nowvalue}],"\
					 "trying to delete config [${key}]"
			else
				write_log -f "${MOLE_LOG}" "DELC0000 del_mole_config notice:"\
					"section=[${section}] key=[${key}] not found in config file,"\
					"no need to delete it, nothing to do."
				return 2
			fi
			### sed command d to delete the whole line.
			errinfo=$(\
			    sed -i ''${linenum}'d' "${config_file}" 2>&1 1>/dev/null)
			if [ "$?" == "0" ]; then
				write_log -f "${MOLE_LOG}" "DELC0000 del_mole_config delete"\
					"section=[${section}] key=[${key}] line-number=[${linenum}]"\
					"success"
				return 0
			else
				write_log -f "${MOLE_LOG}" "DELC0000 del_mole_config error:"\
					"section=[${section}] key=[${key}] line-number=[${linenum}]"\
					"errinfo=[${errinfo}]" 
				return 1
			fi
  		fi
	else
		write_log -f "${MOLE_LOG}" "DELC0000 del_mole_config error:"\
			"config file [${config_file}] not exists or empty.";
		return 4
	fi
  fi
}


# Get global name		config-name:  name
# Note: if returned config-value is empty. return "mole__ops.eyou.net"
#
get_global_name() {
  local result=  default="mole__ops.eyou.net"
  result=$(read_mole_config global name)
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}

# Get mole id			config-name:  id
# Note: if returned config-value is empty. return "0000000000"
#
get_mole_id() {
  local result=  default="0000000000"
  result=$(read_mole_config global id)
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}

# Get parter id			config-name:  parter_id
# Note: if returned config-value is empty. return "0000000000"
#
get_parter_id() {
  local result=  default="0000000000"
  result=$(read_mole_config global parter_id)
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}

# Get scan interval		config-name:  scan_interval
# Note: if returned config-vlaue is invalid, return 5
# Note: scan interval can't smaller than 5
#
get_scan_interval() {
  local result= default=5 min=5
  result=$(read_mole_config global scan_interval)
  if ! is_int "${result}"; then
	result=${default}
  else
	[ ${result} -lt ${min} ] && result=${min}
  fi
  echo "${result}"
}

# Get attach ini mail                   config-name:  attach_ini_mail
# Note: if returned config-value is empty. return "yes"
#
get_attach_ini_mail() {
  local result= default="yes"
  result=$(read_mole_config global attach_ini_mail)
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}

# Get sysload uplimit			config-name:  sysload_uplimit
# Note: if returned config-value is invalid, return 30
#
get_sysload_uplimit() {
  local result= default=30
  result=$(read_mole_config global sysload_uplimit)
  if ! is_int "${result}"; then
	 result=${default}
  fi
  echo "${result}"
}

# Get max kids number 			config-name:  max_kidsnum
# Note: if returned config-value is invalid, return 50
#
get_max_kidsnum() {
  local result= default=50
  result=$(read_mole_config global max_kidsnum)
  if ! is_int "${result}"; then
	 result=${default}
  fi
  echo "${result}"
}

# Get plugin output max length 			config-name:  plugin_maxlen
# Note: if returned config-value is invalid, return 65536
# Note: plugin_maxlen can't larger than 65536
#
get_plugin_maxlen() {
  local result= default=65536 max=65536
  result=$(read_mole_config global plugin_maxlen)
  if ! is_int "${result}"; then
	 result=${default}
  else
	[ ${result} -gt ${max} ] && result=${max}
  fi
  echo "${result}"
}

# Get handler output max length 			config-name:  handler_maxlen 
# Note: if returned config-value is invalid, return 32768
# Note: handler_maxlen can't larger than 32768
#
get_handler_maxlen() {
  local result= default=32768 max=32768
  result=$(read_mole_config global handler_maxlen)
  if ! is_int "${result}"; then
	 result=${default}
  else
	[ ${result} -gt ${max} ] && result=${max}
  fi
  echo "${result}"
}

# Get plugin notify on misform				config-name:  notify_onmisform
# Note: if returned config-value is invalid, return yes
#
get_notify_onmisform() {
  local result= default="yes"
  result=$(read_mole_config global notify_onmisform)
  [ -z "${result}" ] && result=${default}
  echo "${result}"
}

# Get global locale					config-name:  notify_onmisform
# Note: if returned config-value is invalid, return zh_CN.UTF-8
#
get_global_locale() {
  local result= default="zh_CN.UTF-8"
  result=$(read_mole_config global locale)
  [ -z "${result}" ] && result=${default}
  echo "${result}"
}

# Get global logo_link					config-name:  logo_link
# Note: if returned config-value is empty, return http://esop.eyou.net
#
get_logo_link() {
  local result= default="http://esop.eyou.net"
  result=$(read_mole_config global logo_link)
  [ -z "${result}" ] && result=${default}
  echo "${result}"
}

# Get global logo_url					config-name:  logo_url
# Note: if returned config-value is empty, return  http://esop.eyou.net/mc/tpl/public/images/logo/normal.png
#
get_logo_url() {
  local result= default="http://esop.eyou.net/mc/tpl/public/images/logo/normal.png"
  result=$(read_mole_config global logo_url)
  [ -z "${result}" ] && result=${default}
  echo "${result}"
}

# Get plugin enable status		config-name:  enable
# Note: if returned config-value is invalid, return no
#
get_enable() {
  local plugin_name=$1  default="no" result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 get_enable error: missing plugin name";
	return 1
  }
  result=$(read_mole_config ${plugin_name} enable)
  [ -z "${result}" ] && result=$(read_mole_config default enable)

  # check valid or not
  [ -z "${result}" ] && {
	result="${default}"
  } || {
  	[ "${result}" != "yes" -a "${result}" != "no" ] && result="${default}"
  }
  echo "${result}"
}

# Get plugin debug	config-name:  debug
# Note: if returned config-value is invalid, return yes
#
get_debug() {
  local plugin_name=$1  default="yes" result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_debug error: missing plugin name";
        return 1
  }
  result=$(read_mole_config ${plugin_name} debug)
  [ -z "${result}" ] && result=$(read_mole_config default debug)
 
  # check valid or not
  [ -z "${result}" ] && {
        result="${default}"
  } || {
        [ "${result}" != "yes" -a "${result}" != "no" ] && result="${default}"
  }
  echo "${result}"
}

# Get plugin attsnap_mail config-name:  attsnap_mail
# Note: called by script: bin/sendmail
# Note: if returned config-value null or invalid, return no
#
get_attsnap_mail() {
  local plugin_name=$1  default="no" result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_attsnap_mail error: missing plugin name";
        return 1
  }

  result=$(read_mole_config ${plugin_name} attsnap_mail)
  [ -z "${result}" ] && result=$(read_mole_config default attsnap_mail)
  # check null or invalid or not
  [ -z "${result}" ] && {
 	result="${default}"
  } || {
  	[ "${result}" != "yes" -a "${result}" != "no" ] && result="${default}"
  }
  echo "${result}"
}

# Get plugin frequency    config-name: frequency
# Note: if returned config-value is invalid, return 30min
#
get_frequency() {
  local plugin_name=$1  result=  value=   default="30min"  min=30
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_frequency error: missing plugin name";
        return 1
  }
  result=$(read_mole_config ${plugin_name} frequency)
  [ -z "${result}" ] && result=$(read_mole_config default frequency)

  # check valid or not
  value=$( conv_time2sec "${result}" )
  if [ "${value}" == "invalid" ]; then
	write_log -f "${MOLE_LOG}" "E0000000 get_frequency on"\
		"[${plugin_name}]: return is invalid:"\
		"[${result}] ==> auto set to ${default}.";
	result="${default}"
  elif is_int "${value}"; then
	[ "$(echo "${value} < ${min}" | bc 2>&-)" == "1" ] && {
		write_log -f "${MOLE_LOG}" "E0000000 get_frequency on"\
			"[${plugin_name}]: return [${result}] is smaller than minimum"\
			"==> auto set to ${min}sec";
		result="${min}sec"
	}
  fi
  echo "${result}"
}

# Get plugin execution timeout      config-name:  exec_tmout
# Note: if returned config-value is invalid. return 10min
# 
get_exec_tmout() {
  local plugin_name=$1  result=  value=  default="10min"
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_exec_tmout error: missing plugin name";
        return 1
  }
  result=$(read_mole_config ${plugin_name} exec_tmout)
  [ -z "${result}" ] && result=$(read_mole_config default exec_tmout)

  # check valid or not
  value=$( conv_time2sec "${result}" )
  [ "${value}" == "invalid" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_exec_tmout on [${plugin_name}]:"\
		"return is invalid: [${result}]"\
		"==>auto set to ${default}.";
        result="${default}"
  }
  echo "${result}"
}

# Get plugin mail receviers	config-name:  mail_receviers
# called by script bin/sendmail
# Note: if returned email address is empty. return "root_bbk@126.com"
#
get_mail_receviers() {
  local plugin_name=$1  result=	 default="root_bbk@126.com"
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_mail_receviers error: missing plugin name";
        return 1
  }
  result=$(read_mole_config ${plugin_name} mail_receviers)
  [ -z "${result}" ] && result=$(read_mole_config default mail_receviers)

  if [ -f "/${result##*file:}" -a -s "/${result##*file:}" ]; then
        result=$(awk '($0!~/^[ \t]*#/) { for(i=1;i<=NF;i++) {printf "%s ",$i} }' "/${result##*file:}")
  elif [ -f "${BASE_DIR}/${result##*file:}" -a -s "${BASE_DIR}/${result##*file:}" ]; then
        result=$(awk '($0!~/^[ \t]*#/) { for(i=1;i<=NF;i++) {printf "%s ",$i} }' "${BASE_DIR}/${result##*file:}")
  else
        [ -z "${result}" ] && result="${default}"  ### set default whatever.
  fi
  echo -en "${result}"
}

# Get plugin sms receviers	config-name:  sms_receviers
#
get_sms_receviers() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_sms_receviers error: missing plugin name";
        return 1
  }
  result=$(read_mole_config ${plugin_name} sms_receviers)
  [ -z "${result}" ] && result=$(read_mole_config default sms_receviers)

  if [ -f "/${result##*file:}" -a -s "/${result##*file:}" ]; then
        result=$(awk '($0!~/^[ \t]*#/) { for(i=1;i<=NF;i++) {printf "%s ",$i} }' "/${result##*file:}")
  elif [ -f "${BASE_DIR}/${result##*file:}" -a -s "${BASE_DIR}/${result##*file:}" ]; then
        result=$(awk '($0!~/^[ \t]*#/) { for(i=1;i<=NF;i++) {printf "%s ",$i} }' "${BASE_DIR}/${result##*file:}")
  fi
  echo -en "${result}"
}

# Get plugin auto handler	config-name auto_handler
# called by process_plugin
#
get_auto_handler() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 get_auto_handler error: missing plugin name";
	return 1
  }
  result=$(read_mole_config ${plugin_name} auto_handler)
  [ -z "${result}" ] && result=$(read_mole_config default auto_handler)
  echo -e "${result}"
}


# Get plugin comment		config-name:  comment
# Note: if returned config-value is empty. return "Mole Plugin"
#
get_comment() {
  local plugin_name=$1  result=  default="Mole Plugin"
  [ -z "${plugin_name}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 get_comment error: missing plugin name";
	return 1
  }
  result=$(read_mole_config ${plugin_name} comment)
  [ -z "${result}" ] && result=$(read_mole_config default comment)
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}


# Get plugin locale		config-name:  locale
# Note: if returned config-value is empty. return "zh_CN.UTF-8"
#
get_locale() {
  local plugin_name=$1  result=  default="zh_CN.UTF-8"
  [ -z "${plugin_name}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 get_locale error: missing plugin name";
	return 1
  }
  result=$(read_mole_config ${plugin_name} locale)
  [ -z "${result}" ] && result=$(read_mole_config default locale)
  [ -z "${result}" ] && result="${default}"
  echo "${result}"
}

# Get plugin max repeat errtimes	config-name:  maxerr_times
# Note: if returned config-value is invalid. return 1
#
get_maxerr_times() {
  local plugin_name=$1  result=	 default=1
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_maxerr_times error: missing plugin name";
        return 1
  }
  result=$(read_mole_config ${plugin_name} maxerr_times)
  [ -z "${result}" ] && result=$(read_mole_config default maxerr_times)

  # check valid or not ==> ( 0 is invalid )
  [ -z "${result}" -o ! -z "${result//[1-9]}" ] && result=${default}  # set default whatever.
  echo "${result}"
}

# Check Notify Policy is valid or not ?
# Note:	return 0 means valid, otherwise invalid
# Return Code:
# 	0	valid
#	1	empty policy 
#	2	policy not combined by two part which seperated by blank
#	3	max_repeat_time not integer
#	4	max_repeat_time not between 0-99999
#	5	one of range_pair not combined by two part which seperated by -
#	6	one of range_start not integer or not between 0-23
#	7	one of range_stop not integer or not between 1-24
#	8	one of range_start larger or equal range_stop
# 
valid_notify_policy() {
  local policy="${1}"	v="${2}"
  [ -z "${policy//[ ]}" ] && return 1

  local policy_array=( ${policy} )
  [ ${#policy_array[*]} -ne 2 ] && return 2

  local p1=${policy_array[0]} p2=${policy_array[1]}
  if [ "${p2}" == "-1" ]; then
	:
  elif ! is_int "${p2}"; then
	return 3
  elif ! is_between "$((10#${p2}))" 0 9999; then  # use 10hex convetion after int check to avoid error complain
	return 4
  fi

  local range_array=(  ${p1//,/ }  )
  for ((i=0;i<${#range_array[*]};i++))
  do
	local range_pair=${range_array[$i]}
	local pair_array=( ${range_pair//-/ } )
	[ ${#pair_array[*]} -ne 2 ] && return 5
	
	local s=${pair_array[0]} e=${pair_array[1]}
	if ! is_int "${s}" || ! is_between "$((10#${s}))" 0 23; then # use 10hex convetion after int check to avoid error complain 
		return 6
	fi

	if ! is_int "${e}" || ! is_between "$((10#${e}))" 1 24; then # use 10hex convetion after int check to avoid error complain 
		return 7
	fi

	if [ ${s} -ge ${e} ]; then
		return 8
	fi
  done

  return 0
}

# Get plugin mail notify policy		config-name:  mail_policy
# Note: if returned config-value is invalid, return  0-24 3
#
get_mail_policy() {
  local plugin_name=$1  result=  default="0-24 3"
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_mail_policy error: missing plugin name";
        return 1
  }
  result=$(read_mole_config ${plugin_name} mail_policy)
  [ -z "${result}" ] && result=$(read_mole_config default mail_policy)

  # check valid or not 
  valid_notify_policy "${result}" || result=${default}

  echo "${result}"
}

# Get plugin SMS notify policy		config-name:  sms_policy
# Note: if returned config-value is invalid, return  0-24 3
#
get_sms_policy() {
  local plugin_name=$1  result=  default="0-24 3"
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_sms_policy error: missing plugin name";
        return 1
  }
  result=$(read_mole_config ${plugin_name} sms_policy)
  [ -z "${result}" ] && result=$(read_mole_config default sms_policy)

  # check valid or not 
  valid_notify_policy "${result}" || result=${default}

  echo "${result}"
}

# Get plugin notify analysization
# Note:		args {notify_policy_config} must have been valid checked to avoid error occurs.
# 		you shoule pass {notify_policy_config} through function get_sms/mail_policy()
# Usage: 	get_policy_analysize {notify_plicy_config} {part}  [hrformat]
# Note:	 	{part}		~ range | rtime
# Note:		[hrformat] is only used on {part} = range to format range as human-reabable
# Example:	get_policy_analysize  "0-09,07-11,13-20,10-19  5"  range
# Example:	get_policy_analysize  "0-09,07-11,13-20,10-19  5"  range  hrformat
#
get_policy_analysize() {
  local notify_policy="${1}"  part="${2}"  result=

  [ -z "${notify_policy//[ ]}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 get_policy_analysize error: missing notify policy to be analysized.";
	return 1
  }
  [ "${part}" != "range" -a "${part}" != "rtime" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 get_policy_analysize error: required part [${part}] not recognized.";
	return 2
  }

  local policy_array=( ${notify_policy} )
  if [ "${part}" == "range" ]; then
  	local p1=${policy_array[0]}
  	local range_array=(  ${p1//,/ }  )
  	for ((i=0;i<${#range_array[*]};i++))
  	do
		local range_pair=${range_array[$i]}
		local pair_array=( ${range_pair//-/ } )
		local s=${pair_array[0]} e=${pair_array[1]}
		for ((x=$((10#${s}));x<$((10#${e}));x++))
		do
			result="${result} ${x}"
		done
  	done
	# remove duplication items on part=range
	result=$(echo "${result}" | awk -vRS="[\n ]" -vORS=" " '!a[$0]++')

	# [hrformat] is only used on {part} = range
	if [ "${3}" == "hrformat" ]; then
		# sort result items first
		local sorted_result=( $( echo "${result}" |\
			 awk '{split($0,A," "); len=asort(A,tA); for(i=1;i<=len;i++){printf "%d ",tA[i]} }' 2>&- ) )
		# merge sequenced items as time range
		if [ ${#sorted_result[*]} -eq 0 ]; then
			result=
		else
			result="${sorted_result[0]}:00"
			for((i=1;i<${#sorted_result[*]}-1;i++))
			do
				if (( ${sorted_result[${i}]} - ${sorted_result[${i}-1]} > 1 )); then	# if on break point
					result="${result}-$((${sorted_result[${i}-1]}+1)):00, ${sorted_result[${i}]}:00" 
				fi
			done
			result="${result}-$((${sorted_result[${#sorted_result[*]}-1]}+1)):00"
		fi
	fi
  elif [ "${part}" == "rtime" ]; then
	result=$((10#${policy_array[1]}))
  fi

  echo "${result}"
}

# Get plugin's xxxx_action_type value.		
# allowed action_type ==> [ take_snapshot | mail_notify | sms_notify | post_notify | auto_handle ]
# Usage:      get_action_type  plugin-name  xxxx_action_type
# Example:	get_action_type  check_sysload mail_notify
# Note: invalid values will be ignored, only return valid values.
# Note: duplication items will be removed.
# Return:  1: plugin_name or action_type empty  2: action_type invalid
#
get_action_type() {
  local plugin_name=$1  action_type=$2
  local result=  output=  item=
  [ -z "${plugin_name}" -o -z "${action_type}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_action_type error:"\
		"missing plugin_name or action_type : [$*]";
        return 1
  }
  [ "${action_type}" != "take_snapshot" -a "${action_type}" != "mail_notify" -a "${action_type}" != "post_notify" -a "${action_type}" != "auto_handle" -a "${action_type}" != "sms_notify" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 get_action_type error:"\
		"action_type: [${action_type}] is invalid,"\
		"only [ take_snapshot/mail_notify/sms_notify/post_notify/auto_handle ] is acceptable.";
	return 2
  }

  ### read values
  result=$(read_mole_config ${plugin_name} ${action_type})
  [ -z "${result}" ] && result=$(read_mole_config default ${action_type})

  ### unfolder [all|default|none] and remove invalid values.
  for item in `echo "${result}"`
  do
	if is_sub "${item}" "${VALID_ACTION_CONFIG}" ; then  ### item valid
		case "${item}" in
		"all")
			output="${output} crit warn unkn succ notify recovery tmout "	;;
		"default")
			output="${output} crit warn unkn notify recovery tmout"		;;
		"none")
			output="none"  ### break while "none"
			break						;;
		*)
			output="${output} ${item}"
		esac	
	fi
  done

  ### remove duplication items.
  output=$(echo "${output}" | awk -vRS="[\n ]" -vORS=" " '!a[$0]++')
  echo "${output}"
}

# Take action or not
# Argument 1:  plugin-name
# Argument 2:  action_type => take_snapshot mail_notify sms_notify post_notify auto_handle
# Argument 3:  event	=> 0 1 2 3 4 5 tmout recovery
# Example:	take_action_ornot  check_sysload mail_notify 3
# Example:	take_action_ornot  check_v4_ps post_notify 0
# Example:	take_action_ornot  check_cpu_usage take_snapshot tmout
# 
take_action_ornot() {
  local plugin_name=$1  action_type=$2  event=$3
  local result=
  [ -z "${plugin_name}" -o -z "${action_type}" -o -z "${event}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 take_action_ornot error:"\
		"missing plugin_name or action_type or event : [$*]";
        return 1
  }
  
  ### 1. read plugin_name action_type
  local action_type_config=$(get_action_type ${plugin_name} ${action_type})

  ### 2. event in actinon_type or not ? 
  local status=
  if [ "${event}" == "tmout" ]; then  ### 2.1 process event: tmout 
	if is_sub "${event}" "${action_type_config}"; then
		result="yes"
	else
		result="no"
	fi
  elif [ "${event}" == "recovery" ]; then	### 2.1 process event: recovery
	if is_sub "${event}" "${action_type_config}"; then
		result="yes"
	else
		result="no"
	fi
  else
  	for ((i=0;i<=${#ARRAY_RCSTATUS_MAPS[@]}-1;i++))  ### 2.2 process event: return_code
  	do
		[ "${ARRAY_RCSTATUS_MAPS[${i}]}" == "${event}" ] && {
			local i2=$((${i}+1))
			status=${ARRAY_RCSTATUS_MAPS[${i2}]}
			if is_sub "${status}" "${action_type_config}"; then
				result="yes"
			else
				result="no"
			fi
			break
		}
  	done
	[ -z "${result}" ] && result="no"   ### if not matched, return no
  fi
  echo "${result}"
}

# Convert timelong to seconds
# Output:	seconds	| invalid
# Example:	conv_time2sec  30sec | 30seconds | 1hour | 1day | 2week | 3month | 4year | 2day5hour54sec
#
conv_time2sec(){
  local timelong=$1 result=
  local now=$(date +%s)
  local after=$(date -d "+${timelong}" +%s 2>&-)
  if is_int "${after}"; then
	result=$(echo "${after} - ${now}" | bc 2>&-)
  else
	write_log -f "${MOLE_LOG}" "E0000000 conv_time2sec error:"\
		"input invalid: ${timelong}";
	result="invalid"
  fi
  echo "${result}"
}

# Get timestamp of plugin last-run.
# Output:	never_run | invalid_lastrun | "timestamps of last run"
#
get_lastrun() {
  local plugin_name=$1  result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 get_lastrun error: missing plugin name";
	return 1
  }
  if [ ! -s ${TMP_LASTRUN} ]; then
	result="never_run"
  else
  	result=$(awk '($1~/\<'${plugin_name}'\>/) {print $2;exit}' ${TMP_LASTRUN} 2>&-)
  	[ -z "${result}" ] && {
		result="never_run" 
	} || {
		[ ! -z "${result//[0-9]/}" ]  && result="invalid_lastrun"
	}
  fi
  echo "${result}"
}

# Get timestamp of plugin next-run.
# Output:	null | invalid_nextrun | "timestamps of next run"
#
get_nextrun() {
  local plugin_name=$1 result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 get_nextrun error: missing plugin name";
	return 1
  }
  if [ ! -s ${TMP_NEXTRUN} ]; then
	result="null"
  else
	result=$(awk '($1~/\<'${plugin_name}'\>/) {print $2;exit}' ${TMP_NEXTRUN} 2>&-)
	[ -z "${result}" ] && {
		result="null"
	} || {
		[ ! -z "${result//[0-9]/}" ]  && result="invalid_nextrun"
	}
  fi
  echo "${result}" 
}

# Update timestamp of plugin last-run and next-run
# Note: 	only called on plugin finished.
# LogFlag:	CRIT0000 | 00000000
#
update_lastrun_and_nextrun() {
  local plugin_name=$1  jobid=$2	# get jobid only for log record
  local rc=  errinfo=
  local now=$(date +%s) 
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  [ -z "${plugin_name}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 update_lastrun_and_nextrun error: missing plugin name";
	return 1
  }

  if [[ "${plugin_name}" =~ ${INNER_BEGIN} ]]; then
	local logfile="${INNER_LOG}"                                                                                   
  else
	local logfile="${MOLE_LOG}"
  fi

  /bin/touch ${TMP_LASTRUN} ${TMP_NEXTRUN}
  [ ! -s ${TMP_LASTRUN} ] && echo -e "${headline}" > ${TMP_LASTRUN}
  [ ! -s ${TMP_NEXTRUN} ] && echo -e "${headline}" > ${TMP_NEXTRUN}

  # Step 1: first update last-run
  # following sed command will lead to some repeat records.
  # sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${now}'/;tk;$s/$/\n'${plugin_name}' '${now}'/;:k'  ${TMP_LASTRUN}
  local l_time=$(awk '/^'${plugin_name}'\>/' ${TMP_LASTRUN} 2>&-)
  if [ -z "${l_time}" ]; then
	### only collect stderr output
	### '"${plugin_name}"' is important, sed won't complain if plugin_name contains multi part or special chars.
	errinfo=$( sed -i '$s/$/\n'"${plugin_name}"' '"${now}"'/' ${TMP_LASTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
		write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on:"\
			"[${plugin_name}] for [empty, add new lastrun item as nower: ${now}]"\
			"error: [${errinfo}]";
	else
		write_log -f "${logfile}" "$jobid update_lastrun_and_nextrun on:"\
			"[${plugin_name}] for [empty, add new lastrun item as nower: ${now}]"\
			"success";
	fi
  else
	### only collect stderr output
	### sed command c to replace the whole line.
	errinfo=$( sed -i '/^'"${plugin_name}"'\>/c'"${plugin_name}"' '"${now}"'' ${TMP_LASTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
                write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on:"\
			"[${plugin_name}] for [update lastrun time as nower: ${now}]"\
			"error: [${errinfo}]";
	else
		write_log -f "${logfile}" "$jobid update_lastrun_and_nextrun on:"\
			"[${plugin_name}] for [update lastrun time as nower: ${now}]"\
			"success";
	fi
  fi

  # Step 2: then read last-run and update next-run
  local lastrun=$(get_lastrun ${plugin_name})
  local frequency=$(get_frequency ${plugin_name})
  local nextrun=$(( ${lastrun} + $(conv_time2sec "${frequency}") ))
  # following sed command will lead to some repeat records.
  # sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${nextrun}'/;tk;$s/$/\n'${plugin_name}' '${nextrun}'/;:k' ${TMP_NEXTRUN}
  local n_time=$( awk '/^'${plugin_name}'\>/' ${TMP_NEXTRUN} 2>&-)
  if [ -z "${n_time}" ]; then
	### only collect stderr output
	### '"${plugin_name}"' is important, sed won't complain if plugin_name contains multi part or special chars.
        errinfo=$( sed -i '$s/$/\n'"${plugin_name}"' '"${nextrun}"'/' ${TMP_NEXTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
                write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on:"\
			"[${plugin_name}] for [empty, add new nextrun item as ${nextrun} (${frequency} later)]"\
			"error: [${errinfo}]";
	else
                write_log -f "${logfile}" "$jobid update_lastrun_and_nextrun on:"\
			"[${plugin_name}] for [empty, add new nextrun item as ${nextrun} (${frequency} later)]"\
			"success";
	fi
  else
	### only collect stderr output
	### sed command c to replace the whole line.
        errinfo=$( sed -i '/^'${plugin_name}'\>/c'"${plugin_name}"' '"${nextrun}"'' ${TMP_NEXTRUN} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
                write_log -f "${logfile}" "CRIT0000 update_lastrun_and_nextrun on:"\
			"[${plugin_name}] for [update nextrun as ${nextrun}] (${frequency} later)"\
			"error: [${errinfo}]";
	else
                write_log -f "${logfile}" "$jobid update_lastrun_and_nextrun on:"\
			"[${plugin_name}] for [update nextrun as ${nextrun}] (${frequency} later)"\
			"success";
        fi
  fi
  return ${rc}
}


# Update status of plugin result.
# Note:         only called on plugin finished or output result.
#
update_status() {
  local plugin_name=${1} jobid=${2}; shift 2
  local content=$*
  local rc= errinfo= 
  local now=$(date +%s)
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 update_status error: missing plugin name";
        return 1
  }

  if [[ "${plugin_name}" =~ ${INNER_BEGIN} ]]; then
	local logfile="${INNER_LOG}"                                                                                   
  else
	local logfile="${MOLE_LOG}"
  fi

  
  /bin/touch ${TMP_STATUS}
  [ ! -s ${TMP_STATUS} ] && echo -e "${headline}" > ${TMP_STATUS}

  local n_record="${plugin_name} ${jobid} ${now} ${content}"
  local l_record=$(awk '/^'${plugin_name}'\>/' ${TMP_STATUS} 2>&-)
  if [ -z "${l_record}" ]; then
	echo "${n_record}" >> ${TMP_STATUS} 2>/dev/null
	rc=$?
	if [ "${rc}" != "0" ]; then
	       write_log -f "${logfile}" "E0000000 update_status on:"\
			"[${plugin_name}] for [append newitem] error";
	else
	       write_log -f "${logfile}" "$jobid update_status on:"\
			"[${plugin_name}] for [append newitem] success";
	fi
  else
	### following sed command can NOT deal with special chars. (if ${content} contains /)
	# sed -i '/^'${plugin_name}'\>/s/.*/'${plugin_name}' '${now}' '${content}'/' ${TMP_STATUS}
	errinfo=$( sed -i '/^'"${plugin_name}"'\>/d' ${TMP_STATUS} 2>&1 1>/dev/null )
	rc=$?
	if [ "${rc}" != "0" ]; then
	       write_log -f "${logfile}" "E0000000 update_status on:"\
			"[${plugin_name}] for [delete olditem error: ${errinfo}]";
	else
	       write_log -f "${logfile}" "$jobid update_status on:"\
			"[${plugin_name}] for [delete olditem] success"
	       echo "${n_record}" >> ${TMP_STATUS} 2>/dev/null
	       rc=$?
	       if [ "${rc}" != "0" ]; then
			write_log -f "${logfile}" "E0000000 update_status on:"\
				"[${plugin_name}] for [append newitem] error";
	       else
			write_log -f "${logfile}" "$jobid update_status on:"\
				"[${plugin_name}] for [append newitem] success";
	       fi
	fi
  fi
  return ${rc}
}


# Get accumulated return-err number
# Usage:	get_repeat_errcount  plugin_name  [-v]
# Note:		-v only be used on add_repeat_errcount()
# Example:	get_repeat_errcount  check_sysload
# Example:	get_repeat_errcount  check_sysload -v
# Return:	0, [0-9]+
# Return:	if -v, return  null, invalid, [0-9]+
#
get_repeat_errcount() {
  local plugin_name=$1 mode=$2 result=

  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_repeat_errcount error: missing plugin name";
        return 1
  }

  result=$(awk '/^'${plugin_name}'\>/ {print $2;exit}' ${TMP_REPEAT} 2>&-)
  if [ -z "${result}" ]; then
	[ "${mode}" == "-v" ] && result="null" || result=0
  elif [ ! -z "${result//[0-9]}" ]; then
	[ "${mode}" == "-v" ] && result="invalid"  || result=0
  fi

  echo -e "${result}"

}

# Check accumulated return-err number overthan err-limit or not
# Usage:        is_reached_maxerr plugin_name
# Example:	is_reached_maxerr sysload
# Return:	0 | 1
# Output:	N:M	{N}: nower errcount   {M}: max errcount
#
is_reached_maxerr() {
  local plugin_name=$1 result=
  
  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 is_reached_maxerr error: missing plugin name";
        return 1
  }

  local max_errlimit=$(get_maxerr_times "${plugin_name}")
  local now_errcount=$(get_repeat_errcount "${plugin_name}")

  result="${now_errcount}:${max_errlimit}"
  if [ "$(echo "${now_errcount}>=${max_errlimit}" | bc 2>&-)" == "1" ]; then
	echo "${result}"
	return 0    # reached  
  else
	echo "${result}"
	return 1    # unreached
  fi
}

# Accumulated return-err number +1 
# Note: 	only called at plugin return: 1-WARN, 2-CRIT, 3-UNKN 
# Usage:        add_repeat_errcount  plugin_name  [jobid]
# Example:	add_repeat_errcount  check_sysload  [jobid]
# Note:   null 	        =>   insert new as 1
# 	  invalid	=>   update to 1
#         numberic	=>   update to +1
#
add_repeat_errcount() {
  local plugin_name=$1  jobid=$2	# get jobid only for log record
  local rc=  errinfo=
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"

  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 add_repeat_errcount error: missing plugin name";
        return 1
  }

  /bin/touch ${TMP_REPEAT}
  [ ! -s ${TMP_REPEAT} ] && echo -e "${headline}" > ${TMP_REPEAT}

  local repeat_errcount=  num=  mode=
  repeat_errcount=$(get_repeat_errcount "${plugin_name}" -v)
  if [ "${repeat_errcount}" == "null" ]; then
	num=1;
	mode="add"
  elif [ "${repeat_errcount}" == "invalid" ]; then
	num=1;
	mode="update"
  else
  	num=$(( ${repeat_errcount} + 1 ))  # update to +1
	mode="update"
  fi
  # only collect stderr output
  if [ "${mode}" == "update" ]; then
	# update old
  	errinfo=$( sed -i '/^'"${plugin_name}"'\>/c'"${plugin_name}"' '"${num}"'' ${TMP_REPEAT} 2>&1 1>/dev/null )
  elif [ "${mode}" == "add" ]; then
	# add new
	errinfo=$( sed -i '$s/$/\n'"${plugin_name}"' '"${num}"'/' ${TMP_REPEAT} 2>&1 1>/dev/null )   
  fi
  rc=$?
  if [ "${rc}" != "0" ]; then
	write_log -f "${MOLE_LOG}" "E0000000 add_repeat_errcount (mode=${mode}) on:"\
		"[${plugin_name}] for [ ${repeat_errcount} +1 = ${num} ]"\
		"error: [${errinfo}]";
  else
	write_log -f "${MOLE_LOG}" "$jobid add_repeat_errcount (mode=${mode}) on:"\
		"[${plugin_name}] for [ ${repeat_errcount} +1 = ${num} ]"\
		"success";
  fi

  return ${rc}
}

# Reset accumulated return-err number to 0
# Note:		only called at plugin return ok (zero)
# Example:	reset_repeat_errcount  check_sysload   [jobid]
#
reset_repeat_errcount() {
  local plugin_name=$1  jobid=$2	# get jobid only for log record
  local rc=  errinfo=
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"

  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 reset_repeat_errcount error: missing plugin name"
        return 1
  }

  /bin/touch ${TMP_REPEAT}
  [ ! -s ${TMP_REPEAT} ] && echo -e "${headline}" > ${TMP_REPEAT}

  # only collect stderr  output
  errinfo=$( sed -i '/^'"${plugin_name}"'\>/d' ${TMP_REPEAT} 2>&1 1>/dev/null)
  rc=$?
  if [ "${rc}" == "0" ]; then
	write_log -f "${MOLE_LOG}" "$jobid reset_repeat_errcount on"\
		"[${plugin_name}] success."
  else
	write_log -f "${MOLE_LOG}" "E0000000 reset_repeat_errcount on"\
		"[${plugin_name}] error: [${errinfo}]"
  fi

  return "${rc}"
}


# Get plugin's heaped up rc number
# Usage:        get_heapuprc_count plugin_name plugin_rc
# Example:      get_heapuprc_count check_sysload succ
# Return:       noplugin, noheaprc:{nower_rc}, null, invalid, [0-9]+
#	noplugin:	no such plugin
#	noheaprc:	no such rc and nower rc
#	null:		result empty
#	invalid:	result not numberic
#	[0-9]+		result normal (numberic)
#
get_heapuprc_count() {
  local plugin_name=$1  plugin_rc=$2  result=  heapup_date=

  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_heapuprc_count error: missing plugin name"
        return 1
  }

  [ -z "${plugin_rc}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_heapuprc_count error: missing plugin rc"
        return 1
  }

  result=$(awk '($1~/\<'${plugin_name}'\>/) {print $1;exit}' ${TMP_HEAPUPRC} 2>&-)
  if [ -z "${result}" ]; then
	result="noplugin"
  else
	local nowerrc_array=( $(awk '($1~/\<'${plugin_name}'\>/) {print $2,$3;exit}' ${TMP_HEAPUPRC} 2>&-) )
	local nower_rc=${nowerrc_array[0]}  nower_count=${nowerrc_array[1]}
	if [ "${nower_rc}" != "${plugin_rc}" ]; then
		result="noheaprc:${nower_rc}"
	else
  		result=${nower_count}	# set new result
  		if [ -z "${result}" ]; then
			result="null"
  		elif [ ! -z "${result//[0-9]}" ]; then
			result="invalid"
  		fi
	fi
  fi

  echo -e "${result}"
}

# Plugin's heaped up rc number +1 
# Note:         called at any event on plugin return
# Usage:        add_heapuprc_count plugin_name plugin_rc [jobid]
# Example:      add_heapuprc_count sysload succ [jobid]
# Note:   null          =>   update to 1
#         invalid       =>   update to 1
#	  noheaprc	=>   update to 1, this lead to clearing accumulated number on plugin status changed
#         numberic      =>   update to +1
#	  noplugin	=>   add new item as 1
#
add_heapuprc_count() {
  local plugin_name=$1  plugin_rc=$2  jobid=$3        # get jobid only for log record
  local rc=  errinfo=
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"

  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 add_heapuprc_count error: missing plugin name"
        return 1
  }

  [ -z "${plugin_rc}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 add_heapuprc_count error: missing plugin rc"
        return 1
  }

  /bin/touch ${TMP_HEAPUPRC}
  [ ! -s ${TMP_HEAPUPRC} ] && echo -e "${headline}" > ${TMP_HEAPUPRC}

  local heaped_upcount=  num=  mode=  change_from=
  heaped_upcount=$(get_heapuprc_count "${plugin_name}" "${plugin_rc}")
  if [ "${heaped_upcount}" == "noplugin" ]; then	# plugin item not exist, add a new one
	num=1;
	mode="add"
  elif [[ "${heaped_upcount}" =~ "noheaprc" ]]; then	# exist but not on required status, reset.
							# this lead to clearing accumulated number on plugin status changed
	num=1;
	mode="update"
	change_from="${heaped_upcount##*:}"
  elif [ "${heaped_upcount}" == "null" ]; then		# exist but null, reset
       	num=1;
       	mode="update"
  elif [ "${heaped_upcount}" == "invalid" ]; then	# exist but invalid, reset
       	num=1;
       	mode="update"
  else
       	num=$(( ${heaped_upcount} + 1 ))  		# exist and normal, update to +1
       	mode="update"
  fi

  # only collect stderr output
  if [ "${mode}" == "update" ]; then
        # update old, update the whole plugin's line, only one continuously status remaining 
        errinfo=$( sed -i '/^'"${plugin_name}"'\>/c'"${plugin_name}"' '"${plugin_rc}"' '"${num}"'' ${TMP_HEAPUPRC} 2>&1 1>/dev/null )
  elif [ "${mode}" == "add" ]; then
        # add new
        errinfo=$( sed -i '$s/$/\n'"${plugin_name}"' '"${plugin_rc}"' '"${num}"'/' ${TMP_HEAPUPRC} 2>&1 1>/dev/null )
  fi
  rc=$?
  if [ "${rc}" == "0" ]; then
	write_log -f "${MOLE_LOG}" "$jobid add_heapuprc_count (mode=${mode}) on"\
		"[${plugin_name}] [${plugin_rc}] for [ ${heaped_upcount} + 1 = ${num} ] success."
	if [ -n "${change_from}" ]; then
		write_log -f "${MOLE_LOG}" "$jobid add_heapuprc_count (mode=${mode}) on"\
			"[${plugin_name}] status switch from [${change_from}] to [${plugin_rc}] success."
	fi
  else
	write_log -f "${MOLE_LOG}" "E0000000 add_heapuprc_count (mode=${mode}) on"\
		"[${plugin_name}] [${plugin_rc}] for [ ${heaped_upcount} + 1 = ${num} ] error: [${errinfo}]"
	if [ -n "${change_from}" ]; then
		write_log -f "${MOLE_LOG}" "$jobid add_heapuprc_count (mode=${mode}) on"\
			"[${plugin_name}] status switch from [${change_from}] to [${plugin_rc}] failed."
	fi
  fi

  return "${rc}"
}

# Get plugin's heaped up notify number
# Usage:        get_heapupnotify_count plugin_name plugin_rc notify_type
# Example:      get_heapupnotify_count sysload succ mail|sms
# Note:		notify_type ~ mail|sms
# Note:		search index:  combination of [plugin_name]-[notify_type]
# Output:       nottoday, noindex, noheaprc:{nower_rc}, null, invalid, [0-9]+
#	nottoday:	not today data
#	noindex:	no such plugin-notify_type index
#	noheaprc:	no such rc and nower rc
#	null:		result empty
#	invalid:	result not numberic
#	[0-9]+		result normal (numberic)
#
get_heapupnotify_count() {
  local plugin_name=$1  plugin_rc=$2  notify_type=$3  result=  today_date=  heapup_date=

  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_heapupnotify_count error: missing plugin name"
        return 1
  }

  [ -z "${plugin_rc}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 get_heapupnotify_count error: missing plugin rc"
        return 1
  }

  if ! is_sub "${notify_type}" "${ARRAY_NOTIFY_TYPE[*]}"; then 
        write_log -f "${MOLE_LOG}" "E0000000 get_heapupnotify_count error: notify type [${notify_type}] not supported"
        return 1
  fi

  local nower_array=()
  local index="${plugin_name}-${notify_type}"
  nower_array=( $(awk '($1~/\<'${index}'\>/) {print $2,$3,$4;exit}' ${TMP_HEAPUPNOTIFY} 2>&-) )
  if [ ${#nower_array[*]} -eq 0 ]; then
	result="noindex"
  else
	local nower_rc=${nower_array[0]}  nower_count=${nower_array[1]}  nower_date=${nower_array[2]}
	if [ "${nower_rc}" != "${plugin_rc}" ]; then
		result="noheaprc:${nower_rc}"
	else
  		result=${nower_count}	# set new result
  		if [ -z "${result}" ]; then
			result="null"
  		elif [ ! -z "${result//[0-9]}" ]; then
			result="invalid"
		else
			today_date="$(/bin/date +%F 2>&-)"
			if [ "${today_date}" != "${nower_date}" ]; then
				result="nottoday"
			fi
  		fi
	fi
  fi

  echo -e "${result}"
}

# Plugin's heaped up notify number +1 
# Note:         called at any notify action finished
# Usage:        add_heapupnotify_count plugin_name plugin_rc [notify_type] [jobid]
# Example:      add_heapupnotify_count sysload succ [mail|sms] [jobid]
# Note:	  notify_type ~ mail|sms
# Note:   noindex	=>   add new item as 1
# 	  null          =>   update to 1
#         invalid       =>   update to 1
#	  noheaprc	=>   update to 1, this lead to clearing accumulated number on notify level changed
#	  nottoday	=>   update to 1, this lead to clearing accumulated number on a new day
#         numberic      =>   update to +1
#
add_heapupnotify_count() {
  local plugin_name=$1  plugin_rc=$2  notify_type=$3   jobid=$4        # get jobid only for log record
  local rc=  errinfo=
  local headline="NOTICE  --*--< DO NOT EDIT THIS FILE >--*-- \n\n"
  local today_date="$(/bin/date +%F 2>&-)"

  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 add_heapupnotify_count error: missing plugin name"
        return 1
  }

  [ -z "${plugin_rc}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 add_heapupnotify_count error: missing plugin rc"
        return 1
  }

  if ! is_sub "${notify_type}" "${ARRAY_NOTIFY_TYPE[*]}"; then
	write_log -f "${MOLE_LOG}" "E0000000 add_heapupnotify_count error: notify type [${notify_type}] not supported"
	return 1
  fi

  /bin/touch ${TMP_HEAPUPNOTIFY}
  [ ! -s ${TMP_HEAPUPNOTIFY} ] && echo -e "${headline}" > ${TMP_HEAPUPNOTIFY}

  local heaped_upcount=  num=  mode=
  heaped_upcount=$(get_heapupnotify_count "${plugin_name}" "${plugin_rc}" "${notify_type}")
  if [ "${heaped_upcount}" == "noindex" ]; then		# index: [plugin_name]-[notify_type] item not exist, add a new one
	num=1;
	mode="add"
  elif [[ "${heaped_upcount}" =~ "noheaprc" ]]; then	# exist but not on required notify level, reset.
							# this lead to clearing accumulated number on notify level changed
	num=1;
	mode="update"
  elif [ "${heaped_upcount}" == "nottoday" ]; then	# not today's data, reset.
							# this lead to clearing accumulated number on a new day
	num=1;
	mode="update"
  elif [ "${heaped_upcount}" == "null" ]; then		# exist but null, reset
       	num=1;
       	mode="update"
  elif [ "${heaped_upcount}" == "invalid" ]; then	# exist but invalid, reset
       	num=1;
       	mode="update"
  else
       	num=$(( ${heaped_upcount} + 1 ))  		# exist and normal, update to +1
       	mode="update"
  fi

  local index="${plugin_name}-${notify_type}"
  # only collect stderr output
  if [ "${mode}" == "update" ]; then
        # update old, update the whole plugin's line, only one continuously status remaining 
        errinfo=$( sed -i '/^'"${index}"'\>/c'"${plugin_name}"'-'"${notify_type}"' '"${plugin_rc}"' '"${num}"' '"${today_date}"'' ${TMP_HEAPUPNOTIFY} 2>&1 1>/dev/null )
  elif [ "${mode}" == "add" ]; then
        # add new
        errinfo=$( sed -i '$s/$/\n'"${plugin_name}"'-'"${notify_type}"' '"${plugin_rc}"' '"${num}"' '"${today_date}"'/' ${TMP_HEAPUPNOTIFY} 2>&1 1>/dev/null )
  fi
  rc=$?
  if [ "${rc}" == "0" ]; then
	write_log -f "${MOLE_LOG}" "$jobid add_heapupnotify_count (mode=${mode}) on"\
		"[${index}] [${plugin_rc}] for [ ${heaped_upcount} + 1 = ${num} ] success."
  else
	write_log -f "${MOLE_LOG}" "E0000000 add_heapupnotify_count (mode=${mode}) on"\
		"[${index}] [${plugin_rc}] for [ ${heaped_upcount} + 1 = ${num} ] error: [${errinfo}]"
  fi

  return "${rc}"
}

# Check now hit plugin's notify policy range or not ?
# Usage:        hit_policy_range_ornot {notify_plicy_config}
# Example:      hit_policy_range_ornot "0-09,07-11,13-20,10-19  5"  
# Return:	0 | 1
# Output:	if return 0, output is the human-readable time range
#
hit_policy_range_ornot() {
  local notify_policy=$1
  [ -z "${notify_policy//[ ]}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 hit_policy_range_ornot error: missing notify policy to be analysized.";
	return 1
  }

  local nower_H=$(/bin/date +%H 2>&-)
  local range_H=$( get_policy_analysize "${notify_policy}" "range" )

  if is_sub "$((10#${nower_H}))" "${range_H}" ; then
	echo "$( get_policy_analysize "${notify_policy}" "range" "hrformat" )"
	return 0
  else
	return 1
  fi
}

# Check nower heaped up rc-number hit plugin's notify policy maxnum or not ?
# Usage:	hit_policy_rtime_ornot {plugin_name} "{plugin_rc}" "${notify_type}" "{notify_policy}"
# Example:	hit_policy_rtime_ornot {plugin_name} "{plugin_rc}" "${notify_type}" "{notify_policy}"
# Note:		notify_type ~ mail|sms
# Return:	0 | 1
# Output:	if return 0, there will be three kinds of output as following
#		unlimited	same level notify will be sent continuously without limitation
#		ming:N:M	same level notify has been sent for {N} times, max is {M} times.
#		last:M		same level notify has been sent for {M} times, also the last time.
#
hit_policy_rtime_ornot() {
  local plugin_name=$1	plugin_rc=$2  notify_type=$3  notify_policy=$4

  [ -z "${plugin_name}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 hit_policy_rtime_ornot error: missing plugin name";
        return 1
  }

  [ -z "${plugin_rc}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 hit_policy_rtime_ornot error: missing plugin rc";
        return 1
  }

  [ -z "${notify_policy}" ] && {
        write_log -f "${MOLE_LOG}" "E0000000 hit_policy_rtime_ornot error: missing notify policy";
        return 1
  }

  if ! is_sub "${notify_type}" "${ARRAY_NOTIFY_TYPE[*]}"; then 
        write_log -f "${MOLE_LOG}" "E0000000 hit_policy_rtime_ornot error: notify type [${notify_type}] not supported"
        return 1
  fi

  local nower_heapupnum=$(get_heapupnotify_count "${plugin_name}" "${plugin_rc}" "${notify_type}")
  local policy_rtimenum=$(get_policy_analysize "${notify_policy}" "rtime")
  
  if [ "${policy_rtimenum}" == "-1" ]; then
	return 1	# disabled, never notify on -1
  elif [ "${policy_rtimenum}" == "0" ]; then
	echo "unlimited"
	return 0	# unlimited, always notify on 0
  elif [ -z "${nower_heapupnum}" -o ! -z "${nower_heapupnum//[0-9]}" ]; then
	return 0	# enabled on nower heapupnum not numberic
  elif [ -z "${policy_rtimenum}" -o ! -z "${policy_rtimenum//[0-9]}" ]; then
	return 0	# enabled on policy rtimenum not numberic
  else
	if [ ${nower_heapupnum} -lt ${policy_rtimenum} ]; then  # enabled on nower heapupnum lower than policy rtimenum
		echo "ming:${nower_heapupnum}:${policy_rtimenum}"
		return 0	
	elif [ ${nower_heapupnum} -eq ${policy_rtimenum} ]; then # enabled on nower heapupnum equal policy rtimenum
		echo "last:${nower_heapupnum}"
		return 0
	else  							# disabled on nower heapupnum larger than policy rtimenum
		return 1	
	fi
  fi
}


# List enabled plugins include inners
#
list_enabled_plugin_section() {
  # list_plugin_section | while read plugin_name
  for plugin_name in `list_plugin_section`
  do
	[ "$(get_enable ${plugin_name})" == "yes" ] && echo "${plugin_name}"
  done

  for plugin_name in `list_inner_plugin_section`
  do
	echo "${plugin_name}"
  done
}

# List running plugins include inners
# 
list_running_plugin_section() {
  for plugin_name in `list_plugin_section` `list_inner_plugin_section`
  do
	lock_result=$(check_lock ${plugin_name})
	is_int "${lock_result}" && echo "${plugin_name}"
  done
}

# Generate an empty temporary file for plugin if needed.
# Output:	path of temporary file
# Usage:	gen_tmpfile  plugin_name	[{jobid}]
# Example:	gen_tmpfile  sysload		[{jobid}]
#
gen_tmpfile() {
  local plugin_name=$1  jobid=$2  rc=  errinfo=
  [ -z "${plugin_name}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 gen_tmpfile error: missing plugin name";
	return 1
  }

  [ ! -d "${TMP_DIR}/${plugin_name}" ] && /bin/mkdir -p ${TMP_DIR}/${plugin_name} 2>&-
  local filepath="${TMP_DIR}/${plugin_name}/${plugin_name}"
  if [ -z "${jobid}" ]; then
  	filepath="${filepath}_$( ${PLUTIL} unique_digest )"
  else
	filepath="${filepath}_${jobid}"
  fi
  # only collect stderr output.
  errinfo=$( /bin/touch "${filepath}" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" == "0" ]; then
  	echo "${filepath}"
	write_log -f "${MOLE_LOG}" "00000000 gen_tmpfile success:"\
		"[${filepath}]";
  else
	write_log -f "${MOLE_LOG}" "E0000000 gen_tmpfile error:"\
		"touch tmpfile [${filepath}]"\
		"return error: [${errinfo}]";
  fi

  return "${rc}"
}

# Time to run plugin or not ( nower timestamp > next-run timestamp or not)
# Usage:	time2run_ornot  plugin_name
# Output:	yes | no
#
time2run_ornot() {
  local plugin_name=$1 result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 time2run_ornot error: missing plugin name";
	return 1
  }
  local nextrun=$(get_nextrun ${plugin_name})
  local now=$(date +%s)
  [ "$(echo "${nextrun} <= ${now}"|bc)" == "1"  ] && result="yes" || result="no"
  echo "${result}"
}

# Generate run-lock on plugin  (atomic operation)
# Usage:        gen_lock  plugin_name
#
gen_lock() {
  local plugin_name=$1  rc=  errinfo=  logfile=  p_path=
  if [ -z "${plugin_name}" ]; then
	write_log -f "${MOLE_LOG}" "E0000000 gen_lock error: missing plugin name";
  	return 1
  fi
  if [[ "${plugin_name}" =~ ${INNER_BEGIN} ]]; then
   	p_path="${INNER_DIR}/${plugin_name}"
	logfile="${INNER_LOG}"
  else
	p_path="${PLUGIN_DIR}/${plugin_name}"
	logfile="${MOLE_LOG}"
  fi
  # only collect stderr output.
  errinfo=$( ln -s "${p_path}" "${RUN_DIR}/${plugin_name}.lock" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" != "0" ]; then
	write_log -f "${logfile}" "E0000000 gen_lock on plugin:"\
		"[${plugin_name}] error: [${errinfo}]";
  else
	write_log -f "${logfile}" "00000000 gen_lock on plugin:"\
		"[${plugin_name}] success.";
  fi

  return "${rc}"
}

# Unlock plugin
# Usage:        un_lock  plugin_name  [jobid]
#
un_lock() {
  local plugin_name=$1  jobid=$2	# get jobid only for log record when called in process_xxxx
  local rc=  errinfo=  logfile=
  [ -z "${jobid}" ] && jobid="00000000"	# if not specified jobid, means not called in process_xxxx
  if [ -z "${plugin_name}" ]; then
        write_log -f "${MOLE_LOG}" "E0000000 un_lock error: missing plugin name";
        return 1
  fi
  if [[ "${plugin_name}" =~ ${INNER_BEGIN} ]]; then
        logfile="${INNER_LOG}"
  else
        logfile="${MOLE_LOG}"
  fi
  # only collect stderr output.
  errinfo=$( unlink "${RUN_DIR}/${plugin_name}.lock" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" != "0" ]; then
	write_log -f "${logfile}" "E0000000 un_lock on:"\
		"[${plugin_name}] error: [${errinfo}]";
  else
	write_log -f "${logfile}" "$jobid un_lock on:"\
		"[${plugin_name}] success";
  fi
  return "${rc}"
}

# Remove pidfile for plugin
# Usage:	del_fpid  plugin_name  [jobid]
#
del_fpid() {
  local plugin_name=$1  jobid=$2	# get jobid only for log record when called in process_xxxx
  local rc=  errinfo=  logfile=
  [ -z "${jobid}" ] && jobid="00000000" # if not specified jobid, means not called in process_xxxx
  if [ -z "${plugin_name}" ]; then
        write_log -f "${MOLE_LOG}" "E0000000 del_fpid error: missing plugin name";
        return 1
  fi
  if [[ "${plugin_name}" =~ ${INNER_BEGIN} ]]; then
        logfile="${INNER_LOG}"
  else
        logfile="${MOLE_LOG}"
  fi
  # only collect stderr output.
  errinfo=$( /bin/rm -f "${RUN_DIR}/${plugin_name}.pid" 2>&1 1>/dev/null )
  rc=$?
  if [ "${rc}" != "0" ]; then
	write_log -f "${logfile}" "E0000000 del_fpid on:"\
		"[${plugin_name}] error: [${errinfo}]";
  else
	write_log -f "${logfile}" "$jobid del_fpid on:"\
		"[${plugin_name}] success.";
  fi
  return "${rc}"
}

# Check run-lock status for plugin
# Output:	nolock | linkerror | start timestamp (plugin is running)
# Usage:        check_lock  plugin_name
# Example:	check_lock  check_sysload
#
check_lock() {
  local plugin_name=$1 result=
  if [ -z "${plugin_name}" ]; then
	write_log -f "${MOLE_LOG}" "E0000000 check_lock error: missing plugin name";
	return 1
  fi
  # [ -e ${RUN_DIR}/${plugin_name}.lock ] && {   ###  never check broken link: never return linkerror
  if [ -L "${RUN_DIR}/${plugin_name}.lock" ]; then
	local f=$(readlink "${RUN_DIR}/${plugin_name}.lock" 2>&-)
	if [[ "${plugin_name}" =~ ${INNER_BEGIN} ]]; then
		local p_path="${INNER_DIR}/${plugin_name}"
		local logfile="${INNER_LOG}"
	else
        	local p_path="${PLUGIN_DIR}/${plugin_name}"
		local logfile="${MOLE_LOG}"
	fi
	if [ "${f}" == "${p_path}" -a -f "${p_path}" ]; then
		result=$(stat -c %Y ${RUN_DIR}/${plugin_name}.lock 2>&-) 
		if ! is_int "${result}"; then
			write_log -f "${logfile}" "E0000000 check_lock on [${plugin_name}] error: "\
				"runlock timestamp is not numberic: [${result}], "\
				"return linkerror";
			result="linkerror"
		fi
	else
		write_log -f "${logfile}" "E0000000 check_lock on [${plugin_name}] error: "\
				"runlock link->target is mistake or target not exist: "\
				"[${f}] ==> [${p_path}], "\
				"return linkerror";
		result="linkerror"
	fi
  else
	result="nolock"
  fi

  echo "${result}"
}

# Remove error lock and dead pid for plugin
# Clear conditions:
# 1. lock exists, but run-lock link error   ==>  remove lock
# 2. lock exists, but pid file not exists   ==>  remove lock
# 3. lock exists, pid file exist, but according to the pid file, no process running ==> remove lock,remove pidfile
# 4. pid file exists, but according to the pid file, no process running ==> remove pidfile
# Note:		No arguments will clear all plugins.
# Usage:	clear_dead_lock_pid  [ plugin_name ]
# Example1:	clear_dead_lock_pid  check_sysload
# Example2:	clear_dead_lock_pid
# LogFlag:	D0000000
#
clear_dead_lock_pid() {
  local plugin_name=$1

  clear_single_dead_lock_pid() {
	local _p=$1  _rc=
	if [ -z "${_p}" ]; then
		write_log -f "${MOLE_LOG}" "E0000000 clear_single_dead_lock_pid error: missing plugin name";
		return 1
	fi
  	if [[ "${_p}" =~ ${INNER_BEGIN} ]]; then
        	local logfile="${INNER_LOG}"
	else
        	local logfile="${MOLE_LOG}"
  	fi

	[ -L "${RUN_DIR}/${_p}.lock" ] && {
		if [ "$(check_lock  "${_p}")" == "linkerror" ]; then   ### condition: 1
			write_log -f ${logfile} "D0000000 MOLE remove linkerror lock for"\
				"[${_p}]: link error";
			un_lock "${_p}"
		fi
		if [ ! -f "${RUN_DIR}/${_p}.pid" ]; then  ### condition: 2
			write_log -f ${logfile} "D0000000 MOLE remove dead lock for"\
				"[${_p}]: pid not exists";
			un_lock "${_p}"        
		else
			check_ps_by_pid_file "${RUN_DIR}/${_p}.pid" 1>/dev/null 2>&1
			_rc=$?
			if [ "$_rc" != "0" ]; then  ### condition: 3
				write_log -f ${logfile} "D0000000 MOLE remove dead lock and pid for"\
					"[${_p}]: pid exists but process not running";
				un_lock "${_p}"  	# unlock first
				del_fpid "${_p}"	# then del pid file
			fi
		fi
	}
	if [ -s "${RUN_DIR}/${_p}.pid" ]; then
		check_ps_by_pid_file "${RUN_DIR}/${_p}.pid" 1>/dev/null 2>&1
		_rc=$?
		if [ "$_rc" != "0" ]; then  ### condition: 4
			write_log -f ${logfile} "D0000000 MOLE remove dead pid for [${_p}]";
			del_fpid "${_p}"
		fi
	fi
  }

  if [ -z "${plugin_name}" ]; then
	for p in `list_plugin_section`
	do
		clear_single_dead_lock_pid "${p}"
	done 
	for q in `list_inner_plugin_section`
	do
		clear_single_dead_lock_pid "${q}"
	done
  else
	clear_single_dead_lock_pid "${plugin_name}"
  fi
}

# According to input pid to stop process.
# Note: 	called by  stopps_by_pidfile()
# Usage:	stopps_by_pid  {pid}  {signal}
# Note:		{signal} only allowed: 15, 9 
# Example:	stopps_by_pid  1992  15
# LogFlag:      STP00000
#
stopps_by_pid() {
  local pid=$1 sig=$2 cmdline=
  
  if ! is_int "${pid}"; then
        write_log -f "${MOLE_LOG}" "E0000000 stopps_by_pid error:"\
                "argument invalid, pid=[${pid}] must be interger";
        return 1
  fi

  if [ "${sig}" != "15" -a "${sig}" != "9" ]; then
	write_log -f "${MOLE_LOG}" "E0000000 stopps_by_pid error:"\
		"argument invalid, sig=[${sig}] must be 15 or 9";
	return 1
  else
	write_log -f "${MOLE_LOG}" "STP00000 MOLE terminating pid:"\
		"set pid=[${pid}], singal=[${sig}]";
  fi

  if [ -d "/proc/${pid}" ]; then	# try to stop pid
  	cmdline=$(ps -p "${pid}" -o cmd= 2>&-)
	if [ -z "${cmdline}" ]; then	# skip stop pid
		write_log -f "${MOLE_LOG}" "STP00000 MOLE terminating pid:"\
			"cmdline empty, maybe [${pid}] already exit, nothing to do";
		return 1
	else				# send siginal to pid
		write_log -f "${MOLE_LOG}" "STP00000 MOLE terminating pid:"\
			"sending SIG:[${sig}] to pid:[${pid}] (${cmdline})";
		kill -${sig}  "${pid}" 1>&- 2>&- 
	fi
  else					# skip stop pid
	write_log -f "${MOLE_LOG}" "STP00000 MOLE terminating pid:"\
		"/proc/${pid} not exist, maybe [${pid}] already exit, nothing to do";
	return 1
  fi
}

# According to input pid file to stop process.
# Steps:
# 1. read first line from pid file as pids.
#  1.1. for each pid, if directory /proc/${pid}/ exists, search all of its son-pids
#  1.2. send signal TERM to all son pids
#  1.3. read /proc/${pid}/cmdline as variable cmdline1
#  1.4. send signal TERM to ${pid}, sleep {confirm_wait} seconds in case the process trap signal TERM
#  1.5. if directory /proc/${pid}/ still exists, read /proc/${pid}/cmdline as variable cmdline2
#  1.6. if cmdline1=cmdline2, send signal KILL to ${pid}, no more than 3 times.
# 2. remove pid file
#  2.1 skip   if process running
#  2.2 remove if process dead
# Usage:	stopps_by_pidfile   /path/to/pid/file		10
# Example:	stopps_by_pidfile   /var/run/crond.pid		5
# Return:	0	stop success, remove pid file success
#		1	missing argument fpid
#		2	stop success, but remove pid file failed
#		3	specified pid file not exists
#		4	stop failed, process still running
# LogFlag: 	STP00000
#
stopps_by_pidfile() {
  local fpid=$1  confirm_wait=$2
  [ -z "${fpid}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 stopps_by_pidfile error:"\
		"missing arguments, fpid=[${fpid}]";
  	return 1
  }
  
  if [ -z "${confirm_wait}" -o ! -z "${confirm_wait//[0-9]}" ]; then
	write_log -f "${MOLE_LOG}" "STP00000 MOLE confirm wait seconds"\
		"missing, set as default 3 seconds";
	confirm_wait=3
  else
	write_log -f "${MOLE_LOG}" "STP00000 MOLE confirm wait seconds"\
		"was set as ${confirm_wait} seconds";
  fi

  if [ -f "${fpid}" ]; then
	read line < ${fpid}    ### step: 1
	write_log -f "${MOLE_LOG}" "STP00000 MOLE read pids from pidfile:"\
		"[${fpid}] result: [${line}]";

	for x in `echo ${line}`;do
		[ -z "${x//[0-9]/}" -a -d "/proc/${x}" ] && {
			local kidpids=$(get_pidkids_bypid ${x})    ### step: 1.1
			write_log -f "${MOLE_LOG}" "STP00000 MOLE get_kidpids for pid:[${x}] result:[${kidpids}]";

			for cpid in `echo ${kidpids}`    ### step: 1.2
			do
				stopps_by_pid  ${cpid} 15
			done

			local cmdline1=$(cat /proc/${x}/cmdline 2>&-)    ### step: 1.3
			stopps_by_pid  ${x} 15		 ### step: 1.4
			sleep ${confirm_wait}		 ### in case the process trap signal TERM

			if [ -d "/proc/${x}" ]; then
				local cmdline2=$(cat /proc/${x}/cmdline 2>&-)    ### step: 1.5
				local kn=1  kmax=3
				until [ "${cmdline1}" != "${cmdline2}" ]     ### step: 1.6
				do
					write_log -f "${MOLE_LOG}" "STP00000 MOLE father pid:"\
						"[${x}] still running, try to stop it by SIG:KILL, times:[${kn}]";
					stopps_by_pid ${x} 9
					sleep 0.1
					local cmdline2=$(cat /proc/${x}/cmdline 2>&-)
					((kn++))
					### stop the process no more than ${kmax} times.
					[ "$( echo "${kn}>${kmax}" | bc 2>&- )" == "1" ] && break
				done
			else
				write_log -f "${MOLE_LOG}" "STP00000 MOLE terminate father pid:"\
					"[${x}] => [${cmdline1}] SIG:TERM success";
			fi
		}
	done

	if ! check_ps_by_pid_file "${fpid}" >/dev/null 2>&1; then
		write_log -f "${MOLE_LOG}" "STP00000 MOLE terminate"\
			"process according by [${fpid}] success"
		local errinfo=  rc=
  		errinfo=$( /bin/rm -f "${fpid}" 2>&1 1>/dev/null )    ### step: 2
		rc=$?
		if [ "${rc}" != "0" ]; then
			write_log -f "${MOLE_LOG}" "STP00000 MOLE remove pidfile:"\
				"[${fpid}] error: [${errinfo}]";
			return 2
		else
			write_log -f "${MOLE_LOG}" "STP00000 MOLE remove pidfile:"\
				"[${fpid}] success";
			return 0
		fi
	else					# process is still running here !!!
		write_log -f "${MOLE_LOG}" "STP00000 MOLE CRIT ALERT!"\
			"REMOVE PIDFILE: [${fpid}] SKIP, as PROCESS STILL RUNNING!"
		return 4
	fi
  else
	write_log -f "${MOLE_LOG}" "E0000000 stopps_by_pidfile error:"\
		"specified pidfile not exists: [${fpid}]";
	return 3
  fi
}

# Stop plugin	( stop process / remove pid / unlock )
# Usage:	stop_single_plugin   plugin_name
# LogFlag: 	STP00000 
#
stop_single_plugin() {
  local plugin_name=$1  
  local pidfile="${RUN_DIR}/${plugin_name}.pid"
  if [ -z "${plugin_name}" ]; then
	write_log -f "${MOLE_LOG}" "E0000000 stop_single_plugin error: missing plugin name";
	return 1
  else
	write_log -f "${MOLE_LOG}" "STP00000 MOLE stop plugin"\
		"[${plugin_name}]: 1 => stop process on pidfile: [${pidfile}]";
  	stopps_by_pidfile "${pidfile}" 1
	write_log -f "${MOLE_LOG}" "STP00000 MOLE stop plugin"\
		"[${plugin_name}]: 2 => remove lockfile";
  	un_lock "${plugin_name}"
  fi
}

# Check plugin has been running timeout or not  (must be running,otherwise return error directly)
# Output:	yes duration(s) | no duration(s) | error 0 (maybe not ruuning)
# Usage:	timeout_ornot  plugin_name
# Example:	timeout_ornot  check_sysload
#
timeout_ornot() {
  local plugin_name=$1 result=
  [ -z "${plugin_name}" ] && {
	write_log -f "${MOLE_LOG}" "E0000000 timeout_ornot error: missing plugin name";
	return 1
  }
  local exec_tmout=$(conv_time2sec "$(get_exec_tmout ${plugin_name})")
  local starttime=$(check_lock ${plugin_name})
  if [ -z "${starttime}" -o ! -z "${starttime//[0-9]/}" ]; then		### maybe not running
	write_log -f "${MOLE_LOG}" "E0000000 timeout_ornot error:"\
		"starttime [${starttime}] not numberic on plugin "\
		"[${plugin_name}]: maybe not running.";
	result="error 0"
  else				### is running
	local durationtime=$(echo " "$(date +%s)" - "${starttime}" " | bc 2>&-) 
  	[ "$(echo "${durationtime} >= ${exec_tmout}"|bc 2>&-)" == "1" ] && {
		result="yes ${durationtime}"
	} || {
		result="no  ${durationtime}"
	}
  fi
  echo -en "${result}"
}

# Add run-lock on plugin while pid file not exist
# Note:		called to add run-lock at next scan period begins, previous plugin has already finished. 
# 		No need to check previous plugin running timeout or not
# Output:	0 1   ==>  Succ | Fail
# Usage:        add_runlock_on_pid_notexist      plugin_name
# LogFlag: 	P0000000
#
add_runlock_on_pid_notexist(){
  local plugin_name=$1 _rc=
  if [ -z "${plugin_name}" ]; then
        write_log -f "${MOLE_LOG}" "E0000000 add_runlock_on_pid_notexist error: missing plugin name";
        return 1
  fi
  if [[ "${plugin_name}" =~ ${INNER_BEGIN} ]]; then
        local logfile="${INNER_LOG}"
  else
        local logfile="${MOLE_LOG}"
  fi

  gen_lock "${plugin_name}"
  _rc=$?
  if [ "${_rc}" != "0" ]; then
	write_log -f ${logfile} "P0000000 MOLE add runlock on"\
		"[${plugin_name}]: without pidfile but add runlock: failed. EXIT";
	return 1
  else
	write_log -f ${logfile} "P0000000 MOLE add runlock on"\
		"[${plugin_name}]: without pidfile and add runlock: succeed. OK";
	return 0
  fi
}

# Check run-lock on plugin while pid file exists
# Note:		called to check run-lock at next scan period begins, previous plugin is still running.
# Output: 	0 1 2 3 4 5
# Steps:
#   0: running, but timeout  ==>  stop plugin  ==>  process_plugin_timeout  ==>  skip 
#   1: running, and NOT timeout  ==>  skip
#   2: linkerror  ==>  remove dead run-lock  ==>  skip
#   3: nolock  ==>  add run-lock  ==>  failed  ==>  skip
#   4: nolock  ==>  add run-lock  ==>  succ    ==>  process_plugin
#   5: unknown  ==>  skip
# Usage:	check_runlock_on_pid_exist  plugin_name
# Example:	check_runlock_on_pid_exist  check_sysload   
# LogFlag: 	L0000000
#
check_runlock_on_pid_exist() {
  local plugin_name=$1  r_c=
  if [ -z "${plugin_name}" ]; then
        write_log -f "${MOLE_LOG}" "E0000000 check_runlock_on_pid_exist error: missing plugin name";
        return 1
  fi

  if [[ "${plugin_name}" =~ ${INNER_BEGIN} ]]; then
	local logfile="${INNER_LOG}"
  else
	local logfile="${MOLE_LOG}"
  fi

  local lockinfo=$(check_lock "${plugin_name}")
  [ -z "${lockinfo//[0-9]/}" ] && {	    ###   is running
	local timeout_result=( $(timeout_ornot "${plugin_name}") )
	if [ "${timeout_result[0]}" == "yes" ]; then   ### condition: 0
		write_log -f ${logfile} "L0000000 MOLE plugin"\
			"[${plugin_name}] has been running for ${timeout_result[1]} seconds, timeout. STOP IT"
		process_plugin_timeout "${plugin_name}" "${timeout_result[1]}"
		return 0
	else    
		# write_log -f ${logfile} "L0000000 MOLE plugin"\
			# "[${plugin_name}] has been running for ${timeout_result[1]} seconds"
		return 1	### condition: 1
	fi
  }

  [ "${lockinfo}" == "linkerror" ] && {
	un_lock "${plugin_name}"
	write_log -f ${logfile} "L0000000 MOLE plugin"\
		"[${plugin_name}] running but linkerror. UNLOCK IT";
	return 2      ### condition: 2
  }

  [ "${lockinfo}" == "nolock" ] && {    ### not running
	gen_lock "${plugin_name}"
        r_c=$?
	if [ "${r_c}" != "0" ]; then
		write_log -f ${logfile} "L0000000 MOLE add runlock on"\
			"[${plugin_name}]: without runlock but add runlock failed. EXIT";
		return 3      ### condition: 3
	else		
		write_log -f ${logfile} "L0000000 MOLE add runlock on"\
			"[${plugin_name}]: without runlock and add runlock succeed. OK";
		return 4      ### condition: 4
	fi
  }

  write_log -f ${logfile} "L0000000 MOLE plugin"\
	"[${plugin_name}] something unknown occure. EXIT";
  return 5 	### condition: 5
}


# List single plugin status and scheduling information
# Usage:	list_single_plugin_status  {plugin_name1}
# Example:	list_single_plugin_status  sysload 
#
list_single_plugin_status() {
  local _p=$1 enable= running= starttime= durationtime= lastruntime= frequency= nextruntime= repeaterrnum=
  local lastruntime=$(get_lastrun "${_p}")
  local frequency=$(get_frequency "${_p}")
  local nextruntime=$(get_nextrun "${_p}")
  local repeaterrnum=$(get_repeat_errcount "${_p}")

  if [[ "${_p}" =~ ${INNER_BEGIN} ]]; then
	enable="yes"
  else
	enable=$(get_enable "${_p}")
  fi

  if is_int "${lastruntime}"; then
	lastruntime=$(date -d "1970-01-01 UTC ${lastruntime} seconds" +%F_%T)
  else
	[ "${lastruntime}" == "never_run" ] && {
		lastruntime="Never_Run"
	} || {
		[ "${lastruntime}" == "invalid_lastrun" ] && {
			lastruntime="Internal_Error"
		} || {
			lastruntime="Unknown"
		}
	}
  fi

  if is_int "${nextruntime}"; then
	nextruntime=$(date -d "1970-01-01 UTC ${nextruntime} seconds" +%F_%T)
  else
	[ "${nextruntime}" == "null" ] && {
		nextruntime="NULL"
	} || {
		[ "${nextruntime}" == "invalid_nextrun" ] && {
			nextruntime="Internal_Error"
		} || {
			nextruntime="Unknown"
		}
	}
  fi

  [ "${enable}" == "yes" ] && {
	enable="Yes"
  } || {
	enable="No" 
	nextruntime="-"
  }

  local lockinfo=$(check_lock $_p)
  if is_int "${lockinfo}"; then
	running="Yes"
	starttime=$(date -d "1970-01-01 UTC ${lockinfo} seconds" +%F_%T)
	durationtime="$( echo "$(date +%s) - ${lockinfo}" | bc 2>&- )s"
  else
	running="No"
	starttime="-"
	durationtime="-"
  fi

  echo "$_p ${enable} ${running} ${starttime} ${durationtime} ${lastruntime} ${frequency} ${nextruntime} ${repeaterrnum}"
}

# List plugin status and scheduling information
# Usage:	list_plugin_status  plugin_name1 plugin_name2 plugin_name3 ...
# Example1:	list_plugin_status  check_sysload  check_cpu_usage
# Example2:	list_plugin_status  all
#
list_plugin_status() {
  local plugin_name="$*"
  local headline="Plugin Enable Running StartOn Duration LastRun Frequency NextRun RepeatErr"
  if [ "${plugin_name}" == "all" ]; then
		{  echo "${headline}"
		for p in `list_plugin_section`
		do
			list_single_plugin_status "${p}"
		done 
		} | column -t 
  else
		{ echo "${headline}" 
		for o in `echo "${plugin_name}"`
		do
			list_single_plugin_status "${o}" 
		done
		} | column -t
  fi
}

# Enable Plugin (update config file to set enable = yes)
# LogFlag	ENAB0000
#
enable_plugin(){
  local plugin_name=$1  rc=
  write_log -f "${MOLE_LOG}" "ENAB0000 enable_plugin trying to enable plugin [${plugin_name}]";
  update_mole_config "${plugin_name}" "enable" "yes"
  rc=$?
  return "${rc}"
}

# Disable Plugin (update config file to set enable = no)
# LogFlag	DSAB0000
#
disable_plugin() {
  local plugin_name=$1  rc=
  write_log -f "${MOLE_LOG}" "DSAB0000 disable_plugin trying to disable plugin [${plugin_name}]";
  update_mole_config "${plugin_name}" "enable" "no"
  rc=$?
  return "${rc}"
}

# Reset scheduling information and repeat err-num of plugin
# Note:		No arguments will reset all plugins
# Usage:	init_plugin  [plugin_name]
# Example1:	init_plugin  check_sysload
# Example2:	init_plugin 
# LogFlag:	INIT0000
# 
init_plugin() {
  local plugin_name=$1  rc=0
  if [ -z "${plugin_name}" ]; then
	if [ -f "${TMP_LASTRUN}" -a -s "${TMP_LASTRUN}" ]; then
		: > "${TMP_LASTRUN}" >/dev/null 2>&1
		((rc+=$?))
	else
		((rc+=0))
	fi
	if [ -f "${TMP_NEXTRUN}" -a -s "${TMP_NEXTRUN}" ]; then
  		: > "${TMP_NEXTRUN}" >/dev/null 2>&1
		((rc+=$?))
	else
		((rc+=0))
	fi
	if [ -f "${TMP_REPEAT}" -a -s "${TMP_REPEAT}" ]; then
  		: > "${TMP_REPEAT}"  >/dev/null 2>&1
		((rc+=$?))
	else
		((rc+=0))
	fi
	plugin_name="all plugins"
  else
	if [ -f "${TMP_LASTRUN}" -a -s "${TMP_LASTRUN}" ]; then
 		sed -i '/^'"${plugin_name}"'\>/d' "${TMP_LASTRUN}" > /dev/null 2>&1
		((rc+=$?))
	else
		((rc+=0))
	fi
	if [ -f "${TMP_NEXTRUN}" -a -s "${TMP_NEXTRUN}" ]; then
 		sed -i '/^'"${plugin_name}"'\>/d' "${TMP_NEXTRUN}" > /dev/null 2>&1
		((rc+=$?))
	else
		((rc+=0))
	fi
	if [ -f "${TMP_REPEAT}" -a -s "${TMP_REPEAT}" ]; then
 		sed -i '/^'"${plugin_name}"'\>/d' "${TMP_REPEAT}"  > /dev/null 2>&1
		((rc+=$?))
	else
		((rc+=0))
	fi
	plugin_name="plugin: [${plugin_name}]"
  fi


  if [ "${rc}" == "0" ]; then
	write_log -f "${MOLE_LOG}" "INIT0000 resetting ${plugin_name} succeed, return rc=$rc"
  else
	write_log -f "${MOLE_LOG}" "INIT0000 resetting ${plugin_name} failed, return rc=$rc"
  fi

  return ${rc}
}

# List base-config-name ==> config-value of plugin
# Note:		No arguments will list all plugins
# Note:		Extra (user-defination) config-name will not be displayed.
# Usage:  view_base_config 	plugin_name
# 
view_base_config() {
  local plugin_name=$1
  [ -z "${plugin_name}" ] && {
	echo_red "$(gettext "view_base_config error: please specify plugin name.")"; echo
	return 1
  }
  echo_green "[${plugin_name}]: $(gettext "basic configuration")" ; echo
  { 
	echo -e "$(gettext "config_name") ^ $(gettext "value") ^ $(gettext "is_default")"
  	for cname in ${ARRAY_BASE_CONFIG[*]} 
  	do
        	cvalue=$(read_mole_config ${plugin_name} ${cname})
        	if [ -z "${cvalue}" ]; then
                	cvalue="$(read_mole_config default ${cname}) ^ Yes"
		else
			cvalue="${cvalue} ^ No"
        	fi
        	echo -e  "${cname} ^ ${cvalue} "
  	done
  } | column -t -s "^"
}

# List user-defined-config-name ==> config-value of plugin
# Note:         No arguments will list all plugins
# Note:         Basic config-name will not be displayed.
# Usage:  view_extra_config      plugin_name  0|1
# 
view_extra_config() {
  local plugin_name=$1  silient=$2
  [ -z "${silient}"  ] && silient=0 || silient=1
  [ "${silient}" == "0" -a -z "${plugin_name}" ] && {
	echo_red "$(gettext "view_extra_config error: please specify plugin_name.")"; echo
 	return 1
  }
  [ "${silient}" == "0" ] && { 
	echo_green "[${plugin_name}]: $(gettext "extra configuration")"
	echo
  }
  {
	local search_tag=0  headline="$(gettext "config_name(user-def)") ^ $(gettext "value")"
  	for cname in `list_section_keys "${plugin_name}"`
  	do
		if ! is_sub "${cname}" "${ARRAY_BASE_CONFIG[*]}"; then		### 2. user-def config
			cvalue=$(read_mole_config ${plugin_name} ${cname})
			[ "${silient}" == "0" -a "${search_tag}" == "0" ] && echo -e "${headline}"
			echo -e "${cname} ^ ${cvalue}"
			search_tag=1
		fi
  	done
  } | column -t -s "^"
}

# Process plugin 
# Note:		core function, each enabled plugin will be handed over to this function.
# Usage:        process_plugin   plugin_name
# LogFlag:	random 8 character
#
process_plugin() {

  local plugin_name=$1  jid=$2

  # Step 1: set debug flag / set logfile
  export _LOG="${MOLE_LOG}"          ### set logfile 
  local debug=$(get_debug "${plugin_name}")   ### set debug flag
  [ "${debug}" == "yes" ] && export _DEBUG="1" || export _DEBUG="0"

  # Step 2.1: check current overloaded or not,  yes ==> process_sysoverload ==> return
  local SYSLOAD_UPLIMIT=$(get_sysload_uplimit)
  local sysload=$( cut -d" " -f1 /proc/loadavg 2>&- )
  if [ "$(echo  "${sysload} > $SYSLOAD_UPLIMIT" | bc 2>&-)" == "1" ]; then	### plugin finished.
	write_log "${jid} ${plugin_name} system overloaded,"\
		"[${sysload}] > [${SYSLOAD_UPLIMIT}], EXIT";
	process_sysoverload "${plugin_name}" "${sysload}" "${SYSLOAD_UPLIMIT}" "${jid}"
	un_lock "${plugin_name}" "${jid}"	# unlock first
	del_fpid "${plugin_name}" "${jid}"	# then del pid file
	write_log ${jid} ${plugin_name} "FINISHED"
	unset _LOG
	return 1
  else
	write_log ${jid} ${plugin_name} "system load normal: [${sysload}] CONTINUE";
  fi

  # Step 2.2: check current mole kids exceed or not,  yes ==> process_kidsexceed ==> return
  local KIDSNUM_UPLIMIT=$(get_max_kidsnum)
  if [ -f "${PID_FILE}" -a -s "${PID_FILE}" ]; then
 	read empid < "${PID_FILE}"
  	local kidsnum=$( get_kidsnum "${empid}" )
  	if [ "$(echo  "${kidsnum} > $KIDSNUM_UPLIMIT" | bc 2>&-)" == "1" ]; then	### plugin finished.
		write_log "${jid} ${plugin_name} kids number exceed,"\
			"[${kidsnum}] > [${KIDSNUM_UPLIMIT}], EXIT";
		process_kidsexceed "${plugin_name}" "${kidsnum}" "${KIDSNUM_UPLIMIT}" "${jid}"
		un_lock "${plugin_name}" "${jid}"	# unlock first
		del_fpid "${plugin_name}" "${jid}"	# then del pid file
		write_log ${jid} ${plugin_name} "FINISHED"
		unset _LOG
		return 1
  	else
		write_log ${jid} ${plugin_name} "mole kids number normal: [${kidsnum}] CONTINUE";
  	fi
  else
	write_log ${jid} ${plugin_name}\
		"mole pid file not exist or empty, SKIP max_kids_num check, CONTINUE"
  fi


  # Step 3: check if input plugin-name registered in config file or not
  write_log ${jid} ${plugin_name} "START";
  if [ -z "${plugin_name}" ]; then   ### plugin finished, log record, no handler triggered
	write_log ${jid} "plugin_name empty, please specify plugin_name. EXIT";
	update_status "${plugin_name}" "${jid}" "EXIT on Empty Plugin Name"
	update_lastrun_and_nextrun "${plugin_name}" "${jid}"
	un_lock "${plugin_name}" "${jid}"	# unlock first
	del_fpid "${plugin_name}" "${jid}"	# then del pid file
	unset _LOG
	return 1
  else
  	if [ "$(read_plugin_section "${plugin_name}" )" != "${plugin_name}" ]; then   ### plugin finished, log record, no handler triggered 
		write_log ${jid} ${plugin_name} "not registered. EXIT";
		update_status "${plugin_name}" "${jid}" "EXIT on Plugin NOT Registered";
		update_lastrun_and_nextrun "${plugin_name}" "${jid}"
		un_lock "${plugin_name}" "${jid}"	# unlock first
		del_fpid "${plugin_name}" "${jid}"	# then del pid file
		unset _LOG
		return 2
	else
		write_log ${jid} ${plugin_name} "registered. CONTINUE";
	fi
  fi

  # Step 4: check if input plugin-name enabled in config file or not
  local status=$(get_enable "${plugin_name}")
  if [ "${status}" != "yes" ]; then	### plugin finished, log record, no handler triggered
	write_log ${jid} ${plugin_name} "disabled."\
		"status=[${status}] EXIT";
	update_status "${plugin_name}" "${jid}" "EXIT on Plugin Disabled"
	update_lastrun_and_nextrun "${plugin_name}" "${jid}"
	un_lock "${plugin_name}" "${jid}"	# unlock first
	del_fpid "${plugin_name}" "${jid}"	# then del pid file
	unset _LOG
	return 0
  else
	write_log ${jid} ${plugin_name} "enabled. CONTINUE";
  fi

  # Step 5: check if plugin file exists under PLUGIN_DIR or not
  if [ ! -f "${PLUGIN_DIR}/${plugin_name}" -o ! -s "${PLUGIN_DIR}/${plugin_name}" ]; then	### plugin finished, log record, no handler triggered 
	write_log ${jid} ${plugin_name} "plugin file not prepared. EXIT";
	update_status "${plugin_name}" "${jid}" "EXIT on Plugin File Not Found or Empty"
	update_lastrun_and_nextrun "${plugin_name}" "${jid}"
	un_lock "${plugin_name}" "${jid}"	# unlock first
	del_fpid "${plugin_name}" "${jid}"	# then del pid file
	unset _LOG
	return 3
  else
	write_log ${jid} ${plugin_name} "plugin file prepared. CONTINUE";
  fi

  # Step 6: exec plugin / obtain returned code / obtain returned stuff
  [ -x "${PLUGIN_DIR}/${plugin_name}" ] || {
	/bin/chmod a+x "${PLUGIN_DIR}/${plugin_name}" 2>&-
  }
  # local output=$( eval "..." 2>&1 )    # is wrong! can NOT get returned code, as be 0 always
  local output=  rc=
  output=$( eval "${PLUGIN_DIR}/${plugin_name}" 2>&1 )
  rc=$?
  write_log ${jid} ${plugin_name} "execution completed."\
	"return code: [${rc}]  return string: [${output}]. CONTINUE";


  write_log ${jid} ${plugin_name} "begin misform examinations on plugin result. CONTINUE"

  # Step 6.1: check plugin output max length
  local PLUGIN_MAXLEN=$(get_plugin_maxlen)
  local plugin_output_length="${#output}"
  if [ "$(echo  "${plugin_output_length} > $PLUGIN_MAXLEN" | bc 2>&-)" == "1" ]; then      ### truncate and plugin continue.
	write_log "${jid} ${plugin_name} plugin output length exceed,"\
		"[${plugin_output_length}] > [${PLUGIN_MAXLEN}], TRUNCATE";
	output="${output:0:${PLUGIN_MAXLEN}}"
	output="${output}}"		### completion '}' after truncated
	write_log "${jid} ${plugin_name} plugin output length exceed,"\
		"truncated result: [${output}], CONTINUE"
  else
	write_log ${jid} ${plugin_name} "plugin output length normal: [${plugin_output_length}] CONTINUE";
  fi

  # Step 6.2: check plugin return code
  case "${rc}" in
  "0"|"1"|"2"|"3"|"4"|"5")
	write_log ${jid} ${plugin_name} "plugin return code normal: [${rc}], CONTINUE";
	;;
  *)
	write_log ${jid} ${plugin_name} "plugin return code invalid: [${rc}], EXIT";  	  ### plugin finished
        process_plugin_misform "${plugin_name}"  "rc"  "${rc}"  "${jid}"
        un_lock "${plugin_name}" "${jid}"	# unlock first
        del_fpid "${plugin_name}" "${jid}"	# then del pid file
        write_log ${jid} ${plugin_name} "FINISHED"
        unset _LOG
        return 1
	;;
  esac 

  # Step 6.3: check plugin output format

  # Step 6.3.1: check output lines number
  local output_linenum=
  output_linenum=$(echo -en "${output}"|awk 'END{print NR}')
  if [ "${output_linenum}" != "1" ]; then
        write_log "${jid} ${plugin_name} plugin output lines number invalid:"\
                "[${output_linenum}], should be one-line-output, EXIT";
	process_plugin_misform "${plugin_name}"  "lines"  "${output_linenum}" "${jid}"
        un_lock "${plugin_name}"  "${jid}"       # unlock first
        del_fpid "${plugin_name}" "${jid}"       # then del pid file
        write_log ${jid} ${plugin_name} "FINISHED"
        unset _LOG
        return 1
  else
        write_log ${jid} ${plugin_name} "plugin output lines number normal: [${output_linenum}] CONTINUE";
  fi

  local part1= part2= part3=
  # Step 6.3.2: check output parts format: {a}:{b}:{c}
  part3=$( ${PLUTIL} "parted_output" "3" "${output}" )
  if [ -z "${part3}" ]; then
        write_log "${jid} ${plugin_name} plugin output format unrecognized, EXIT";
	process_plugin_misform "${plugin_name}"  "format" "third part empty" "${jid}"
        un_lock "${plugin_name}" "${jid}"      # unlock first
        del_fpid "${plugin_name}" "${jid}"       # then del pid file
        write_log ${jid} ${plugin_name} "FINISHED"
        unset _LOG
        return 1
  else
	write_log ${jid} ${plugin_name} "plugin output format normal, CONTINUE";
  fi

  # Step 6.3.3: check output part1 -> {level}
  part1=$( ${PLUTIL} "parted_output" "1" "${output}" | tr '[A-Z]' '[a-z]' )
  case "${part1}" in
  "succ"|"warn"|"crit"|"unkn"|"noop"|"notify")
	write_log ${jid} ${plugin_name} "plugin output level normal: [${part1}], CONTINUE";
	;;
  *)
	write_log ${jid} ${plugin_name} "plugin output level invalid: [${part1}], EXIT";	### plugin finished
	process_plugin_misform "${plugin_name}"  "level"  "${part1}" "${jid}"
        un_lock "${plugin_name}" "${jid}"        # unlock first
        del_fpid "${plugin_name}" "${jid}"      # then del pid file
        write_log ${jid} ${plugin_name} "FINISHED"
        unset _LOG
        return 1
	;;
  esac

  # Step 6.3.4: check output part1 and return code match or not ?
  if [ "$(is_match "${part1}" "${rc}")" == "yes" ]; then
	write_log ${jid} ${plugin_name} "plugin output level [${part1}] match return code [${rc}], CONTINUE"
  else
	write_log ${jid} ${plugin_name} "plugin output level [${part1}] mismatch return code [${rc}], EXIT";  ### plugin finished
	process_plugin_misform "${plugin_name}" "mismatch" "${part1} <=> ${rc}" "${jid}"
	un_lock "${plugin_name}" "${jid}"	# unlock first
	del_fpid "${plugin_name}" "${jid}"		# then del pid file
	write_log ${jid} ${plugin_name} "FINISHED"
	unset _LOG
	return 1
  fi

  # Step 6.3.5: check output part2 -> {type}
  part2=$( ${PLUTIL} "parted_output" "2" "${output}" | tr '[A-Z]' '[a-z]' )
  case "${part2}" in
  "file"|"str")
	write_log ${jid} ${plugin_name} "plugin output type normal: [${part2}], CONTINUE";
	;;
  *)
	write_log ${jid} ${plugin_name} "plugin output type invalid: [${part2}], EXIT";		### plugin finished
	process_plugin_misform "${plugin_name}"  "type"  "${part2}"  "${jid}"
        un_lock "${plugin_name}" "${jid}"        # unlock first
        del_fpid "${plugin_name}" "${jid}"	   # then del pid file
        write_log ${jid} ${plugin_name} "FINISHED"
        unset _LOG
        return 1
	;;
  esac
  
  write_log ${jid} ${plugin_name} "plugin result passed all examinations. CONTINUE"


  # Step 7: special steps on each level
  # 		0-SUCC	:	reset plugin result if hit event [recovery], continue
  # 		4-NOOP	:	nothing to do, exit
  # 		5-NOTIFY:	nothing to do, continue
  # 		1-WARN	:	add repeat errcount +1 and checking, continue if reached, otherwise exit
  # 		2-CRIT	:	add repeat errcount +1 ...
  #		3-UNKN	:	add repeat errcount +1 ...

  # 0-SUCC
  if [ "${rc}" == "0" ]; then    
	write_log ${jid} ${plugin_name}\
		"return status: [SUCC], will check nower errcount to detect recovery event, CONTINUE";
	local maxerr_detail=
	if maxerr_detail=$(is_reached_maxerr "${plugin_name}"); then	# got event recovery 
		local _now_errcount=${maxerr_detail%%:*}    _errcount_uplimit=${maxerr_detail##*:}
		local new_level="recovery"
		write_log ${jid} ${plugin_name}\
			"got event recovery, nower errcount reached maximize errtimes,"\
			"[${_now_errcount} >= ${_errcount_uplimit}]. CONTINUE"
		write_log ${jid} ${plugin_name}\
			"got event recovery, reset output part1 from [${part1}] to [${new_level}]. CONTINUE"
		part1="${new_level}"
		if [ "${part2}" == "str" ]; then               # reset plugin {output}
			local add_title="$(gettext "RECOVERY")"
			write_log ${jid} ${plugin_name}\
				"got event recovery, and return is [str], reset output part3"\
				"to add title [${add_title}]. CONTINUE"
			output="{${part1}}:{${part2}}:{(${add_title}) ${part3}}"  
		else
			output="{${part1}}:{${part2}}:{${part3}}"
		fi
		write_log ${jid} ${plugin_name}\
			"got event recovery, reset plugin return code from [${rc}] to [${new_level}]. CONTINUE"
		rc="${new_level}"			       # reset plugin {rc}
	else
		local _now_errcount=${maxerr_detail%%:*}    _errcount_uplimit=${maxerr_detail##*:}
		write_log ${jid} ${plugin_name}\
			"not event recovery (${_now_errcount} < ${_errcount_uplimit}), return status: [SUCC]. CONTINUE"
	fi
	write_log ${jid} ${plugin_name}\
		"will reset repeat errcount. CONTINUE";
	reset_repeat_errcount "${plugin_name}" "${jid}"		# reset accumulated return-err number => 0
  # 4-NOOP
  elif [ "${rc}" == "4" ]; then  ### plugin finished. 
	write_log ${jid} ${plugin_name}\
		"return status: [NOOP], Noting to do. EXIT";
	update_lastrun_and_nextrun "${plugin_name}" "${jid}"
	un_lock "${plugin_name}" "${jid}"	# unlock first
	del_fpid "${plugin_name}" "${jid}"	# then del pid file
	write_log ${jid} ${plugin_name} "FINISHED"
	unset _LOG
	return 0
  # 5-NOTIFY
  elif [ "${rc}" == "5" ]; then
	write_log ${jid} ${plugin_name}\
		"return status: [NOTIFY], CONTINUE";
  # 1-WARN, 2-CRIT, 3-UNKN 
  else  
	write_log ${jid} ${plugin_name}\
		"return code: [${rc}]. try to +1 on repeat errcount. CONTINUE";
  	add_repeat_errcount "${plugin_name}" "${jid}"	# accumulated error number +1, on plugin return warn,crit,unkn
	local maxerr_detail=
  	if maxerr_detail=$(is_reached_maxerr "${plugin_name}"); then  # plugin continue
		local _now_errcount=${maxerr_detail%%:*}   _errcount_uplimit=${maxerr_detail##*:}
		write_log ${jid} ${plugin_name} "reached maximize errtimes:"\
			"[(${_now_errcount}) >= (${_errcount_uplimit})] CONTINUE";
  	else  # plugin finished
		local _now_errcount=${maxerr_detail%%:*}   _errcount_uplimit=${maxerr_detail##*:}
		write_log ${jid} ${plugin_name} "have-not-yet reached maximize errtimes:"\
			"[(${_now_errcount}) < (${_errcount_uplimit})] EXIT";
        	update_lastrun_and_nextrun "${plugin_name}" "${jid}"
        	un_lock "${plugin_name}" "${jid}"	# unlock first
        	del_fpid "${plugin_name}" "${jid}"	# then del pid file
        	write_log ${jid} ${plugin_name} "FINISHED"
        	unset _LOG
        	return 0
  	fi
  fi


  # update plugin execution result
  update_status "${plugin_name}" "${jid}" "${output}"

  # update plugin heaped up rc number
  # --*--< Important >--*--
  # this step must behind in max err check, otherwise leading to conflict with notify policy logic
  add_heapuprc_count "${plugin_name}" "${part1}" "${jid}"


  # Step 8: check action: take_snapshot
  local t_snap=$(take_action_ornot "${plugin_name}" take_snapshot ${rc})
  local snapfile=
  if [ "${t_snap}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "take snapshot disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "take snapshot enabled. CONTINUE";
	snapfile=$( ${TAKESNAP_SH} -f "${plugin_name}" -s "${jid}" 2>/dev/null )
 	snapfile=" ${t_snap} ### ${snapfile##*/} "
	write_log ${jid} ${plugin_name} "take snapshot finished."\
		"detailis in ${TAKESNAP_LOG##*/}. CONTINUE";
  fi
	
  # Step 9: check action: auto_handle
  local a_hand=$(take_action_ornot "${plugin_name}" auto_handle ${rc})
  local hd_output=  hd_rc=
  if [ "${a_hand}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "auto handle disabled. SKIP";
	hd_output="auto handle is disabled. Nothing to do"
  else
	write_log ${jid} ${plugin_name} "auto handle enabled. CONTINUE";
	local handler=$(get_auto_handler "${plugin_name}")
	if [ -f "${HANDLER_DIR}/${handler}" -a -s "${HANDLER_DIR}/${handler}" ]; then
		write_log ${jid} ${plugin_name} "auto handler:"\
			"[${HANDLER_DIR}/${handler}] exists. CONTINUE";
 		[ ! -x "${HANDLER_DIR}/${handler}" ] && /bin/chmod a+x "${HANDLER_DIR}/${handler}" 2>&-
		hd_output=$( eval "${HANDLER_DIR}/${handler}" 2>&1 )
		hd_rc=$?
		write_log ${jid} ${plugin_name} "auto handler execution completed."\
			"return code:[${hd_rc}] return string: [${hd_output}] CONTINUE";
		local HANDLER_MAXLEN=$(get_handler_maxlen)
		local handler_output_length="${#hd_output}"
  		if [ "$(echo  "${handler_output_length} > $HANDLER_MAXLEN" | bc 2>&-)" == "1" ]; then  ### truncate it
        		write_log "${jid} ${plugin_name} handler output length exceed,"\
                		"[${handler_output_length}] > [${HANDLER_MAXLEN}], TRUNCATE";
        		hd_output="${hd_output:0:${HANDLER_MAXLEN}}"
        		hd_output="${hd_output}}"             ### completion '}' after truncated
        		write_log "${jid} ${plugin_name} handler output length exceed,"\
                		"truncated result: [${hd_output}], CONTINUE"
  		else 
        		write_log "${jid} ${plugin_name} handler output length normal: [${handler_output_length}] CONTINUE";
  		fi
		hd_output="auto handler [${handler}] return ### ### ${hd_output}"
  	else
		write_log ${jid} ${plugin_name} "auto handler:"\
			"[${HANDLER_DIR}/${handler}] not exist or empty. SKIP";
		hd_output="auto handler [${handler}] not exist or empty. Nothing to do"
	fi
  fi

  # Step 10: check action: sms_notify
  local s_alert=$(take_action_ornot "${plugin_name}" sms_notify ${rc})
  local result_smslst=
  local sms_receviers=$(get_sms_receviers "${plugin_name}")
  if [ "${s_alert}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "sms notify disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "sms notify enabled. CONTINUE";
	result_smslst=" ${s_alert} ###  ###  ${sms_receviers} "
	write_log ${jid} ${plugin_name} "sms notify without local handler, set all receviers as failed. CONTINUE";
  fi

  # Step 11: check action: mail_notify
  local m_alert=$(take_action_ornot "${plugin_name}" mail_notify ${rc})
  local result_emllst=
  if [ "${m_alert}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "mail notify disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "mail notify enabled. CONTINUE";
	# read mail notify policy
	local mail_policy=$(get_mail_policy ${plugin_name})
	write_log ${jid} ${plugin_name} "mail notify policy is [${mail_policy}]. CONTINUE";
	# check mail notify policy
	local mail_policy_detail=$(gettext "according by plugin's policy settings,")
	local hit_range_detail=  hit_rtime_detail=
	# check time range of mail notify policy
	if hit_range_detail=$(hit_policy_range_ornot "${mail_policy}"); then
		write_log ${jid} ${plugin_name} "mail notify is allowed by nower"\
							"time range (${hit_range_detail}), CONTINUE";
		# check rtime of mail notify policy
		if hit_rtime_detail=$(hit_policy_rtime_ornot "${plugin_name}" "${part1}" "mail" "${mail_policy}"); then
			write_log ${jid} ${plugin_name} "mail notify is allowed by nower"\
					"heapuprc number (${hit_rtime_detail}), CONTINUE";

			local tmp_content=
			if [ "${hit_rtime_detail}" == "unlimited" ]; then
				tmp_content="$(gettext "will continuously send mail noitfy,")"
			elif [[ "${hit_rtime_detail}" =~ "ming" ]]; then
				local n=${hit_rtime_detail%:*}; n=${n##*:}
				local m=${hit_rtime_detail##*:}
				tmp_content="$(eval_gettext "will send no more than \${m} mail notify, now for the \${n} times,")"
			elif [[ "${hit_rtime_detail}" =~ "last" ]]; then
				local m=${hit_rtime_detail##*:}
				tmp_content="$(eval_gettext "will send no more than \${m} mail notify, now for the last time,")"
			fi
			mail_policy_detail="${mail_policy_detail} ${tmp_content}"
			if [ -n "${hit_range_detail}" ]; then
				tmp_content="$(eval_gettext "mail notify range: \${hit_range_detail}")"
				mail_policy_detail="${mail_policy_detail} ${tmp_content}"
			fi

			result_emllst=$( ${SENDMAIL} -f "${plugin_name}" -s "${jid}" \
						-i "${output}" -h "${hd_output}" \
						-p "${mail_policy_detail}" 2>&1 )
			result_emllst=" ${m_alert} ### ${result_emllst} " 
			write_log ${jid} ${plugin_name} "mail notify finished, details in ${SENDMAIL_LOG##*/}. CONTINUE";
		else
			result_emllst=" banned ### $(gettext "banned by mail notify nower heapuprc number") "
			write_log ${jid} ${plugin_name} "mail notify is banned by nower heapuprc number. SKIP";
		fi
	else
		result_emllst=" banned ### $(gettext "banned by mail notify time-range") "
		write_log ${jid} ${plugin_name} "mail notify is banned at this time range. SKIP";
	fi
  fi

  # Step 12: check action: post_notify
  local p_alert=$(take_action_ornot "${plugin_name}" post_notify ${rc})
  if [ "${p_alert}" != "yes" ]; then
	write_log ${jid} ${plugin_name} "post notify disabled. SKIP";
  else
	write_log ${jid} ${plugin_name} "post notify enabled. CONTINUE";
	[ "${hd_output}" == "auto handle is disabled. Nothing to do" ] && hd_output="disabled"
	# eval  will return syntax error. why ?
	[ -z "${_now_errcount}" ] && _now_errcount=0
	${POSTLOG_SH} -t "post" -p "${plugin_name}" -j "${jid}" -o "${output}" -h "${hd_output}" -e "${result_emllst}" -s "${result_smslst}" -f "${snapfile}" -r "${_now_errcount}" 2>&1
	write_log ${jid} ${plugin_name} "post notify finished."\
		"details in ${POSTLOG_LOG##*/}. CONTINUE";
  fi

  # Step 13: plugin finished
  update_lastrun_and_nextrun "${plugin_name}" "${jid}"
  un_lock "${plugin_name}" "${jid}"	# unlock first
  del_fpid "${plugin_name}"  "${jid}"	# then del pid file
  write_log ${jid} ${plugin_name} "FINISHED"
  unset _LOG
  return 0
}



# Process inner plugin, in fact simplified version of process_plugin
# Usage:	process_inner_plugin    plugin_name  [startrun]
# Note: 	if startrun, no need to unlock when inner plugin finished, because didn't add lock
#
process_inner_plugin() {
  local plugin_name=$1  mode=$2 output=

  # Step 1: set jid
  local jid="${mode}"

  # Step 2: check plugin script 
  write_log -f ${INNER_LOG} ${jid} ${plugin_name} "START"
  if [ ! -f "${INNER_DIR}/${plugin_name}" ]; then
        write_log -f ${INNER_LOG} ${jid} ${plugin_name} "plugin file:"\
		"[${INNER_DIR}/${plugin_name}] not exist. EXIT";
        [ "${mode}" == "startrun" ] || un_lock "${plugin_name}" "${jid}"
	del_fpid "${plugin_name}" "${jid}"
        return 3
  else
        write_log -f ${INNER_LOG} ${jid} ${plugin_name} "plugin file:"\
		"[${INNER_DIR}/${plugin_name}] exist -> exec. CONTINUE";
  fi

  # Step 3: execute plugin / get return stuff
  [ ! -x "${INNER_DIR}/${plugin_name}" ] && /bin/chmod a+x "${INNER_DIR}/${plugin_name}"
  output=$( eval "${INNER_DIR}/${plugin_name}" 2>&1 )
  write_log -f ${INNER_LOG} ${jid} ${plugin_name} "execution completed."\
	"return: [${output}]";

 # Step 4: plugin finished
 update_status "${plugin_name}" "${jid}" "${output}"
 update_lastrun_and_nextrun "${plugin_name}" "${jid}"
 [ "${mode}" == "startrun" ] || un_lock "${plugin_name}" "${jid}"	# unlock first
 del_fpid "${plugin_name}" "${jid}"				# then del pid file
 write_log -f ${INNER_LOG} ${jid} ${plugin_name} "execution DONE."

}

# Process plugin running timeout
# Usage:    	process_plugin_timeout   plugin_name  durationtime
# 
process_plugin_timeout() {
  local plugin_name=$1  durationtime=$2
  # local jid=$3          # can't inherit jobid from caller, will set a new jid
  local jid=$( ${PLUTIL} unique_digest )      ### set a new jid
  local level="tmout"
  local output="{${level}}:{str}:{ $(eval_gettext "Plugin \${plugin_name} Execution TimeOut")"\
"| $(date +%F_%T): $(eval_gettext "\${plugin_name} has been terminated")"\
"| $(html_red "$(eval_gettext "Plugin: [\${plugin_name}] execution timeout, has been terminated.")") ### }";

  write_log -f "${MOLE_LOG}" "$jid ${plugin_name} running timeout"\
	"has been running for ${durationtime} seconds"

  # Step 0: update status
  update_status "${plugin_name}" "${jid}" "${output}"

  # Step x: update headed up rc number.
  add_heapuprc_count "${plugin_name}" "${level}" "${jid}"

  # Step 1: update lastrun and nextrun
  update_lastrun_and_nextrun "${plugin_name}" "${jid}"

  # Step 2: stop timeout plugin 
  stop_single_plugin "${plugin_name}"
  # return here while inner plugin
  [[ "${plugin_name}" =~ ${INNER_BEGIN} ]] && return 0

  # Step 2: take snapshot
  local t_snap=$(take_action_ornot "${plugin_name}" take_snapshot "tmout")
  local snapfile=
  if [ "${t_snap}" != "yes" ]; then
        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"take snapshot disabled. SKIP"
  else
        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"take snapshot enabled. CONTINUE"
        snapfile=$( ${TAKESNAP_SH} -f "${plugin_name}" -s "$jid" 2>/dev/null )
	snapfile=" ${t_snap} ### ${snapfile##*/} "
        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"take snapshot finished, detailis in ${TAKESNAP_LOG##*/}. CONTINUE"
  fi

  # Step 3: auto handler while timeout
  local a_hand=$(take_action_ornot "${plugin_name}" auto_handle "tmout")
  local hd_output=  hd_rc=
  if [ "${a_hand}" != "yes" ]; then
 	write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"auto handle disabled. SKIP"
	hd_output="auto handle is disabled. Nothing to do"
  else
	write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"auto handle enabled. CONTINUE"
	local handler=$(get_auto_handler "${plugin_name}")
        if [ -f "${HANDLER_DIR}/${handler}" -a -s "${HANDLER_DIR}/${handler}" ]; then
                write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
			"auto handler [${HANDLER_DIR}/${handler}] exists. CONTINUE"
                [ ! -x "${HANDLER_DIR}/${handler}" ] && /bin/chmod a+x "${HANDLER_DIR}/${handler}" 2>&-
		hd_output=$( eval "${HANDLER_DIR}/${handler}" 2>&1 )
		hd_rc=$?
                write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
			"auto handle execution completed, return code:[${hd_rc}] return string: [${hd_output}], CONTINUE"
                local HANDLER_MAXLEN=$(get_handler_maxlen)
                local handler_output_length="${#hd_output}"
                if [ "$(echo  "${handler_output_length} > $HANDLER_MAXLEN" | bc 2>&-)" == "1" ]; then  ### truncate it
                        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
				"handler output length exceed, ${handler_output_length} > ${HANDLER_MAXLEN}, TRUNCATE"
                        hd_output="${hd_output:0:${HANDLER_MAXLEN}}"
                        hd_output="${hd_output}}"             ### completion '}' after truncated
                        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
				"handler output length exceed, truncated result: [${hd_output}], CONTINUE"
                else 
			write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
				"handler output length normal ${handler_output_length}, CONTINUE";
                fi   
		hd_output="auto handler file [${handler}] return ### ### ${hd_output}"
        else
                write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
			"auto handler [${HANDLER_DIR}/${handler}] not exist or empty. SKIP"
		hd_output="auto handler file [${handler}] not exist or empty. Nothing to do"
        fi
  fi

  # Step 4: send timeout notify sms
  local s_alert=$(take_action_ornot "${plugin_name}" sms_notify "tmout")
  local result_smslst=
  local sms_receviers=$(get_sms_receviers "${plugin_name}")
  if [ "${s_alert}" != "yes" ]; then
        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"sms notify disabled. SKIP"
  else
        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"sms notify enabled. CONTINUE"
        result_smslst=" ${s_alert} ### ### ${sms_receviers} "
        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"sms notify without local handler, set all receviers as failed. CONTINUE"
  fi

  # Step 5: send timeout notify mail
  local m_alert=$(take_action_ornot "${plugin_name}" mail_notify "tmout")
  local result_emllst=
  if [ "${m_alert}" != "yes" ]; then
        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"mail notify disabled. SKIP"
  else
	write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"mail notify enabled. CONTINUE"
        local mail_policy=$(get_mail_policy ${plugin_name})
        write_log ${jid} ${plugin_name} "mail notify policy is [${mail_policy}]. CONTINUE";
        if hit_policy_range_ornot "${mail_policy}"; then
		result_emllst=$( ${SENDMAIL} -f "${plugin_name}" -s "$jid" -i "${output}" -h "${hd_output}" 2>&1 )
		result_emllst=" ${m_alert} ### ${result_emllst} "
		write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
			"send timeout mail finished, details in ${SENDMAIL_LOG##*/}. CONTINUE"
	else 
		result_emllst=" banned ### $(gettext "banned by mail notify time-range") "
		write_log ${jid} ${plugin_name} "mail notify is banned at this time range. SKIP";
        fi 
  fi

  # Step 6: post timeout information
  local p_alert=$(take_action_ornot "${plugin_name}" post_notify "tmout")
  if [ "${p_alert}" != "yes" ]; then
        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"post notify disabled. SKIP"
  else
        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"post notify enabled. CONTINUE"
	[ "${hd_output}" == "auto handle is disabled. Nothing to do" ] && hd_output="disabled"
  	${POSTLOG_SH} -t "post" -p "${plugin_name}" -j "$jid" -o "${output}" -h "${hd_output}" -e "${result_emllst}" -s "${result_smslst}" -f "${snapfile}" -r 0 2>&1
        write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"post alert finished, details in ${POSTLOG_LOG##*/}. CONTINUE"
  fi


}

# Process system overloaded
# Usage:    	process_sysoverload  plugin-name   sysload_now  sysload_limit   jobid
# Example:	process_sysoverload  check_smtp_svr  39  30
# 
process_sysoverload() {
  local plugin_name=$1  sysload_now=$2  sysload_limit=$3
  local jid=$4          # inherit jobid
  local level="ovld"
  local output="{${level}}:{str}:{ $(gettext "System OverLoad")"\
"| $(date +%F_%T): $(eval_gettext "\${plugin_name} has been cancled")"\
"| $(html_red "$(eval_gettext "Sysload: [\${sysload_now}] over than Uplimit: [\${sysload_limit}]")") ### "\
"$(eval_gettext "Plugin: [\${plugin_name}] has been cancled") ### }";
  local hd_output="$(gettext "System OverLoaded, Nothing to do")"

  write_log -f "${MOLE_LOG}" "$jid MOLE sysload overloaded:"\
	"${sysload_now} >= ${sysload_limit}"

  # Step 0: update status.
  update_status "${plugin_name}" "${jid}" "${output}"

  # Step x: update heaped up rc number.
  add_heapuprc_count "${plugin_name}" "${level}" "${jid}"

  # Step 1: update lastrun and nextrun.
  update_lastrun_and_nextrun "${plugin_name}" "${jid}"

  # Step 2: take snapshot whatever.
  local snapfile=
  write_log -f "${MOLE_LOG}" "$jid MOLE"\
	"taking snapshot"
  snapfile=$( ${TAKESNAP_SH} -f "${plugin_name}" -s "$jid" 2>/dev/null )
  snapfile=" yes ### ${snapfile##*/} "

  # Step 3: send sms_notify.
  local result_smslst=
  local sms_receviers=$(get_sms_receviers "${plugin_name}")
  write_log -f "${MOLE_LOG}" "$jid MOLE"\
	"sending sms"
  result_smslst=" yes ### ### ${sms_receviers} "
  write_log -f "${MOLE_LOG}" "$jid MOLE"\
	"sms notify without local handler, set all receviers as failed. CONTINUE";

  # Step 4: send alert mail whatever.
  write_log -f "${MOLE_LOG}" "$jid MOLE"\
	"sending alert mail"
  local result_emllst=
  local mail_policy=$(get_mail_policy ${plugin_name})
  write_log ${jid} ${plugin_name} "mail notify policy is [${mail_policy}]. CONTINUE";
  if hit_policy_range_ornot "${mail_policy}"; then
 	result_emllst=$( ${SENDMAIL} -f "${plugin_name}" -s "$jid" -i "${output}" -h "${hd_output}" 2>&1 )
  	result_emllst=" yes ### ${result_emllst} "
  else 
	result_emllst=" banned ### $(gettext "banned by mail notify time-range") "
	write_log ${jid} ${plugin_name} "mail notify is banned at this time range. SKIP";
  fi 

  # Step 5: post alert information whatever.
  write_log -f "${MOLE_LOG}" "$jid MOLE"\
	"posting alert data"
  [ "${hd_output}" == "System OverLoaded, Nothing to do" ] && hd_output="disabled"
  ${POSTLOG_SH} -t "post" -p "${plugin_name}" -j "$jid" -o "${output}" -h "${hd_output}" -e "${result_emllst}" -s "${result_smslst}" -f "${snapfile}" -r 0 2>&1
}


# Process kids process number exceed
# Usage:    	process_kidsexceed plugin-name   kidsnum_now  kidsnum_limit  jobid
# Example:	process_kidsexceed check_smtp_svr  32  30
# 
process_kidsexceed() {
  local plugin_name=$1  kidsnum_now=$2  kidsnum_limit=$3
  local jid=$4          # inherit jobid
  local level="kids"
  local output="{${level}}:{str}:{ $(gettext "Too Many Agent Kid Processes")"\
"| $(date +%F_%T): $(eval_gettext "\${plugin_name} has been cancled")"\
"| $(html_red "$(eval_gettext "Kids Running: [\${kidsnum_now}] over than Uplimit: [\${kidsnum_limit}]")") ### "\
"$(eval_gettext "Plugin: [\${plugin_name}] has been cancled") ### }";
  local hd_output="$(gettext "Kid Processes Number Exceed, Nothing to do")"

  write_log -f "${MOLE_LOG}" "$jid MOLE kidsnum exceed:"\
	"${kidsnum_now} >= ${kidsnum_limit}"

  # Step 0: update status.
  update_status "${plugin_name}" "${jid}" "${output}"

  # Step x: update heaped up rc number.
  add_heapuprc_count "${plugin_name}" "${level}" "${jid}"

  # Step 1: update lastrun and nextrun.
  update_lastrun_and_nextrun "${plugin_name}" "${jid}"

  # Step 2: take snapshot whatever.
  local snapfile=
  write_log -f "${MOLE_LOG}" "$jid MOLE"\
	"taking snapshot"
  snapfile=$( ${TAKESNAP_SH} -f "${plugin_name}" -s "$jid" 2>/dev/null )
  snapfile=" yes ### ${snapfile##*/} "

  # Step 3: send sms_notify.
  local result_smslst=
  local sms_receviers=$(get_sms_receviers "${plugin_name}")
  write_log -f "${MOLE_LOG}" "$jid MOLE"\
        "sending sms"
  result_smslst=" yes ### ### ${sms_receviers} "
  write_log -f "${MOLE_LOG}" "$jid MOLE"\
	"sms notify without local handler, set all receviers as failed. CONTINUE"

  # Step 4: send alert mail whatever.
  write_log -f "${MOLE_LOG}" "$jid MOLE"\
	"sending alert mail"
  local result_emllst=
  local mail_policy=$(get_mail_policy ${plugin_name})
  write_log ${jid} ${plugin_name} "mail notify policy is [${mail_policy}]. CONTINUE";
  if hit_policy_range_ornot "${mail_policy}"; then
  	result_emllst=$( ${SENDMAIL} -f "${plugin_name}" -s "$jid" -i "${output}" -h "${hd_output}" 2>&1 )
  	result_emllst=" yes ### ${result_emllst} "
  else
	result_emllst=" banned ### $(gettext "banned by mail notify time-range") "
	write_log ${jid} ${plugin_name} "mail notify is banned at this time range. SKIP";
  fi

  # Step 5: post alert information whatever.
  write_log -f "${MOLE_LOG}" "$jid MOLE"\
	"posting alert data";
  [ "${hd_output}" == "Kid Processes Number Exceed, Nothing to do" ] && hd_output="disabled"
  ${POSTLOG_SH} -t "post" -p "${plugin_name}" -j "$jid" -o "${output}" -h "${hd_output}" -e "${result_emllst}" -s "${result_smslst}" -f "${snapfile}" -r 0 2>&1
}

# Process plugin misform rcode/output
# Usage:	process_plugin_misform {plugin-name}  {reason_type}  {reason_value}  {jobid}
# Note:		reason_type	~  rc|lines|format|level|mismatch|type
# Example:	process_plugin_misform sysload  rc  9
#
process_plugin_misform() {
  local plugin_name=$1  reason_type=$2  reason_value=$3 
  local jid=$4		# inherit jobid
  local level="misform"
  local reason=
  case "${reason_type}" in
  "rc") 
	reason="$(eval_gettext "plugin return code invalid: [\${reason_value}], only 0-5 allowed")"
	;;
  "lines")
	reason="$(eval_gettext "plugin output lines number invalid: [\${reason_value}], only one-line allowed")"
	;;
  "format")
	reason="$(eval_gettext "plugin output format unrecognized: [\${reason_value}], only {a}:{b}:{c} allowed")"
	;;
  "level")
	reason="$(eval_gettext "plugin output level unrecognized: [\${reason_value}], only [succ,warn,crit,unkn,noop,notify] allowed")"
	;;
  "mismatch")
	reason="$(eval_gettext "plugin output level mismatch: [\${reason_value}], only matched level <=> rc allowed")"
	;;
  "type")
	reason="$(eval_gettext "plugin output type unrecognized: [\${reason_value}], only [file,str] allowed")"
	;;
  esac
  local output="{${level}}:{str}:{ $(eval_gettext "Misforma Output for Plugin \${plugin_name}")"\
"| $(date +%F_%T): $(eval_gettext "\${plugin_name} has been cancled")"\
"| $(eval_gettext "plugin \${plugin_name} output misforma on [\${reason_type}]") ### "\
"$(html_red "${reason}") ### }";
  local hd_output="$(gettext "Plugin Output Misform, Nothing to do")"

  write_log -f "${MOLE_LOG}" "$jid ${plugin_name} output misforma:"\
	"${reason}"

  # Step 0: update status.
  update_status "${plugin_name}" "${jid}" "${output}"

  # Step x: update heaped up rc number.
  add_heapuprc_count "${plugin_name}" "${level}" "${jid}"

  # Step 1: update lastrun and nextrun.
  update_lastrun_and_nextrun "${plugin_name}" "${jid}"

  # Step 2: send misforma notify-mail or not ?
  local notify_onmisform=$(get_notify_onmisform)
  local result_emllst=  result_smslst=  snapfile=" no ### "
  if [ "${notify_onmisform}" == "yes" ]; then
  	write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
        	"sending notify mail"
	local mail_policy=$(get_mail_policy ${plugin_name})
	write_log ${jid} ${plugin_name} "mail notify policy is [${mail_policy}]. CONTINUE";
        if hit_policy_range_ornot "${mail_policy}"; then
  		result_emllst=$( ${SENDMAIL} -f "${plugin_name}" -s "$jid" -i "${output}" -h "${hd_output}" 2>&1 )
		result_emllst=" yes ### ${result_emllst} "
	else 
		result_emllst=" banned ### $(gettext "banned by mail notify time-range") "
		write_log ${jid} ${plugin_name} "mail notify is banned at this time range. SKIP";
        fi 

	write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"sending notify sms"
	local sms_receviers=$(get_sms_receviers "${plugin_name}")
	result_smslst=" yes ### ### ${sms_receviers} "
	write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"sms notify without local handler, set all receviers as failed."
	
  else
	result_emllst=" no ### "
	result_smslst=" no ### "
	write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
		"misform notify(mail/sms) disabled, SKIP" 
  fi

  # Step 3: post misforma information whatever.
  write_log -f "${MOLE_LOG}" "$jid ${plugin_name}"\
        "posting notify data"
  [ "${hd_output}" == "Plugin Output Misform, Nothing to do" ] && hd_output="disabled"
  ${POSTLOG_SH} -t "post" -p "${plugin_name}" -j "$jid" -o "${output}" -h "${hd_output}" -e "${result_emllst}" -s "${result_smslst}" -f "${snapfile}" -r 0 2>&1
}



#################  Debug Area  #####################

# stopps_by_pidfile  /usr/local/esop/agent/mole/tmp/run/esop_mole.pid
# read_mole_config global locale
# read_mole_config -f /tmp/123  global locale
# clear_mole_config default enable
#is_float  .1; echo $?
#is_float  0; echo $?
#is_float  9999; echo $?
#is_float  11a.0; echo $?
#is_float  11.1zzz; echo $?
#is_between 99.9 1.1 100; echo $?
#is_between .9 azdk 100; echo $?
#valid_notify_policy " abc 3 ";echo $?
#valid_notify_policy " 0-24,1-1,1-100,abc-def,,  12 ";echo $?
#valid_notify_policy " 0-2,7-9,11 5"; echo $?
#get_mail_policy abc
#get_sms_policy abc
#get_policy_analysize " 0-24,1-1,1-100,3-108,10000-10007,,  12  "  range
#get_policy_analysize  "0-9,07-08,13-18,15-17  5"  range
#get_policy_analysize  "7-9,6-14,0-4 5"  range 
#get_policy_analysize  "7-9,6-14,0-4 5"  range  hrformat
#get_policy_analysize  "0-1,2-3,5-9 5"  range 
#get_policy_analysize  "0-1,2-3,5-9 5"  range  hrformat
#hit_policy_range_ornot "0-9,07-08,13-18  5";echo $?
#add_heapuprc_count sysload crit
#add_heapuprc_count sysload crit
#add_heapuprc_count sysload crit
#add_heapuprc_count sysload succ
#add_heapuprc_count sysload crit
#add_heapuprc_count sysload crit
#add_heapuprc_count sysload crit
#get_heapuprc_count sysload succ
#get_heapuprc_count sysload crit
#hit_policy_rtime_ornot sysload crit "$(get_mail_policy sysload)"; echo $?
