#!/usr/bin/env perl

our $basedir = '/usr/local/esop/agent/mole';
our $mole = "$basedir/sbin/mole";

BEGIN {
  my $basedir = '/usr/local/esop/agent/mole';
  my $pllib_dir = "$basedir/opt/plmods";
  my $esoplib_dir = "$basedir/opt/EsopLib";
  my @incs = (    # set additional path
        # rhel5 32bit
        $pllib_dir.'/lib/perl5/',
        $pllib_dir.'/lib/perl5/5.8.8/',
        $pllib_dir.'/lib/perl5/site_perl/',
        $pllib_dir.'/lib/perl5/site_perl/5.8.8/',
	$pllib_dir.'/lib/perl5/site_perl/5.8.8/i386-linux-thread-multi/',
        # rhel5 64bit
        $pllib_dir.'/lib64/perl5/',
        $pllib_dir.'/lib64/perl5/5.8.8/',
        $pllib_dir.'/lib64/perl5/site_perl/',
        $pllib_dir.'/lib64/perl5/site_perl/5.8.8/',
	$pllib_dir.'/lib64/perl5/site_perl/5.8.8/x86_64-linux-thread-multi/',
        # rhel6 32bit
        $pllib_dir.'/lib/perl5/',
	$pllib_dir.'/share/perl5/',
        # rhel6 64bit
        $pllib_dir.'/lib64/perl5/',
	$pllib_dir.'/share/perl5/',
	# esop lib
	$esoplib_dir.'/lib/',
  );  

  push @INC, @incs;
};

use warnings;
use strict;
use utf8;
use JSON;
use EsopLib;
# use Smart::Comments;
binmode(STDIN, ":encoding(utf8)");
binmode(STDOUT, ":encoding(utf8)");
binmode(STDERR, ":encoding(utf8)");

$| = 1;

# return codes
our ($state_succ,$state_warn,$state_crit,$state_unkn,$state_noop,$state_notify) = (0,1,2,3,4,5);

# return stuff
our ($rc, $result) = (0,'');

our $filename = (split /\//, __FILE__)[-1];

# check mole 
unless (-f $mole && -x $mole) {
  printf "{unkn}:{str}:{$mole not prepared.}";
  exit $state_unkn;
}


our $SaveFile = "/var/tmp/.mole.$filename.tmp";

#
# global sub def start
#
sub get_osbitmode {
  my $osbit = '32';
  my $getconf = "/usr/bin/getconf";
  if (-f $getconf && -x $getconf) {
          open my $fh, "$getconf LONG_BIT 2>&- |";
          if ($fh) {
                while(<$fh>){
                        chomp; s/\A\s*//; s/\s*\Z//g; $osbit = $_;
                }    
          }    
  }
  return $osbit;
}

sub get_runlevel {
  my $level = 'X';
  my $inittab = '/etc/inittab';
  if (-f $inittab && -r $inittab) {
        if(open my $fh, "<", $inittab){
                while(<$fh>){
                        chomp; s/(\A\s+|\s+\Z)//g;
                        if (m/\A\s*id:/){
                                $level = (split /:/)[1];
                                last;
                        }
                }
                close $fh;
        }
  }
  return $level;
}

sub load_oldinfo {
  my $savefile = shift;
  my $oldinfo  = undef;			# Note: return jsoned string
  unless (defined $savefile && -f $savefile &&  -r $savefile) {
	return undef;
  } 
  if (open my $fh, "<", $savefile) {
	while(<$fh>){
		$oldinfo = $_;		# read only one line and exit
		last;
	}
	close $fh if ($fh);
  } else {
	return undef;
  }
  unless (defined $oldinfo && $oldinfo =~ s/\A0 //g) {	# $oldinfo must start by 0+space
	return undef;
  }
  return $oldinfo;
}

sub write_newinfo {
  my $savefile = shift;
  my $newinfo  = shift; 		# Note: receive jsoned string
  unless (defined $newinfo && $newinfo ne '') {
	return undef;
  }
  if (open my $fh, ">", $savefile ) {
	unless (print $fh "0 $newinfo\n") {	# write new info start by 0+space, Note: use print not printf to avoid $newinfo contain '%'
		return undef;
	}
	close $fh if ($fh);
  } else {
	return undef;
  }
}

sub genjson_diffinfo {
  my ($oldinfo,$newinfo) = @_;	# Note: only receive raw (unjsoned) %hash struct
  my %oldinfo = %{$oldinfo} if (defined $oldinfo);
  my %newinfo = %{$newinfo} if (defined $newinfo);
  my %diffinfo = ();
  my $diffjson = '{}';
  unless(%oldinfo && %newinfo) {
	return $diffjson;
  }

  ### diff {arp}
  if (@{$newinfo{'arp'}} ne @{$oldinfo{'arp'}}) {
	$diffinfo{'arp'} = \@{$newinfo{'arp'}};
  } else {
        my @newinfo_arp = @{$newinfo{'arp'}};   # item in array sort order same
        my @oldinfo_arp = @{$oldinfo{'arp'}};   # item in array sort order same
        for(my $i=0;$i<=$#newinfo_arp;$i++){
                my %newinfo_arp = %{$newinfo_arp[$i]};
                my %oldinfo_arp = %{$oldinfo_arp[$i]};
                foreach my $x (sort keys %{$newinfo_arp[$i]}) {
                        unless ( $newinfo_arp{$x} eq $oldinfo_arp{$x} ) {
                                $diffinfo{'arp'} = \@{$newinfo{'arp'}};
                                goto ARP_BREAK;
                        }    
                }    
        }    
        ARP_BREAK: {
		;
        }
  }

  ### diff {cpu_info}
  if ($newinfo{'cpu_info'}{'logical'} ne $oldinfo{'cpu_info'}{'logical'} ||
      $newinfo{'cpu_info'}{'physical'} ne $oldinfo{'cpu_info'}{'physical'} ) {
	$diffinfo{'cpu_info'} = \%{$newinfo{'cpu_info'}};
  }

  ### diff {cpu_usage}
  foreach my $i (sort keys %{$newinfo{'cpu_usage'}}) {
	unless ($newinfo{'cpu_usage'}{$i} eq $oldinfo{'cpu_usage'}{$i}) {
		$diffinfo{'cpu_usage'} = \%{$newinfo{'cpu_usage'}};
		last;
	}
  }

  ### diff {disk_space}
  if (@{$newinfo{'disk_space'}} ne @{$oldinfo{'disk_space'}}) {
	$diffinfo{'disk_space'} = \@{$newinfo{'disk_space'}};
  } else {
        my @newinfo_diskspace = @{$newinfo{'disk_space'}};   # item in array sort order same
        my @oldinfo_diskspace = @{$oldinfo{'disk_space'}};   # item in array sort order same
        for(my $i=0;$i<=$#newinfo_diskspace;$i++){
                my %newinfo_diskspace = %{$newinfo_diskspace[$i]};
                my %oldinfo_diskspace = %{$oldinfo_diskspace[$i]};
                foreach my $x (sort keys %{$newinfo_diskspace[$i]}) {
                        unless ( $newinfo_diskspace{$x} eq $oldinfo_diskspace{$x} ) {
                                $diffinfo{'disk_space'} = \@{$newinfo{'disk_space'}};
                                goto DISK_BREAK;
                        }    
                }    
        }    
        DISK_BREAK: {
		;
        }
  }

  ### diff {dns}
  if (@{$newinfo{'dns'}} ne @{$oldinfo{'dns'}}) {
	$diffinfo{'dns'} = \@{$newinfo{'dns'}};
  } else {
	if (join("",sort @{$newinfo{'dns'}}) ne join("",sort @{$oldinfo{'dns'}})) {
		$diffinfo{'dns'} = \@{$newinfo{'dns'}};
	}
  }
  
  ### diff {inet_name}
  if (@{$newinfo{'inet_name'}} ne @{$oldinfo{'inet_name'}}) {
	$diffinfo{'inet_name'} = \@{$newinfo{'inet_name'}};
  } else {
        my @newinfo_inetname = @{$newinfo{'inet_name'}};   # item in array sort order same
        my @oldinfo_inetname = @{$oldinfo{'inet_name'}};   # item in array sort order same
        for(my $i=0;$i<=$#newinfo_inetname;$i++){
                my %newinfo_inetname = %{$newinfo_inetname[$i]};
                my %oldinfo_inetname = %{$oldinfo_inetname[$i]};
                foreach my $x (sort keys %{$newinfo_inetname[$i]}) {
                        unless ( $newinfo_inetname{$x} eq $oldinfo_inetname{$x} ) {
                                $diffinfo{'inet_name'} = \@{$newinfo{'inet_name'}};
                                goto INET_BREAK;
                        }    
                }    
        }    
        INET_BREAK: {
		;
        }
  }

  ### diff {input_dev}
  if (@{$newinfo{'input_dev'}} ne @{$oldinfo{'input_dev'}}) {
	$diffinfo{'input_dev'} = \@{$newinfo{'input_dev'}};
  } else {
	if (join("",sort @{$newinfo{'input_dev'}}) ne join("",sort @{$oldinfo{'input_dev'}})) {
		$diffinfo{'input_dev'} = \@{$newinfo{'input_dev'}};
	}
  }

  ### diff {lastlogin}
  if ($newinfo{'lastlogin'}{'number'} ne $oldinfo{'lastlogin'}{'number'}) {
	$diffinfo{'lastlogin'} = \%{$newinfo{'lastlogin'}};
  } else {
	if (join("",sort @{$newinfo{'lastlogin'}{'result'}}) ne join("",sort @{$oldinfo{'lastlogin'}{'result'}})) {
		$diffinfo{'lastlogin'} = \%{$newinfo{'lastlogin'}};
	}
  }

  ### diff {mem_info}
  if ($newinfo{'mem_info'}{'memfreedevnum'} ne $oldinfo{'mem_info'}{'memfreedevnum'} ||
	$newinfo{'mem_info'}{'meminstallednum'} ne $oldinfo{'mem_info'}{'meminstallednum'} ||
	$newinfo{'mem_info'}{'memmaxcapacity'} ne $oldinfo{'mem_info'}{'memmaxcapacity'} ||
	$newinfo{'mem_info'}{'memmaxdevnum'} ne $oldinfo{'mem_info'}{'memmaxdevnum'} ||
	$newinfo{'mem_info'}{'os_mem_total'} ne $oldinfo{'mem_info'}{'os_mem_total'} ||
	$newinfo{'mem_info'}{'os_swap_total'} ne $oldinfo{'mem_info'}{'os_swap_total'} ) {
	$diffinfo{'mem_info'} = \%{$newinfo{'mem_info'}};
  }

  ### diff {mem_usage}
  foreach my $i (sort keys %{$newinfo{'mem_usage'}}) {
	unless ($newinfo{'mem_usage'}{$i} eq $oldinfo{'mem_usage'}{$i}) {
		$diffinfo{'mem_usage'} = \%{$newinfo{'mem_usage'}};
		last;
	}
  }

  
  ### diff {mount}
  if (@{$newinfo{'mount'}} ne @{$oldinfo{'mount'}}) {
	$diffinfo{'mount'} = \@{$newinfo{'mount'}};
  } else {
        my @newinfo_mount = @{$newinfo{'mount'}};   # item in array sort order same
        my @oldinfo_mount = @{$oldinfo{'mount'}};   # item in array sort order same
        for(my $i=0;$i<=$#newinfo_mount;$i++){
                my %newinfo_mount = %{$newinfo_mount[$i]};
                my %oldinfo_mount = %{$oldinfo_mount[$i]};
                foreach my $x (sort keys %{$newinfo_mount[$i]}) {
                        unless ( $newinfo_mount{$x} eq $oldinfo_mount{$x} ) {
                                $diffinfo{'mount'} = \@{$newinfo{'mount'}};
                                goto MOUNT_BREAK;
                        }    
                }    
        }    
        MOUNT_BREAK: {
		;
        }
  }

  ### diff {netstat}
  # always post new netstat
  $diffinfo{'netstat'} = \%{$newinfo{'netstat'}};

  ### diff {online_user}
  if (@{$newinfo{'online_user'}} ne @{$oldinfo{'online_user'}}) {
	$diffinfo{'online_user'} = \@{$newinfo{'online_user'}};
  } else {
        my @newinfo_onlineuser = @{$newinfo{'online_user'}};   # item in array sort order same
        my @oldinfo_onlineuser = @{$oldinfo{'online_user'}};   # item in array sort order same
        for(my $i=0;$i<=$#newinfo_onlineuser;$i++){
                my %newinfo_onlineuser = %{$newinfo_onlineuser[$i]};
                my %oldinfo_onlineuser = %{$oldinfo_onlineuser[$i]};
                foreach my $x (sort keys %{$newinfo_onlineuser[$i]}) {
                        unless ( $newinfo_onlineuser{$x} eq $oldinfo_onlineuser{$x} ) {
                                $diffinfo{'online_user'} = \@{$newinfo{'online_user'}};
                                goto ONLINE_BREAK;
                        }    
                }    
        }    
        ONLINE_BREAK: {
		;
        }
  }

  ### diff {os_info}
  foreach my $i (sort keys %{$newinfo{'os_info'}}) {
	unless ($newinfo{'os_info'}{$i} eq $oldinfo{'os_info'}{$i}) {
		$diffinfo{'os_info'} = \%{$newinfo{'os_info'}};
		last;
	}
  }

  ### diff {process}
  if ($newinfo{'process'}{'blocked'} ne $oldinfo{'process'}{'blocked'} || 
	$newinfo{'process'}{'ctxtnum'} ne $oldinfo{'process'}{'ctxtnum'} ||
	$newinfo{'process'}{'forksnum'} ne $oldinfo{'process'}{'forksnum'} ||
	$newinfo{'process'}{'totalnum'} ne $oldinfo{'process'}{'totalnum'} ) {
  	$diffinfo{'process'} = \%{$newinfo{'process'}};
  }

  ### diff {product_info}
  foreach my $i (sort keys %{$newinfo{'product_info'}}) {
	unless ($newinfo{'product_info'}{$i} eq $oldinfo{'product_info'}{$i}) {
		$diffinfo{'product_info'} = \%{$newinfo{'product_info'}};
		last;
	}
  }

  ### diff {raid_info}
  # do not post raid_info changes
  # $diffinfo{'raid_info'} = ();


  ### diff {route}
  if (@{$newinfo{'route'}} ne @{$oldinfo{'route'}}) {
	$diffinfo{'route'} = \@{$newinfo{'route'}};
  } else {
        my @newinfo_route = @{$newinfo{'route'}};   # item in array sort order same
        my @oldinfo_route = @{$oldinfo{'route'}};   # item in array sort order same
        for(my $i=0;$i<=$#newinfo_route;$i++){
                my %newinfo_route = %{$newinfo_route[$i]};
                my %oldinfo_route = %{$oldinfo_route[$i]};
                foreach my $x (sort keys %{$newinfo_route[$i]}) {
                        unless ( $newinfo_route{$x} eq $oldinfo_route{$x} ) {
                                $diffinfo{'route'} = \@{$newinfo{'route'}};
                                goto ROUTE_BREAK;
                        }    
                }    
        }    
        ROUTE_BREAK: {
		;
        }
  }

  ### diff {runlevel}
  unless ($newinfo{'runlevel'}  eq $oldinfo{'runlevel'}) {
	$diffinfo{'runlevel'} = $newinfo{'runlevel'};
  }

  ### diff {selinux}
  foreach my $i (sort keys %{$newinfo{'selinux'}}) {
	unless ($newinfo{'selinux'}{$i} eq $oldinfo{'selinux'}{$i}) {
		$diffinfo{'selinux'} = \%{$newinfo{'selinux'}};
		last;
	}
  }

  ### diff {startups}
  if (@{$newinfo{'startups'}} ne @{$oldinfo{'startups'}}) {
	$diffinfo{'startups'} = \@{$newinfo{'startups'}};
  } else {
	if (join("",sort @{$newinfo{'startups'}}) ne join("",sort @{$oldinfo{'startups'}})) {
		$diffinfo{'startups'} = \@{$newinfo{'startups'}};
	}
  }

  ### diff {sys_clock}
  foreach my $i (sort keys %{$newinfo{'sys_clock'}}) {
	unless ($newinfo{'sys_clock'}{$i} eq $oldinfo{'sys_clock'}{$i}) {
		$diffinfo{'sys_clock'} = \%{$newinfo{'sys_clock'}};
		last;
	}
  }

  ### diff {sys_lang}
  foreach my $i (sort keys %{$newinfo{'sys_lang'}}) {
	unless ($newinfo{'sys_lang'}{$i} eq $oldinfo{'sys_lang'}{$i}) {
		$diffinfo{'sys_lang'} = \%{$newinfo{'sys_lang'}};
		last;
	}
  }

  ### diff {sys_locks}
  unless ($newinfo{'sys_locks'} eq $oldinfo{'sys_locks'}) {
	$diffinfo{'sys_locks'} = $newinfo{'sys_locks'};
  }

  ### diff {sys_mods}
  if ( $oldinfo{'sys_mods'}{'number'} ne $newinfo{'sys_mods'}{'number'} ) {
	$diffinfo{'sys_mods'} = \%{$newinfo{'sys_mods'}};
  } else {
	if (join("",sort @{$newinfo{'sys_mods'}{'list'}}) ne join("",sort @{$oldinfo{'sys_mods'}{'list'}})) {
		$diffinfo{'sys_mods'} = \%{$newinfo{'sys_mods'}};
	}
  }

  ### diff {sysload}
  foreach my $i (sort keys %{$newinfo{'sysload'}}) {
	unless ($newinfo{'sysload'}{$i} eq $oldinfo{'sysload'}{$i}) {
		$diffinfo{'sysload'} = \%{$newinfo{'sysload'}};
		last;
	}
  }

  ### diff {systime}
  foreach my $i (sort keys %{$newinfo{'systime'}}) {
	unless ($newinfo{'systime'}{$i} eq $oldinfo{'systime'}{$i}) {
		$diffinfo{'systime'} = \%{$newinfo{'systime'}};
		last;
	}
  }

  ### diff {sysuser}
  if (@{$newinfo{'sysuser'}} ne @{$oldinfo{'sysuser'}}) {
	$diffinfo{'sysuser'} = \@{$newinfo{'sysuser'}};
  } else {
	my @newinfo_sysuser = @{$newinfo{'sysuser'}};	# item in array sort order same
	my @oldinfo_sysuser = @{$oldinfo{'sysuser'}};	# item in array sort order same
	for(my $i=0;$i<=$#newinfo_sysuser;$i++){
		my %newinfo_sysuser = %{$newinfo_sysuser[$i]};
		my %oldinfo_sysuser = %{$oldinfo_sysuser[$i]};
		foreach my $x (sort keys %{$newinfo_sysuser[$i]}) {
			unless ( $newinfo_sysuser{$x} eq $oldinfo_sysuser{$x} ) {
				$diffinfo{'sysuser'} = \@{$newinfo{'sysuser'}};
				goto SYSUSER_BREAK;
			}
		}
	}
	SYSUSER_BREAK: {
		;
	}
  }

  ### %diffinfo
  if ($diffjson = JSON->new->allow_nonref->utf8(1)->ascii(1)->canonical(1)->encode(\%diffinfo)) {
  	return $diffjson;
  } else {
	return $diffjson;
  }
}
#
# global sub def end
#

our $OS_RUNLEVEL = &get_runlevel;
our $OS_BITMODE  = &get_osbitmode;


our %data_config = (

  # original system_dyninfo
  'sysload'		=> 1,
  'online_user'		=> 1,
  'systime'		=> 1,
  'mem_usage'		=> 1,
  'process'		=> 1,
  'netstat'		=> 1,
  'lastlogin'		=> 1,
  'sys_mods'		=> 1,
  'sys_locks'		=> 1,
  'disk_space'		=> 1,
  'cpu_usage'		=> 1,

  # original system_fixinfo
  'product_info'	=> 1,
  #'mem_info'		=> 1,		# depend on (same as) product_info
  'cpu_info'		=> 1,
  'input_dev'		=> 1,
  'os_info'		=> 1,
  'sys_clock'		=> 1,
  'sys_lang'		=> 1,
  'selinux'		=> 1,
  'sysuser'		=> 1,
  'runlevel'		=> 1,
  'startups'		=> 1,
  'dns'			=> 1,
  'route'		=> 1,
  'arp'			=> 1,
  'mount'		=> 1,
  'inet_name'		=> 1,
  'raid_info'		=> 1,
);
### %data_config


our %result = ();



#
#  BEGIN to COLLECT SYSTEM INFORMATION 
#


##
##  system dyninfo
##

# sysload
if ($data_config{'sysload'}) {
  my %sysload= (
  	'1min'	=> '',
  	'5min'	=> '',
  	'15min'	=> '',
  );
  my $load_file = '/proc/loadavg';
  if (-f $load_file && -r $load_file) {
  	if (open my $fh, "<", $load_file) {
        	my ($load1,$load5,$load15) = ('','','');
        	while(<$fh>){
			($load1,$load5,$load15) = (split/\s+/)[0,1,2];
			last;
		}
		$sysload{'1min'} = $load1;
		$sysload{'5min'} = $load5;
		$sysload{'15min'} = $load15;
		close $fh if $fh;
  	}
  }
  ### %sysload
  $result{'sysload'} = \%sysload;
}


# online_user
if ($data_config{'online_user'}) {
  my @online_user = ();
  my $w = '/usr/bin/w';
  if (-f $w && -x $w) {
	open my $fh, "$w -h 2>&- | ";
  	if ($fh) {
		while(<$fh>){
			chomp;
			my %single_online = ();
			my @line = split/\s+/;
			@single_online{'name','from','time','idle','tty'} = @line[0,2,3,4,1];
			splice(@line,0,7);
			$single_online{'doing'} = join(" ",@line);
			if (length($single_online{'doing'}) > 20) {
				$single_online{'doing'} = substr($single_online{'doing'},0,15) . ' ...';
			}
			push @online_user, \%single_online;
		}
  	}
  }
  ### @online_user
  $result{'online_user'} = \@online_user;
}


# systime
if ($data_config{'systime'}) {
  my %systime = (
  	'systime'	=> time,
  	'boottime'	=> '',
  	'runtime'	=> '',
  	'idletime'	=> '',
  	'idlerate'	=> '',
  );
  my $stat_file = '/proc/stat';
  my $uptm_file = '/proc/uptime';
  my $cpu_file = '/proc/cpuinfo';
  if (-f $stat_file && -r $stat_file) {
  	if (open my $fh, "<", $stat_file) {
		while(<$fh>){
			if (m/\A\s*btime\s+(\d+)/i) {
				$systime{'boottime'} = $1;
				last;
			}
  		}
		close $fh if $fh;
  	}
  }
  if (-f $uptm_file && -r $uptm_file) {
	if (open my $fh, "<", $uptm_file) {
		while(<$fh>){
			@systime{'runtime','idletime'} = split/\s+/;
			last;
		}
		close $fh if $fh;
  	}
  }
  my $processor_number = 0;
  if (-f $cpu_file && -r $cpu_file) {
  	if (open my $fh, "<", $cpu_file) {
		while(<$fh>){
			if (m/\Aprocessor\s+/i) {
				$processor_number ++;
				next;
			}
		}
		close $fh if $fh;
  	}
  }
  $processor_number = 1 if $processor_number == 0;
  $systime{'idletime'} = $systime{'idletime'}/$processor_number;
  $systime{'idlerate'} = sprintf("%0.2f",100*$systime{'idletime'}/$systime{'runtime'}).'%';
  ### %systime
  $result{'systime'} = \%systime;
}



# mem_usage
if ($data_config{'mem_usage'}) {
  my %mem_usage = (
  	'mem_total'	=> '',
  	'swp_total'	=> '',
  	'mem_free'	=> '',
  	'swp_free'	=> '',
  	'mem_usage'	=> '',
  	'swp_usage'	=> '',
  );
  my $mem_file = '/proc/meminfo';
  if (-f $mem_file && -r $mem_file) {
  	if (open my $fh, "<", $mem_file) {
		while(<$fh>){
			if (m/\A\s*MemTotal:\s+(\d+)\s*KB/i) {
				$mem_usage{'mem_total'} = $1;
				next;
			}
			if (m/\A\s*SwapTotal:\s+(\d+)\s*KB/i) {
				$mem_usage{'swp_total'} = $1;
				next;
			}
			if (m/\A\s*MemFree:\s+(\d+)\s*KB/i) {
				$mem_usage{'mem_free'} = $1;
				next;
			}
			if (m/\A\s*SwapFree:\s+(\d+)\s*KB/i) {
				$mem_usage{'swp_free'} = $1;
				next;
			}
		}
		close $fh if $fh;
		if ($mem_usage{'mem_total'} && $mem_usage{'mem_free'}) {
			$mem_usage{'mem_usage'} = $mem_usage{'mem_total'}-$mem_usage{'mem_free'};
		}
		if ($mem_usage{'swp_total'} && $mem_usage{'swp_free'}) {
			$mem_usage{'swp_usage'} = $mem_usage{'swp_total'}-$mem_usage{'swp_free'};
		}
  	}
  }
  ### %mem_usage
  $result{'mem_usage'} = \%mem_usage;
}



# process
if ($data_config{'process'}) {
  my %process = (
  	'totalnum'	=> '',  # by: /proc/\d+/
  	'state'	=> '',  # by: ps -eo state=
  	'blocked'	=> '',
  	'ctxtnum'	=> '',
  	'forksnum'	=> '',
  );
  my $stat_file = '/proc/stat';
  if (-f $stat_file && -r $stat_file) {
  	if (open my $fh, "<", $stat_file) {
		while(<$fh>){
			if (m/\A\s*ctxt\s+(\d+)/i) {
				$process{'ctxtnum'} = $1;
				next;
			}
			if (m/\A\s*processes\s+(\d+)/i) {
				$process{'forksnum'} = $1;
				next;
			}
			if (m/\A\s*procs_blocked\s+(\d+)/i) {
				$process{'blocked'} = $1;
				next;
			}
		}
		close $fh if $fh;
  	}
  }
  if (-d "/proc/") {
  	my @process = glob "/proc/[0-9]*";
  	$process{'totalnum'} = @process;
  }
  my $ps = '/bin/ps';
  if (-f $ps && -x $ps) {
  	open my $fh, "$ps -eo stat= 2>&- | ";
  	my %ps_state = ();
  	if ($fh) {
		while(<$fh>){
			chomp; my $key = substr $_,0,1;
			$ps_state{$key} ++;
		}
  	}
  	$process{'state'} = \%ps_state;
  }
  ### %process
  $result{'process'} = \%process;
}



# netstat
if ($data_config{'netstat'}) {
  my %netstat = (
  	'total_tcp'	=> '',
  	'total_udp'	=> '',
  	'net_flow'	=> '',
  );
  my $tcp_file = '/proc/net/tcp';
  my $udp_file = '/proc/net/udp';
  my $net_devf = '/proc/net/dev';
  if (-f $tcp_file && -r $tcp_file) {
  	if (open my $fh, "<", $tcp_file) {
		my @tcp_content = <$fh>;
		$netstat{'total_tcp'} = scalar @tcp_content - 1;
		close $fh if $fh;
  	}
  }
  if (-f $udp_file && -r $udp_file) {
  	if (open my $fh, "<", $udp_file) {
		my @udp_content = <$fh>;
		$netstat{'total_udp'} = scalar @udp_content - 1;
		close $fh if $fh;
  	}
  }
  if (-f $net_devf && -r $net_devf) {
 	if (open my $fh, "<", $net_devf) {
		my @net_flow = ();
		while(<$fh>){
			if (m/\A\s*(.+?):\s*(.*)/) {
				my %single_flow = ();
				@{$single_flow{$1}}{qw(
					rxbyt rxpcks rxerrs rxdrop
					txbyt txpcks txerrs txdrop
				)} = (split/\s+/,$2)[0,1,2,3,8,9,10,11];
				$single_flow{$1}{'ttbyt'} = $single_flow{$1}{'rxbyt'} + $single_flow{$1}{'txbyt'};
				$single_flow{$1}{'ttpcks'} = $single_flow{$1}{'rxpcks'} + $single_flow{$1}{'txpcks'};
				push @net_flow, \%single_flow;
			}
		}
		close $fh if ($fh);
		$netstat{'net_flow'} = \@net_flow;
 	}
  }
  my $netstat = '/bin/netstat';
  if ( -f $netstat && -x $netstat) {
	open my $fh, "$netstat -s 2>&- | ";
	if ($fh) {
		my %tcp_statistics = ();
		my %udp_statistics = ();
		my ($flag_tcp, $flag_udp) = (0, 0);
		while(<$fh>){
			chomp;
			if (m/\ATcp:\s*\Z/i) {
				$flag_udp = 0;
				$flag_tcp = 1;
				next;
			} elsif (m/\AUdp:\s*\Z/i) {
				$flag_udp = 1;
				$flag_tcp = 0;
				next;
			} elsif (m/\A(\w+):\Z/i) {
				$flag_udp = 0;
				$flag_tcp = 0;
				next;
			}
			if ($flag_tcp) {
				if (m/(\d+)\s+?active connections openings/i) {
					$tcp_statistics{'active_conn'} = $1; next;
				} 
				if (m/(\d+)\s+?passive connection openings/i) {
					$tcp_statistics{'passive_conn'} = $1; next;
				} 
				if (m/(\d+)\s+?failed connection attempts/i) {
					$tcp_statistics{'failed_conn'} = $1; next;
				} 
				if (m/(\d+)\s+?connection resets received/i) {
					$tcp_statistics{'recvreset_conn'} = $1; next;
				} 
				if (m/(\d+)\s+?segments received/i) {
					$tcp_statistics{'seg_received'} = $1; next;
				} 
				if (m/(\d+)\s+?segments send out/i) {
					$tcp_statistics{'seg_sendout'} = $1; next;
				} 
				if (m/(\d+)\s+?segments retransmited/i) {
					$tcp_statistics{'seg_retrans'} = $1; next;
				} 
				if (m/(\d+)\s+?bad segments received/i) {
					$tcp_statistics{'seg_badrecv'} = $1; next;
				} 
				if (m/(\d+)\s+?resets sent/i) {
					$tcp_statistics{'reset_sent'} = $1; next;
				} 
			}
			if ($flag_udp) {
				if (m/(\d+)\s+?packets received/i) {
					$udp_statistics{'packet_recv'} = $1; next;
				} 
				if (m/(\d+)\s+?packets to unknown port received/i) {
					$udp_statistics{'packetunknownport_recv'} = $1; next;
				} 
				if (m/(\d+)\s+?packet receive errors/i) {
					$udp_statistics{'packet_recverror'} = $1; next;
				} 
				if (m/(\d+)\s+?packets sent/i) {
					$udp_statistics{'packet_sent'} = $1; next;
				} 
			}
		}
		if ($tcp_statistics{'seg_sendout'}) {
			if ($tcp_statistics{'seg_retrans'}) {
				$tcp_statistics{'seg_retrans_rate'} = sprintf ("%0.2f", 100*$tcp_statistics{'seg_retrans'}/$tcp_statistics{'seg_sendout'}).'%';
			} else {
				$tcp_statistics{'seg_retrans_rate'} = '0.00%';
			}
		}
		if ($udp_statistics{'packet_recv'}) {
			if ($udp_statistics{'packet_recverror'}) {
				$udp_statistics{'packet_lostrate'} = sprintf ("%0.2f", 100*$udp_statistics{'packet_recverror'}/$udp_statistics{'packet_recv'}).'%';
			} else {
				$udp_statistics{'packet_lostrate'} = '0.00%';
			}
		}
		$netstat{'tcp_statistics'} = \%tcp_statistics;
		$netstat{'udp_statistics'} = \%udp_statistics;
	}
  }
  ### %netstat
  $result{'netstat'} = \%netstat;
}



# lastlogin
if ($data_config{'lastlogin'}) {
  my %lastlogin = (
  	'number'	=> 10,
  	'result'	=> '',
  );
  my $last = '/usr/bin/last';
  my %months = (
  	'JAN' => 1, 'FEB' => 2, 'MAR' => 3, 
  	'APR' => 4, 'MAY' => 5, 'JUN' => 6,
  	'JUL' => 7, 'AUG' => 8, 'SEP' => 9,
  	'OCT' => 10, 'NOV' => 11, 'DEC' => 12,
  );
  if (-f $last && -x $last) {
  	open my $fh, "$last -n $lastlogin{'number'} -x 2>&- | ";
  	if ($fh) {
		my @login_result;
		while(<$fh>){
			chomp;
			next if m/\A(runlevel|reboot|shutdown)/i;
			last if m/\A\s*\Z/;
			my ($login_year, $login_month, $login_day,$login_ms) = (1900+(localtime(time()))[5],(split/\s+/)[4,5,6]);
			next unless (exists $months{uc($login_month)});  # in case of IP field nil
			my $login_time = sprintf("%d-%d-%d_%s",$login_year,$months{uc($login_month)},$login_day,$login_ms);
			my $single_login = $login_time . ' ' . join(" ",(split/\s+/)[0,1,2]);
			push @login_result, $single_login;
		}
		$lastlogin{'result'} = \@login_result if (@login_result);
  	}
  }
  ### %lastlogin
  $result{'lastlogin'} = \%lastlogin;
}



# sys_mods
if ($data_config{'sys_mods'}) {
  my %sys_mods = (
	'number'	=> 0,
  	'list'	=> '',
  );
  my $mod_file = '/proc/modules';
  if (-f $mod_file && -r $mod_file) {
  	if (open my $fh, "<", $mod_file) {
		my @sys_mods = ();
		while(<$fh>){
			push @sys_mods, (split/\s+/)[0];
		}
		$sys_mods{'number'} = scalar @sys_mods if (@sys_mods);
		$sys_mods{'list'} = \@sys_mods;
		close $fh if $fh;
  	}
  }
  ### %sys_mods
  $result{'sys_mods'} = \%sys_mods;
}



# sys_locks
if ($data_config{'sys_locks'}) {
  my $sys_locks = 0;
  my $lock_file = '/proc/locks';
  if (-f $lock_file && -r $lock_file) {
  	if (open my $fh, "<", $lock_file) {
		my @sys_locks = <$fh>;
		$sys_locks = scalar @sys_locks;
		close $fh if $fh;
  	}
  }
  ### $sys_locks
  $result{'sys_locks'} = $sys_locks ? $sys_locks : 0 ;
}



# disk_space
if ($data_config{'disk_space'}) {
  my @disk_space = ();
  my @check_fstype = ('ext2','ext3','ext4');	# only collect local filesystem, exclude nfs, gfs ...
  my ($mtab,$df) = ('/etc/mtab','/bin/df');
  if (-f $mtab && -r $mtab && -f $df && -x $df) {
	my @disks = ();
	if (open my $fh0, "<", $mtab ) {
		while (<$fh0>) {
			chomp; my ($dev,$fstype) = (split/\s+/)[0,2];
			if (defined $fstype && grep(/\A\Q$fstype\E\Z/i, @check_fstype)) {
				push @disks, $dev;
			}
		}
		close $fh0 if ($fh0);
		while(my $dev = shift @disks) {
			my %single_disk = (
				'dev'		=> $dev,
				'fstype'	=> '',
				'mount'		=> '',
				'msize'		=> '',
				'mused'		=> '',
				'mfree'		=> '',
				'isize'		=> '',
				'iused'		=> '',
				'ifree'		=> '',
			);
			open my $fh, "$df -lPTk $dev 2>&- | ";
			if ($fh) {
				while(<$fh>){
					if (m/\A\Q$dev\E\s+/i) {
						@single_disk{'fstype','mount','msize','mused','mfree'} = (split/\s+/)[1,6,2,3,4];
					}
				}
			} 
			open my $fh1, "$df -lPTi $dev 2>&- | ";
			if ($fh1) {
				while(<$fh1>){
					if (m/\A\Q$dev\E\s+/i) {
						@single_disk{'isize','iused','ifree'} = (split/\s+/)[2,3,4];
					}
				}
			}
			push @disk_space, \%single_disk;
		}
  	}
  }
  ### @disk_space
  $result{'disk_space'} = \@disk_space;
}



# cpu_usage
if ($data_config{'cpu_usage'}) {
  my %cpu_usage = (
  	'time'		=> 5,
  	'interval'	=> 1,
  	'user'		=> 0,
  	'sys'		=> 0,
  	'wait'		=> 0,
  	'idle'		=> 0,
	);
  my $vmstat = '/usr/bin/vmstat';
  if (-f $vmstat && -x $vmstat) {
  	open my $fh, "$vmstat $cpu_usage{'interval'} $cpu_usage{'time'} 2>&- | ";
  	if ($fh) {
		while(<$fh>){
			next unless m/\A\s*\d+/;
			$cpu_usage{'user'} += (split/\s+/)[-5];
			$cpu_usage{'sys'}  += (split/\s+/)[-4];
			$cpu_usage{'wait'} += (split/\s+/)[-2];
			$cpu_usage{'idle'} += (split/\s+/)[-3];
		}
  	}
  }
  $cpu_usage{'user'} = $cpu_usage{'user'}/$cpu_usage{'time'};
  $cpu_usage{'sys'} = $cpu_usage{'sys'}/$cpu_usage{'time'};
  $cpu_usage{'wait'} = $cpu_usage{'wait'}/$cpu_usage{'time'};
  $cpu_usage{'idle'} = $cpu_usage{'idle'}/$cpu_usage{'time'};
  ### %cpu_usage
  $result{'cpu_usage'} = \%cpu_usage;
}



##
##  system fixinfo
##

if ($data_config{'product_info'}) {
  my %product_info = (
  	'manufacturer'		=> '',
  	'productname'		=> '',
  	'productuuid'		=> '',
  	'serialnumber'		=> '',
  	'biosvendor'		=> '',
  	'biosversion'		=> '',
  	'biosreleasedate'	=> '',
  	'baseboardmanufacturer'	=> '',
  	'baseboardproductname'	=> '',
  	'baseboardversion'	=> '',
  	'baseboardserialnumber'	=> '',
  );
  my %mem_info = (
  	'memmaxcapacity'	=> '',		# Memory Maximum Capacity
  	'memmaxdevnum'		=> '',		# Memory Maxinum Plugin Interface
  	'memfreedevnum'		=> '',		# Memory Free Plugin Interface
  	'meminstallednum'	=> '',		# Memory Installed Number
  	'meminstalledsize'	=> '',		# Memory Installed Size (by each)
  	'memtype'		=> '',
  	'memspeed'		=> '',
  	'os_mem_total'		=> '',
  	'os_swap_total'		=> '',
  );
  my $dmidecode = '/usr/sbin/dmidecode';	# dmidecode >= 2.7, [OS >= rhel 5.1]
  if (-f $dmidecode && -x $dmidecode) {
  	%product_info = (
  		'manufacturer'		=> 'system-manufacturer',
  		'productname'		=> 'system-product-name',
  		'productuuid'		=> 'system-uuid',
  		'serialnumber'		=> 'system-serial-number',
  		'biosvendor'		=> 'bios-vendor',
  		'biosversion'		=> 'bios-version',
  		'biosreleasedate'	=> 'bios-release-date',
		'baseboardmanufacturer'	=> 'baseboard-manufacturer',
		'baseboardproductname'	=> 'baseboard-product-name',
		'baseboardversion'	=> 'baseboard-version',
		'baseboardserialnumber' => 'baseboard-serial-number',
  	);
  	foreach my $key (keys %product_info) {
    		open my $fh, "$dmidecode -s $product_info{$key} 2>&- |";
    		if ($fh) {
			while (<$fh>) {
				chomp; s/(\A\s+|\s+\Z)//g;
				next if m/\A\s*#/;
				s/\A\s*//; s/\s*\Z//g; $product_info{$key} = $_;
				last;
			}
    		}
  	}

  	open my $fh, "$dmidecode -t memory 2>&- |";
  	if ($fh) {
		my $memdev_start = 0;
		my @meminstalledsize = ();
		my (%memtype,%memspeed);
		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			if (m/\A\s*\Z/){
				$memdev_start = 0;
				next;
			}
			if (m/\A\s*Maximum\s+Capacity:/i) {
				$mem_info{'memmaxcapacity'} = &c2kb( (split /:\s+/)[1] );
				next;
			}
			if (m/\A\s*Memory Device/i) {
				$memdev_start = 1;
				$mem_info{'memmaxdevnum'}++;
				next;
			}
			if (m/\A\s*Size:/i) {
				(my $size = (split /:/)[1]) =~ s/\A\s*//g;
				$mem_info{'meminstallednum'}++;
				push @meminstalledsize, &c2kb($size);
				next;
			}
			if (m/\A\s*Type:/i && $memdev_start == 1) {
				(my $memtype = (split /:/)[1]) =~ s/\A\s*//g;
				$memtype{$memtype}++;
				next;
			}
			if (m/\A\s*Speed:/i && $memdev_start == 1) {
				(my $memspeed = (split /:/)[1] ) =~ s/\A\s*//g;
				$memspeed{$memspeed}++;
				next;
			}
		}
        	if ($mem_info{'memmaxdevnum'} ne '' && $mem_info{'meminstallednum'} ne ''){
                	$mem_info{'memfreedevnum'} = $mem_info{'memmaxdevnum'} - $mem_info{'meminstallednum'};
        	}
		$mem_info{'meminstalledsize'} = \@meminstalledsize;

		my (@memtype,@memspeed);
                for my $tmp_memtype (sort keys %memtype) {
                        my %single_memtype = (
                                'type'		=> $tmp_memtype,
                                'number'        => $memtype{$tmp_memtype},
                        );
                        push @memtype, \%single_memtype; 
                }
		$mem_info{'memtype'} = \@memtype;

                for my $tmp_memspeed (sort keys %memspeed) {
                        my %single_memspeed = (
                                'speed'		=> $tmp_memspeed,
                                'number'        => $memspeed{$tmp_memspeed},
                        );
                        push @memspeed, \%single_memspeed; 
                }
		$mem_info{'memspeed'} = \@memspeed;
  	}
  }
  my $mem_file = '/proc/meminfo';
  if (-f $mem_file && -r $mem_file) {
  	if(open my $fh, "<", $mem_file){
  		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			if (m/\AMemTotal:/i) {
				$mem_info{'os_mem_total'} = (split /\s+/)[1];
				next;
			}
			if (m/\ASwapTotal:/i) {
				$mem_info{'os_swap_total'} = (split /\s+/)[1];
				next;
			}
  		}
  		close $fh if ($fh);
  	}
  }
  ### %product_info
  ### %mem_info
  $result{'product_info'} = \%product_info;
  $result{'mem_info'} = \%mem_info;
}


if ($data_config{'cpu_info'}) {
  my %cpu_info = (
  	'vendor'	=> '',
  	'type'		=> '',
  	'physical'	=> '',
  	'logical'	=> '',
  	'speed'		=> '',
  );
  my $cpu_file = '/proc/cpuinfo';
  if (-f $cpu_file && -r $cpu_file) {
  	if (open my $fh, "<", $cpu_file) {
		my (%cpu_phyid, %cpu_speed, %cpu_vendor, %cpu_type);
        	while(<$fh>){
                	chomp; s/(\A\s+|\s+\Z)//g;
			if (m/\Aprocessor\s+/i) {
				$cpu_info{'logical'}++;
				next;
			}
			if (m/\Aphysical\s+id\s+/i) {
				$cpu_phyid{$_}++;
				next;
			}
			if (m/\Acpu\s+MHz\s+/i) {
				(my $speed = (split /:/)[1]) =~ s/\A\s*//g;
				$cpu_speed{$speed.'MHz'}++;
				next;
			}
			if (m/\Avendor_id\s+/i) {
				(my $vendor = (split /:/)[1]) =~ s/\A\s*//g;
				$cpu_vendor{$vendor}++;
				next;
			}
			if (m/\Amodel\s+name\s+/i) {
				(my $type = (split /:/)[1]) =~ s/\A\s*//g;
				$cpu_type{$type}++;
				next;
			}
	        }
		close $fh if ($fh);
		$cpu_info{'physical'} = scalar keys %cpu_phyid;
		$cpu_info{'physical'} = 1 if $cpu_info{'physical'} == 0;

		my (@cpu_speed,@cpu_vendor,@cpu_type);
		for my $tmp_speed (sort keys %cpu_speed) {
			my %single_cpu_speed = (
				'speed'		=> $tmp_speed,
				'number'	=> $cpu_speed{$tmp_speed},
			);
			push @cpu_speed, \%single_cpu_speed; 
		}
		$cpu_info{'speed'} = \@cpu_speed;

		for my $tmp_vendor (sort keys %cpu_vendor) {
			my %single_cpu_vendor = (
				'vendor'	=> $tmp_vendor,
				'number'	=> $cpu_vendor{$tmp_vendor},
			);
			push @cpu_vendor, \%single_cpu_vendor;
		}
		$cpu_info{'vendor'} = \@cpu_vendor;

		for my $tmp_type (sort keys %cpu_type) {
			my %single_cpu_type = (
				'type'		=> $tmp_type,
				'number'	=> $cpu_type{$tmp_type},
			);
			push @cpu_type, \%single_cpu_type;
		}
		$cpu_info{'type'} = \@cpu_type;
  	}
  }
  ### %cpu_info
  $result{'cpu_info'} = \%cpu_info;
}




if ($data_config{'input_dev'}) { 
  my @input_dev = ();
  my $input_devfile = '/proc/bus/input/devices';
  if (-f $input_devfile && -r $input_devfile) {
	  open my $fh, "<", $input_devfile;
	  if ($fh) {
		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			if (m/\AN: /i) {
				s/[\"\']//g;
				push @input_dev, (split/=/)[1];
			}
		}
		close $fh if ($fh);
	  }
  }
  ### @input_dev
  $result{'input_dev'} = \@input_dev;
}



if ($data_config{'os_info'}) {
  my %os_info = (
	  'os_distribute'	=> '',
	  'os_release'		=> '',
	  'os_manufacturer'	=> '',
	  'os_codename'		=> '',
	  'os_descript'		=> '',
	  'os_bitmode'		=> $OS_BITMODE,
	  'arch'		=> '',
	  'os'			=> '',
	  'kernel_name'		=> '',
	  'kernel_release' 	=> '',
	  'hostname'		=> '',
  );
  my $lsb_release = "/usr/bin/lsb_release";
  if (-f $lsb_release && -x $lsb_release) {
	  open my $fh, "$lsb_release -a 2>&1 |";
	  if ($fh) {
		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			next if m/\ALSB Version/i;
			my ($key,$value) = split /:/;
			$key = 'os_distribute' if $key =~ /\ADistributor ID/i;
			$key = 'os_release' if $key =~ /\ARelease/i;
			$key = 'os_codename' if $key =~ /\ACodename/i;
			$key = 'os_descript' if $key =~ /\ADescription/i;
			$value =~ s/\A\s*//g;
			$os_info{$key} = $value;
		}
		if ($os_info{'os_distribute'} =~ m/centos/i) {
			$os_info{'os_manufacturer'} = 'centos';
		} elsif ($os_info{'os_distribute'} =~ m/redhat/i) {
			$os_info{'os_manufacturer'} = 'redhat';
		} elsif ($os_info{'os_distribute'} =~ m/fedora/i) {
			$os_info{'os_manufacturer'} = 'fedora';
		} elsif ($os_info{'os_distribute'} =~ m/suse/i) {
			$os_info{'os_manufacturer'} = 'suse';
		}
	  }
  }
  my $uname = "/bin/uname";
  if (-f $uname && -x $uname) {
	  my %uname_info = (
	  	'arch'			=> '-m',
	  	'os'			=> '-o',
	  	'kernel_name'		=> '-s',
	  	'kernel_release' 	=> '-r',
	  	'hostname'		=> '-n',
	  );
	 foreach my $key (keys %uname_info){
	   open my $fh, "$uname $uname_info{$key} 2>&1 |";
	   if ($fh) {
		while(<$fh>){
			chomp; s/\A\s*//; s/\s*\Z//g; $os_info{$key} = $_;
			last;
		}
	   }
	 }
  }
  ### %os_info
  $result{'os_info'} = \%os_info;
}




if ($data_config{'sys_clock'}) {
  my %sys_clock = (
	  'timezone'		=> '',
	  'useutc'		=> '',
  );
  my $clockfile = '/etc/sysconfig/clock';
  if (-f $clockfile && -r $clockfile) {
	  if(open my $fh, "<", $clockfile){
		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			if (m/\AZONE=/) {
				s/"//g;
				$sys_clock{'timezone'} = (split/=/)[1];
				next;
			}
			if (m/\AUTC=/) {
				$sys_clock{'useutc'} = (split/=/)[1];
				next;
			}
		}
		close $fh;
	  }
  }
  ### %sys_clock
  $result{'sys_clock'} = \%sys_clock;
}




if ($data_config{'sys_lang'}) {
  my %sys_lang = (
	  'lang_default'	=> '',
	  'lang_supported'	=> '',
	  'font_default'	=> '',
  );
  my $i18nfile = '/etc/sysconfig/i18n';
  if (-f $i18nfile && -r $i18nfile) {
	  if(open my $fh, "<", $i18nfile){
		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			if (m/\ALANG=/){
				s/"//g;
				$sys_lang{'lang_default'} = (split/=/)[1];
				next;
			}
			if (m/\ASUPPORTED=/){
				s/"//g;
				$sys_lang{'lang_supported'} = (split/=/)[1];
				next;
			}
			if (m/\ASYSFONT=/){
				s/"//g;
				$sys_lang{'font_default'} = (split/=/)[1];
				next;
			}
		}
		close $fh;
	  }
  }
  ### %sys_lang
  $result{'sys_lang'} = \%sys_lang;
}




if ($data_config{'selinux'}) {
  my %selinux = (
	  'status'		=> '',
	  'type'		=> '',
  );
  my $selinuxfile = '/etc/selinux/config';
  if (-f $selinuxfile && -r $selinuxfile) {
	  if (open my $fh, "<", $selinuxfile) {
		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			next if /\A\s*#/;
			if (m/\A\s*SELINUX\b/) {
				$selinux{'status'} = (split/=/)[1];
				next;
			}
			if (m/\A\s*SELINUXTYPE\b/) {
				$selinux{'type'} = (split/=/)[1];
				next;
			}
		}
		close $fh;
	  }
  }
  ### %selinux
  $result{'selinux'} = \%selinux;
}




if ($data_config{'sysuser'}) {
  my @sysuser = ();
  my $userfile = '/etc/passwd';
  if (-f $userfile && -r $userfile) {
	  if(open my $fh, "<", $userfile){
		while(<$fh>){
			chomp; 
			next if m/\A\s*#/;
			s/(\A\s+|\s+\Z)//g;
			my ($name,$uid,$gid,$homedir,$shell) = (split /:/)[0,2,3,5,6];
			if (defined $shell && -e $shell && $shell =~ /sh\Z/) {
				my %sysuser = (
	  				'name'		=> $name,
	  				'uid'		=> $uid,
	  				'gid'		=> $gid,
	  				'homedir'	=> (-d $homedir) ? $homedir : "$homedir (Missing)",
	  				'shell'		=> $shell,
				);
				push @sysuser, \%sysuser;
			}
		}
		close $fh;
	  }
  }
  ### @sysuser
  $result{'sysuser'} = \@sysuser;
}



if ($data_config{'runlevel'}) {
  ### $OS_RUNLEVEL
  $result{'runlevel'} = $OS_RUNLEVEL;
}



if ($data_config{'startups'}) {
  my @startups = ();
  my $startdir = "/etc/rc$OS_RUNLEVEL.d/";
  if (-d $startdir && -r $startdir) {
	my @start_files = (glob "$startdir/S*");
  	foreach(@start_files){
		my $start_file = (split /\//)[-1];
		if(defined $start_file){
			$start_file =~ s/\AS\d+//;
			$start_file = 'rc.local' if $start_file eq 'local';
			push @startups, $start_file;
		}
  	}
  }
  ### @startups
  $result{'startups'} = \@startups;
}



if ($data_config{'dns'}) {
  my @dns = ();
  my $dnsfile = '/etc/resolv.conf';
  if (-f $dnsfile && -r $dnsfile) {
  	if(open my $fh, "<", $dnsfile){
		while(<$fh>){
			if(m/\A\s*nameserver\s+(.+)\s*\Z/){
				push @dns, $1;
			}
		}
		close $fh;
  	}
  }
  ### @dns
  $result{'dns'} = \@dns;
}




if ($data_config{'route'}) {
  my @route = ();
  my $route = '/sbin/route';
  if (-f $route && -x $route) {
	open my $fh, "$route -n 2>&- |"; 
   	if ($fh) {
		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			if(m/\A\s*\d/i){
				my %route_way;
				@route_way{'dest','gateway','genmask','flag','metric','ref','use','iface'} = split /\s+/;
				push @route, \%route_way;
			}
		}
		close $fh;
   	}
  }
  ### @route
  $result{'route'} = \@route;
}




if ($data_config{'arp'}) {
  my @arp = ();
  my $arpfile = '/proc/net/arp';
  if (-f $arpfile && -r $arpfile) {
	if (open my $fh, "<", $arpfile) {
		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			if(m/\A\s*\d/i){
				my %arp_addr;
				@arp_addr{'ip','mac'} = (split /\s+/)[0,3];
				push @arp, \%arp_addr;
			}
		}
		close $fh if $fh;
   	}
  }
  ### @arp
  $result{'arp'} = \@arp;
}



if ($data_config{'mount'}) {
  my @mount = ();
  my $mtabfile = '/etc/mtab';
  if (-f $mtabfile && -r $mtabfile) {
  	if (open my $fh, "<", $mtabfile) {
		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			my %mount_dev;
			@mount_dev{'dev','mount','fstype','args'} = (split /\s+/)[0,1,2,3];
			if ($mount_dev{'fstype'} =~ m/\b(ext2|ext3|ext4|nfs|gfs|gfs2)\b/i) {
				push @mount, \%mount_dev;
			}
		}
		close $fh if $fh;
  	}
  }
  ### @mount
  $result{'mount'} = \@mount;
}



# only for inner called
my %netcard;
my $lspci = '/sbin/lspci';
if (-f $lspci && -x $lspci) {
  open my $fh, "$lspci 2>&- |";
  if ($fh) {
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if (m/Ethernet controller:/i) {
			my $busid = (split /\s+/)[0];
			my $desc = (split /Ethernet controller:\s+/i)[1];
			$netcard{$busid} = $desc;
		}
	}
  }
}


if ($data_config{'inet_name'}) {
  my @inet_name = ();
  my $netfile = '/proc/net/dev';
  my $ethtool = '/sbin/ethtool';
  my $ifconfig = '/sbin/ifconfig';
  if (-f $netfile && -r $netfile) {
	  my @netfaces = ();
	  if(open FH1, "<", $netfile){
		while(<FH1>){
			chomp; s/(\A\s+|\s+\Z)//g;
			if(/\A\s*(\w+?):\s*(\d+)/i){
				next if ($1 eq 'lo' || $1 eq 'sit0' || $1 =~ m/range/i);
				push @netfaces, $1;
			}
		}
		close FH1;
	  }
	  foreach(@netfaces){
		chomp; s/(\A\s+|\s+\Z)//g;
		my $inet_name = $_;
		my %inet_info = (
			'name'			=> $inet_name,
			'speed'			=> '',
			'duplex'		=> '',
			'is_autoneg'		=> '',
			'is_linked'		=> '',
			'driver'		=> '',
			'driver_version'	=> '',
			'firmware_version'	=> '',
			'pci_busid'		=> '',
			'pci_description'	=> '',
			'encapsulation'		=> '',
			'mac_address'		=> '',
			'ipv4_address'		=> '',
			'ipv4_netmask'		=> '',
			'mtu'			=> '',
			'promisc_mode'		=> 'off',
		);
		if (-f $ethtool && -x $ethtool) {
			open my $fh, "$ethtool $inet_name 2>&1 | ";
			if ($fh) {
				while(<$fh>){
					chomp; s/(\A\s+|\s+\Z)//g;
					$inet_info{'duplex'} = (split/:\s+/)[1] if m/\A\s*Duplex:/;
					$inet_info{'is_autoneg'} = (split/:\s+/)[1] if m/\A\s*Auto-negotiation:/;
					$inet_info{'is_linked'} = (split/:\s+/)[1] if m/\A\s*Link detected:/;
					$inet_info{'speed'} = (split/:\s+/)[1] if m/\A\s*Speed:/;
					if ( $inet_info{'speed'} =~ m/\A(\d+)\s*Gb\/s\Z/i ) {
						$inet_info{'speed'} = $1 * 1024 . 'Mb/s';
					}
				}
			}
			open my $fh1, "$ethtool -i $inet_name 2>&1 | ";
			if ($fh1) {
				while(<$fh1>){
					chomp; s/(\A\s+|\s+\Z)//g;
					$inet_info{'driver'} = (split/:\s+/)[1] if m/\A\s*driver:/;
					$inet_info{'driver_version'} = (split/:\s+/)[1] if m/\A\s*version:/;
					$inet_info{'firmware_version'} = (split/:\s+/)[1] if m/\A\s*firmware-version:/;
					$inet_info{'firmware_version'} = '' if not defined($inet_info{'firmware_version'});
					$inet_info{'pci_busid'} = (split/:\s+/)[1] if m/\A\s*bus-info:/;
				}
				if (not defined ($inet_info{'pci_busid'})) {
					$inet_info{'pci_busid'} = '';
				} else {
					$inet_info{'pci_busid'} =~ s/\A(.+?)://;	# trim first xxxx:
					if (exists $netcard{$inet_info{'pci_busid'}}) {
						$inet_info{'pci_description'} = $netcard{$inet_info{'pci_busid'}};
					}
				}
			}
		}
		if (-f $ifconfig && -x $ifconfig) {
			open my $fh, "$ifconfig $inet_name 2>&1 | ";
			if ($fh) {
				while(<$fh>){
					chomp; s/(\A\s+|\s+\Z)//g;
					if(m/^$inet_name\s+Link encap:(\w+)\s+HWaddr ((?:[A-Fa-f0-9]{2}:){5}(?:[A-Fa-f0-9]{2}))\s*\Z/i){
						$inet_info{'encapsulation'} = $1;			
						$inet_info{'mac_address'} = $2;
						next;
					}
					if(m/\s*inet addr:((([0-9]|([1-9]\d)|(1\d\d)|(2([0-4]\d|5[0-5])))\.){3}([1-9]|([1-9]\d)|(1\d\d)|(2([0-4]\d|5[0-5]))))\s+(.*)Mask:(.+)\Z/){
						$inet_info{'ipv4_address'} = $1;
						$inet_info{'ipv4_netmask'} = $14;
						next;
					}
					if(m/\s+MTU:(\d+)\s+/i){
						$inet_info{'mtu'} = $1;
						next;
					}
				}
			}
		}
		my $flagfile = "/sys/class/net/$inet_name/flags";
		if (-f $flagfile && -r $flagfile) {
			open my $fh, "<", $flagfile;
			if ($fh) {
				chomp( my $int_flags = <$fh>);
				if(hex $int_flags & 0x100) {
					$inet_info{'promisc_mode'} = 'on';
				}
			}
		}
		push @inet_name, \%inet_info;
	  }
  }
  ### @inet_name
  $result{'inet_name'} = \@inet_name;
}



if ($data_config{'raid_info'}) {
  my @raid_info = ();
  my $megacli = '/opt/MegaRAID/MegaCli/MegaCli64';
  $megacli = '/opt/MegaRAID/MegaCli/MegaCli' if ($OS_BITMODE eq '32');
  if (-f $megacli && -x $megacli) {
	  my ($i,$raid_num) = (0,0);
	  open my $fh, "$megacli -adpCount -NoLog 2>&- | ";
	  if($fh){
		while(<$fh>){
			chomp; s/(\A\s+|\s+\Z)//g;
			if (/\A\s*Controller Count:\s*(\d+)/i){
				$raid_num = $1;
				last;
			}
		}
	  }
	  for($i=0;$i<$raid_num;$i++){
	  	my %raid_single = (
			'RAID_ID'			=> $i,
	  		'Product_Name'			=> '',
	  		'Serial_Number'			=> '',
			'BIOS_Version'			=> '',
			'RAID_BBU'			=> '',
			'RAID_Memory'			=> '',
			'RAID_Temp_Sensor'		=> '',
			'Current_Time'			=> '',
			'RAID_Supported'		=> '',
			'Supported_Drives'		=> '',
			'Virtual_Disk_Number'		=> '',
			'Virtual_Disk_Info'		=> '',
			'Physical_Disk_Number'		=> '',
			'Physical_Disks_Critical'	=> '',
			'Physical_Disks_Failed'		=> '',
			'Physical_Disk_Info'		=> '',
			'Memory_Correctable_Errors'	=> '',
			'Memory_Uncorrectable_Errors'	=> '',
			'Default_Strip_Size'		=> '',
			'Default_Write_Policy'		=> '',
			'Default_Read_Policy'		=> '',
			'Default_Cache_When_BBU_Bad'	=> '',
	  	);
		my %raid_temp_sensor = (	### init  %raid_temp_sensor
			'Present'	=> 0,
			'Temperature'	=> '',
		);
		open my $fh1, "$megacli -AdpAllInfo -a$i -NoLog 2>&- | ";
		if($fh1){
			while(<$fh1>){
				chomp; s/(\A\s+|\s+\Z)//g;
				if(/\A\s*Product Name\s*:\s*(.+)\s*\Z/i){
					$raid_single{'Product_Name'} = $1;
					next;
				}
				if(/\A\s*Serial No\s*:\s*(.+)\s*\Z/i){
					$raid_single{'Serial_Number'} = $1;
					next;
				}
				if(/\A\s*BIOS Version\s*:\s*(.+)\s*\Z/i){
					$raid_single{'BIOS_Version'} = $1;
					next;
				}
				if(/\A\s*BBU\s*:\s*Present\s*\Z/i){
					my %bbu_single = (
						'Present'			=> 1,
						'Voltage'			=> '',
						'Temperature'			=> '',
						'Charging_Status'		=> '',   # Charing, Discharing, None
						'Learn_Cycle_Status'		=> '',
						'Learn_Cycle_Active'		=> '',	 # Yes, No
						'Relative_State_of_Charge' 	=> '',
						'Battery_Replacement_Required'	=> '',   # Yes, No
						'Remaining_Capacity_Low'	=> '',   # Yes, No
						'Charger_Status'		=> '',
						'Auto_Learn_Mode'		=> '',
						'Auto_Learn_Period'		=> '',
						'Next_Learn_time'		=> '',
					);
					open my $fh2, "$megacli -AdpBbuCmd -a$i -NoLog 2>&- | ";
					if($fh2){
						while(<$fh2>){
							chomp; s/(\A\s+|\s+\Z)//g;
							if(/\A\s*Voltage:\s*(.+)\s*\Z/i){
								$bbu_single{'Voltage'} = $1;
								next;
							}
							if(/\A\s*Temperature:\s*(.+)\s*\Z/i){
								$bbu_single{'Temperature'} = $1;
								next;
							}
							if(/\A\s*Charging Status\s*:\s*(.+)\s*\Z/i){
								$bbu_single{'Charging_Status'} = $1;
								next;
							}
							if(/\A\s*Learn Cycle Status\s*:\s*(.+)\s*\Z/i){
								$bbu_single{'Learn_Cycle_Status'} = $1;
								next;
							}
							if(/\A\s*Learn Cycle Active\s*:\s*(.+)\s*\Z/i){
								$bbu_single{'Learn_Cycle_Active'} = $1;
								next;
							}
							if(/\A\s*Relative State of Charge:\s*(.+)\s*\Z/i){
								$bbu_single{'Relative_State_of_Charge'} = $1;
								next;
							}
							if(/\A\s*Battery Replacement required\s*:\s*(.+)\s*\Z/i){
								$bbu_single{'Battery_Replacement_Required'} = $1;
								next;
							}
							if(/\A\s*Remaining Capacity Low\s*:\s*(.+)\s*\Z/i){
								$bbu_single{'Remaining_Capacity_Low'} = $1;
								next;
							}
							if(/\A\s*Charger Status:\s*(.+)\s*\Z/i){
								$bbu_single{'Charger_Status'} = $1;
								next;
							}
							if(/\A\s*Auto-Learn Mode:\s*(.+)\s*\Z/i){
								$bbu_single{'Auto_Learn_Mode'} = $1;
								next;
							}
							if(/\A\s*Auto Learn Period:\s*(.+)\s*\Z/i){
								$bbu_single{'Auto_Learn_Period'} = $1;
								next;
							}
							if(/\A\s*Next Learn time:\s*(.+)\s*\Z/i){
								$bbu_single{'Next_Learn_time'} = $1;
								next;
							}
						}
					}
					$raid_single{'RAID_BBU'} = \%bbu_single;
					next;
				}
				if(/\A\s*Memory Size\s*:\s*(.+)\s*\Z/i){
					$raid_single{'RAID_Memory'} = &c2kb($1);
					next;
				}
				if(/\A\s*Temperature sensor for controller\s*:\s*Present\s*\Z/i){
					$raid_temp_sensor{'Present'} = 1;
					next;
				}
				if(/\A\s*Controller temperature\s*:\s*(.+)\s*\Z/i){
					$raid_temp_sensor{'Temperature'} = $1;
					next;
				}
				if(/\A\s*Current Time\s*:\s*(.+)\s*\Z/i){
					$raid_single{'Current_Time'} = $1;
					next;
				}
				if(/\A\s*RAID Level Supported\s*:\s*(.+)\s*\Z/i){
					my @raid_supported = split(/,\s+/,$1);
					$raid_single{'RAID_Supported'} = \@raid_supported;
					next;
				}
				if(/\A\s*Supported Drives\s*:\s*(.+)\s*\Z/i){
					my @drive_supported = split(/,\s+/,$1);
					$raid_single{'Supported_Drives'} = \@drive_supported;
					next;
				}
				if(/\A\s*Virtual Drives\s*:\s*(\d+)\s*\Z/i){
					$raid_single{'Virtual_Disk_Number'} = $1;
					if ($raid_single{'Virtual_Disk_Number'} > 0) {
						my @vd_array = ();
						for(my $v=0;$v<$raid_single{'Virtual_Disk_Number'};$v++){
							my %vd_single = (
								'vd_id'			=> 0,
								'raid_level'		=> '',
								'size'			=> '',
								'state'			=> '',
								'stripe_size'		=> '',
								'pdnum'			=> '',
								'depth'			=> '',
								'encryption'		=> '',
								'default_cache_policy'	=> '',
								'current_cache_policy'	=> '',
								'default_access_policy'	=> '',
								'current_access_policy'	=> '',
							);
							open my $fh3, "$megacli -LDInfo -L$v -a$i -NoLog 2>&- | ";
							if($fh3){
								while(<$fh3>){
									chomp; s/(\A\s+|\s+\Z)//g;
									if(/\A\s*Virtual Drive\s*:\s*(\d+)\s*/i){
										$vd_single{'vd_id'} = $1;
										next;
									}
									if(/\A\s*RAID Level\s*:\s*(.+)\s*\Z/i){
										$vd_single{'raid_level'} = $1;
										next;
									}	
									if(/\A\s*Size\s*:\s*(.+)\s*\Z/i){
										$vd_single{'size'} = &c2kb($1);
										next;
									}	
									if(/\A\s*State\s*:\s*(.+)\s*\Z/i){
										$vd_single{'state'} = $1;
										next;
									}	
									if(/\A\s*Strip Size\s*:\s*(.+)\s*\Z/i){
										$vd_single{'stripe_size'} = &c2kb($1);
										next;
									}	
									if(/\A\s*Number Of Drives\s*:\s*(\d+)\s*\Z/i){
										$vd_single{'pdnum'} = $1;
										next;
									}	
									if(/\A\s*Span Depth\s*:\s*(\d+)\s*\Z/i){
										$vd_single{'depth'} = $1;
										next;
									}	
									if(/\A\s*Encryption Type\s*:\s*(.+)\s*\Z/i){
										$vd_single{'encryption'} = $1;
										next;
									}	
									if(/\A\s*Default Cache Policy\s*:\s*(.+)\s*\Z/i){
										$vd_single{'default_cache_policy'} = $1;
										next;
									}	
									if(/\A\s*Current Cache Policy\s*:\s*(.+)\s*\Z/i){
										$vd_single{'current_cache_policy'} = $1;
										next;
									}	
									if(/\A\s*Default Access Policy\s*:\s*(.+)\s*\Z/i){
										$vd_single{'default_access_policy'} = $1;
										next;
									}	
									if(/\A\s*Current Access Policy\s*:\s*(.+)\s*\Z/i){
										$vd_single{'current_access_policy'} = $1;
										next;
									}	
								}
							}
							if ($vd_single{'raid_level'} =~ m/Primary-1, Secondary-0/i) {
								$vd_single{'raid_level'} = 'raid1';
							} elsif ($vd_single{'raid_level'} =~ m/Primary-0, Secondary-0/i) {
								$vd_single{'raid_level'} = 'raid0';
							} elsif ($vd_single{'raid_level'} =~ m/Primary-5, Secondary-0/i) {
								$vd_single{'raid_level'} = 'raid5';
							} elsif ($vd_single{'raid_level'} =~ m/Primary-1, Secondary-3/i) {
								$vd_single{'raid_level'} = 'raid10';
							}
							push @vd_array, \%vd_single;
						}
						$raid_single{'Virtual_Disk_Info'} = \@vd_array;
					}
					next;
				}
				if(/\A\s*Disks\s*:\s*(\d+)\s*\Z/i){
					$raid_single{'Physical_Disk_Number'} = $1;
					if ($raid_single{'Physical_Disk_Number'} > 0) {
						my @pd_array = ();
						my %pd_single = (
							'pd_id'			=> 'X',	# init
							'pd_type'		=> '',
							'position'		=> '',
							'raw_size'		=> '',
							'coerced_size'		=> '',
							'media_type'		=> '',
							'media_error'		=> '',
							'other_error'		=> '',
							'predictive_failure'	=> '',
							'firmware_state'	=> '',
							'inquiry_data'		=> '',
							'temperature'		=> '',
							'write_cache'		=> '',
						);
						my $pd_finish_flag = 0;
						open my $fh4, "$megacli -PDList -a$i -NoLog 2>&- | ";
						if($fh4){
							while(<$fh4>){
								chomp; s/(\A\s+|\s+\Z)//g;
								# if blank-line, check if single physical disk finished.
								if(/\A\s*\Z/i){	
									if($pd_single{'pd_id'} ne 'X' && $pd_finish_flag == 0){
										$pd_finish_flag = 1;
										my %tmp_pd_single = %pd_single;
										push @pd_array, \%tmp_pd_single;
									}else{
										$pd_finish_flag = 0;
										$pd_single{'pd_id'} = 'X';
									}
									next;
								}
								if(/\A\s*Device Id\s*:\s*(\d+)\s*\Z/i){
									$pd_single{'pd_id'} = $1;
									next;
								}	
								if(/\A\s*PD Type\s*:\s*(.+)\s*\Z/i){
									$pd_single{'pd_type'} = $1;
									next;
								}	
								if(/\A\s*Drive\'s postion\s*:\s*(.+)\s*\Z/i){
									$pd_single{'position'} = $1;
									next;
								}	
	                                                        if(/\A\s*Raw Size\s*:\s*([\d.]+\s+(\w)+)\s*/i){
	                                                                $pd_single{'raw_size'} = &c2kb($1);
	                                                                next;
	                                                        }
	                                                        if(/\A\s*Coerced Size\s*:\s*([\d.]+\s+(\w)+)\s*/i){
	                                                                $pd_single{'coerced_size'} = &c2kb($1);
	                                                                next;
	                                                        }
								if(/\A\s*Media Type\s*:\s*(.+)\s*\Z/i){
									$pd_single{'media_type'} = $1;
									next;
								}	
								if(/\A\s*Media Error Count\s*:\s*(.+)\s*\Z/i){
									$pd_single{'media_error'} = $1;
									next;
								}	
								if(/\A\s*Other Error Count\s*:\s*(.+)\s*\Z/i){
									$pd_single{'other_error'} = $1;
									next;
								}	
								if(/\A\s*Predictive Failure Count\s*:\s*(.+)\s*\Z/i){
									$pd_single{'predictive_failure'} = $1;
									next;
								}	
								if(/\A\s*Firmware state\s*:\s*(.+)\s*\Z/i){
									$pd_single{'firmware_state'} = $1;
									next;
								}	
								if(/\A\s*Inquiry Data\s*:\s*(.+?)\s*\Z/i){
									$pd_single{'inquiry_data'} = $1;
									next;
								}	
								if(/\A\s*Drive Temperature\s*:\s*(.+)\s*\Z/i){
									$pd_single{'temperature'} = $1;
									next;
								}	
								if(/\A\s*Drive\'s write cache\s*:\s*(.+)\s*\Z/i){
									$pd_single{'write_cache'} = $1;
									next;
								}	
							}
						}
						$raid_single{'Physical_Disk_Info'} = \@pd_array;
					}
					next;
				}
				if(/\A\s*Critical Disks\s*:\s*(\d+)\s*\Z/i){
					$raid_single{'Physical_Disks_Critical'} = $1;
					next;
				}
				if(/\A\s*Failed Disks\s*:\s*(\d+)\s*\Z/i){
					$raid_single{'Physical_Disks_Failed'} = $1;
					next;
				}
				if(/\A\s*Memory Correctable Errors\s*:\s*(\d+)\s*\Z/i){
					$raid_single{'Memory_Correctable_Errors'} = $1;
					next;
				}
				if(/\A\s*Memory Uncorrectable Errors\s*:\s*(\d+)\s*\Z/i){
					$raid_single{'Memory_Uncorrectable_Errors'} = $1;
					next;
				}
				if(/\A\s*Strip Size\s*:\s*(.+)\s*\Z/i){
					$raid_single{'Default_Strip_Size'} = &c2kb($1);
					next;
				}
				if(/\A\s*Write Policy\s*:\s*(.+)\s*\Z/i){
					$raid_single{'Default_Write_Policy'} = $1;
					next;
				}
				if(/\A\s*Read Policy\s*:\s*(.+)\s*\Z/i){
					$raid_single{'Default_Read_Policy'} = $1;
					next;
				}
				if(/\A\s*Cache When BBU Bad\s*:\s*(.+)\s*\Z/i){
					$raid_single{'Default_Cache_When_BBU_Bad'} = $1;
					next;
				}
			}
	  	}
		$raid_single{'RAID_Temp_Sensor'} = \%raid_temp_sensor;
	  	push @raid_info, \%raid_single;
	  }
  }
  ### @raid_info
  $result{'raid_info'} = \@raid_info;
}


### %result


#
#  END to COLLECT SYSTEM INFORMATION 
#

our $DiffInfo = undef;
if (my $OldInfo = &load_oldinfo($SaveFile)) {
	### load_oldinfo_succeed
	if (my $OldInfo_Decode = JSON->new->allow_nonref->utf8(1)->ascii(1)->decode($OldInfo)) {
		### decode_oldinfo_succeed
		my %OldInfo = %{$OldInfo_Decode};
		$DiffInfo = &genjson_diffinfo(\%OldInfo,\%result);
		$DiffInfo = "diff $DiffInfo";
	} else {
		### decode_oldinfo_failed
	}
} else {
	### load_oldinfo_failed
}
unless ($DiffInfo) {
	### use_new_result_as_diffinfo
	# if not defined, maybe load_oldinfo failed, or decode oldinfo failed
	# on these case, return encoded new %result as diffinfo.
	$DiffInfo = JSON->new->allow_nonref->utf8(1)->ascii(1)->canonical(1)->encode(\%result);
	$DiffInfo = "full $DiffInfo";
}
### $DiffInfo



### output and exit
print $DiffInfo;
if ($result = JSON->new->allow_nonref->utf8(1)->ascii(1)->canonical(1)->encode(\%result)) {
	if (&write_newinfo($SaveFile, $result)) {
		#printf "+OK save new result into file succeed\n";
		exit $state_succ;
	} else {
		#printf "-ERR save new result into file failed\n";
		exit $state_warn;
	}
} else {
	#printf "-ERR encode new result as json failed\n";
	exit $state_warn;
}
