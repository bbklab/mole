#!/usr/bin/env perl

our $basedir = '/usr/local/esop/agent/mole';
our $mole = "$basedir/sbin/mole";

BEGIN {
  my $basedir = '/usr/local/esop/agent/mole';
  my $pllib_dir = "$basedir/opt/plmods";
  my $esoplib_dir = "$basedir/opt/EsopLib";
  my @incs = (    # set additional path
  	# rhel5 32bit
  	$pllib_dir.'/lib/perl5/',
  	$pllib_dir.'/lib/perl5/5.8.8/',
  	$pllib_dir.'/lib/perl5/site_perl/',
  	$pllib_dir.'/lib/perl5/site_perl/5.8.8/',
	$pllib_dir.'/lib/perl5/site_perl/5.8.8/i386-linux-thread-multi/',
  	# rhel5 64bit
  	$pllib_dir.'/lib64/perl5/',
  	$pllib_dir.'/lib64/perl5/5.8.8/',
  	$pllib_dir.'/lib64/perl5/site_perl/',
  	$pllib_dir.'/lib64/perl5/site_perl/5.8.8/',
	$pllib_dir.'/lib64/perl5/site_perl/5.8.8/x86_64-linux-thread-multi/',
  	# rhel6 32bit
  	$pllib_dir.'/lib/perl5/',
  	$pllib_dir.'/share/perl5/',
  	# rhel6 64bit
  	$pllib_dir.'/lib64/perl5/',
  	$pllib_dir.'/share/perl5/',
	# esop lib
	$esoplib_dir.'/lib/',
  );

  push @INC, @incs;
};

use strict;
use warnings;
use utf8;
use Encode;
use Getopt::Std;
use IO::Socket;
use IO::Socket::INET;
use Benchmark ':hireswallclock';
use JSON;
use Time::HiRes;
use POSIX qw(strftime);
use EsopLib;
# use Smart::Comments;

binmode(STDIN, ":encoding(utf8)");
binmode(STDOUT, ":encoding(utf8)");

$| = 1;

# declar global vars
our $filename = (split /\//, __FILE__)[-1];
our %opts = ();
our ($type,$plugin,$jobid,$output,$houtput,$eml,$sms,$snapfile,$repeat,$sysinfo,$debug) = ();
our $logfrom;
our (%json_data,$json_result) = ('','');

our $postlog = "$basedir/log/postlog.log";
our $statfile = "$basedir/tmp/.posthost.status";

our $parter_id = read_mole_config('global','parter_id');
our $hid = read_mole_config('global','id');
our $hname = read_mole_config('global','name');
if ($hid && $hname) {
	$hname = $hid . '__' . $hname;
}

# install __WARN__/__DIE__ handler
$SIG{__DIE__} = sub {
	&log("CRIT: caught event die: [@_]");
	die @_;
};
$SIG{__WARN__} = sub {
	&log("CRIT: caught event warn: [@_]");
	warn @_;
};

# check mole
unless (-f $mole && -x $mole) {
  printf "$mole not prepared.\n";
  exit 1;
} 


# read args from cli
getopts('t:p:j:o:h:e:s:f:r:i:d',\%opts);
($type,$plugin,$jobid,$output,$houtput,$eml,$sms,$snapfile,$repeat,$sysinfo,$debug) = @opts{'t','p','j','o','h','e','s','f','r','i','d'};

# important to check utf8 flag on/off, or lead to json encode problems
foreach my $chinese ($output,$houtput,$eml,$sms){
	unless (Encode::is_utf8($chinese)){
    		Encode::_utf8_on($chinese);
  	}
}

# set initial logfrom first
$logfrom = 'POSTLOG.INITFROM';

# check arg [type] first
unless (defined $type && $type ne '') {
	&log("CRIT: $logfrom type required. exit");
  	print "type required.\n";
  	&help;
  	exit 1;
}

# check arg [jobid] secondly
unless (defined $jobid && $jobid ne '') {
	&log("CRIT: $logfrom jobid required. exit");
	print "jobid required\n";
	&help;
	exit 1;
}

# reset [logfrom]
if ($type eq 'post') {
  	unless (defined $plugin && defined $output){
        	&log("CRIT: $logfrom plugin and plugin_output required on type=post. exit");
        	print "plugin and plugin_output required on type=post\n";
        	&help;
        	exit 1;
  	}

  	unless (defined $houtput && $houtput ne ''){ 
        	$houtput = 'Nothing to do';
        	&log("INFO: $logfrom houtput empty, reset houtput=[$houtput]");
  	}

	# reset logfrom
        $logfrom = "$type $plugin $jobid";

} elsif ($type eq 'sysinfo') {
  	unless (defined $sysinfo && $sysinfo ne '') {
		&log("CRIT: $logfrom sysinfo required on type=sysinfo . exit");
		print "sysinfo required on type=sysinfo\n";
		&help;
		exit 1;
  	}

	# reset logfrom
	$logfrom = "$type AGENT.SYSINFO $jobid";

} elsif ($type eq 'plugin') {
	# reset logfrom
  	$logfrom = "$type AGENT.PLUGIN $jobid";

} elsif ($type eq 'config') {
	# reset logfrom
  	$logfrom = "$type AGENT.CONFIG $jobid";

} elsif ($type eq 'heartbeat') {
	# reset logfrom
  	$logfrom = "$type AGENT.HEARTBEAT $jobid";

} else {
	&log("CRIT: $logfrom type $type invalid. exit");
  	print "type $type invalid.\n";
  	&help;
  	exit 1;
}

# log start
&log("INFO: $logfrom script postlog start");

# check global {parter_id}, {hid}, {hname}
if (!$parter_id || $parter_id eq '') {
	&log("CRIT: $logfrom parter_id is empty, script postlog exit.");
	exit 3;
}
if (!$hid || $hid eq '') {
	&log("CRIT: $logfrom hid is empty, script postlog exit.");
	exit 3;
}
if (!$hname || $hname eq '') {
	&log("CRIT: $logfrom hname is empty, script postlog exit.");
	exit 3;
}

# set debug flag
if(!defined $debug || $debug eq ''){
	$debug = (read_mole_config('postlog','post_debug') eq 'yes') ? 1 : 0;
  	&log("INFO: $logfrom set debug=[$debug] from config file.");
} else {
  	&log("INFO: $logfrom set debug=[$debug] from CLI argument.");
}


# check post host status
if (-f $statfile && -s $statfile){
  	if(open FH, "<", $statfile) {
		while(<FH>){
			my @array_status = split /\s+/;
			if (@array_status) {
  				my $conn_status = shift @array_status;
  				my $conn_details = "@array_status";
  				if ($conn_status ne '0') {
					&log("CRIT: $logfrom post host seems down, $conn_details, exit");
  					exit 2;
  				} else {
					&log("INFO: $logfrom post host seems online, continue.");
  				}
			}
			last;
		}
		close FH;
  	} else {
		&log("INFO: $logfrom post host status file open failed, ignore and continue.");
	}
} else {
  	&log("INFO: $logfrom post host status file not exist or empty, continue.");
}


# generate json data by {action_type}: [post|plugin|config|heartbeat]
if ($type eq 'post') {
	%json_data = &genjson_post($plugin,$jobid,$output,$houtput,$eml,$sms,$snapfile,$repeat);
} elsif ($type eq 'plugin') {
  	%json_data = &genjson_plugin;
} elsif ($type eq 'config') {
  	%json_data = &genjson_config;
} elsif ($type eq 'heartbeat') {
  	%json_data = &genjson_heartbeat($jobid);
} elsif ($type eq 'sysinfo') {
  	%json_data = &genjson_sysinfo($jobid,$sysinfo);
}

$json_result = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%json_data);
$json_result =~ s/[\r\n]//g;

our $post_length = 0;
unless ($json_result) {
  	&log("CRIT: $logfrom json result empty, exit");
  	exit 1;
}
$post_length = length($json_result);
&log("INFO: $logfrom json data result [$json_result]") if $debug;
&log("INFO: $logfrom json data length $post_length");
### %json_data
### $json_result


# set post address
our %post_server = (
  	'post_server'		=> '',
  	'post_server_port'	=> '',
  	'post_port_type'	=> '',
	'post_timeout'		=> '',
  	'post_max_length'	=> '',
  	'encrypt_prikey'	=> '',
  	'gzip_minlen'		=> '',
);
foreach my $key (keys %post_server) {
	$post_server{$key} = read_mole_config('postlog',$key);
}

# check post_server
unless (defined $post_server{'post_server'} && $post_server{'post_server'} ne '') {
	&log("CRIT: $logfrom post server address not defined. exit");
  	exit 1;
}

# check post_max_length
unless (defined $post_server{'post_max_length'} && $post_server{'post_max_length'} ne '') {
  	$post_server{'post_max_length'} = 50000;
} elsif ($post_server{'post_max_length'} =~ /\D/) {
  	$post_server{'post_max_length'} = 50000;
}
unless ($post_length <= $post_server{'post_max_length'}) {
  	&log("CRIT: $logfrom json length exceed, $post_length > $post_server{'post_max_length'}, exit");
  	exit 1;
}

# check post_server_port
unless (defined $post_server{'post_server_port'} && $post_server{'post_server_port'} ne '') {
  	$post_server{'post_server_port'} = 8548;
} elsif ($post_server{'post_server_port'} =~ /\D/) {
  	$post_server{'post_server_port'} = 8548;
}

# check post_port_type
unless (defined $post_server{'post_port_type'} && $post_server{'post_port_type'} ne '') {
  	$post_server{'post_port_type'} = 'tcp';
} elsif ($post_server{'post_port_type'} ne 'tcp' && $post_server{'post_port_type'} ne 'udp') {
  	$post_server{'post_port_type'} = 'tcp';
}

# check post_timeout
unless (defined $post_server{'post_timeout'} && $post_server{'post_timeout'} ne '') {
  	$post_server{'post_timeout'} = 10;
} elsif ($post_server{'post_timeout'} =~ /\D/) {
  	$post_server{'post_timeout'} = 10;
}

# check encrypt_prikey
unless (defined $post_server{'encrypt_prikey'} && $post_server{'encrypt_prikey'} ne '') {
  	$post_server{'encrypt_prikey'} = '1234567812345678';
} elsif (length $post_server{'encrypt_prikey'} ne '16') {
  	$post_server{'encrypt_prikey'} = '1234567812345678';
}

# check gzip_minlen
unless (defined $post_server{'gzip_minlen'} && $post_server{'gzip_minlen'} ne '') {
  	$post_server{'gzip_minlen'} = 100;
} elsif ($post_server{'gzip_minlen'} =~ /\D/) {
  	$post_server{'gzip_minlen'} = 100;
}

# encode data
my ($encode_data, $encode_error) = &encode_mole_data(
	$json_result, $post_server{'encrypt_prikey'}, chr(0) x 16, $post_server{'gzip_minlen'});
unless ($encode_data) {
	&log ("CRIT: $logfrom encode data error: [$encode_error]");
	exit 2;
}
&log ("INFO: $logfrom encode data succeed, length " . length $encode_data);

# connect post host
my $post_timeout = $post_server{'post_timeout'};
my $sock;
eval {
	# install ALRM handler
	local $SIG{'ALRM'} = sub { die 'Post Timed Out'; };
	alarm ($post_timeout);

	# connect
	$sock=IO::Socket::INET->new(
  		'PeerAddr' =>     $post_server{'post_server'},
  		'PeerPort' =>     $post_server{'post_server_port'},
  		'Proto'    =>     $post_server{'post_port_type'},
	);
	
	unless (defined $sock) {
		my $response = '';
		( $response = $@ ) =~ s/[\r\n]//g if ($@);
  		&log ("CRIT: $logfrom connect $post_server{'post_port_type'}://$post_server{'post_server'}:$post_server{'post_server_port'} error: [$response]");
  		exit 2;
	}
	&log ("INFO: $logfrom connect $post_server{'post_port_type'}://$post_server{'post_server'}:$post_server{'post_server_port'} succeed");

	# *IMPORTANT*  turn on autoflush
	$sock->autoflush(1);

	# read welcome banner
	my $sock_response = <$sock>;
	unless (defined $sock_response) {
		&log ("CRIT: $logfrom connect to socket didn't return welcome banner.");
		die 'Banner Empty';
	}
	chomp $sock_response;
	$sock_response =~ s/[\r\n]//g;
	unless ($sock_response =~ /\A\+OK/i) {
		&log ("CRIT: $logfrom read proxy welcome banner [$sock_response]");
		die 'Banner Error';
	}
	&log ("INFO: $logfrom read proxy welcome banner [$sock_response]");
	
	my $rv;

	# send HEAD
	my $header = "HEAD $type,$hid,$jobid";
	my $header_length = length $header;

	$rv = $sock->send( "$header\r\n", 0 );
	unless (defined $rv) {
		&log ("CRIT: $logfrom send HEAD to socket failed.");
		die 'HEAD Send Failed';
	}
	$rv -= 2;
	unless ( $rv eq $header_length) {
		&log ("CRIT: $logfrom send half HEAD to socket.");
		die 'HEAD Send Half';
	}

	$sock_response = <$sock>;
	unless (defined $sock_response) {
		&log ("CRIT: $logfrom send HEAD to socket return nothing.");
		die 'HEAD Return Nothing';
	}
	chomp $sock_response;
	$sock_response =~ s/[\r\n]//g;
	unless ($sock_response =~ /\A\+OK/i) {
		&log ("CRIT: $logfrom send HEAD to socket return [$sock_response]");
		die 'HEAD Return Error';
	}
	&log ("INFO: $logfrom send HEAD ($rv) to socket return [$sock_response]");

	# send DATA
	my $data_length = length $encode_data;

	$rv = $sock->send( "$encode_data\r\n", 0 );

	unless (defined $rv) {
		&log ("CRIT: $logfrom send DATA to socket failed.");
		die 'DATA Send Failed';
	}
	$rv -= 2;
	unless ( $rv eq $data_length) {
		&log ("CRIT: $logfrom send half DATA to socket.");
		die 'DATA Send Half';
	}

	$sock_response = <$sock>;
	unless (defined $sock_response) {
		&log ("CRIT: $logfrom send DATA to socket return nothing.");
		die 'DATA Return Nothing';
	}
	chomp $sock_response;
	$sock_response =~ s/[\r\n]//g;
	unless ($sock_response =~ /\A\+OK/i) {
		&log ("CRIT: $logfrom send DATA to socket return [$sock_response]");
		die 'DATA Return Error';
	}
	&log ("INFO: $logfrom send DATA ($rv) to socket return [$sock_response]");

	alarm(0);
};
alarm(0);
if ($@) {
	if ($@ =~ m/Post Timed Out/) {
		&log ("CRIT: $logfrom script postlog timeout.\n\n");
		exit (10);
	} else {
		&log ("CRIT: $logfrom script postlog finish with error: [$@]\n\n");
		exit (9);
	}
} else {
	&log ("INFO: $logfrom script postlog finished.\n\n");
	exit (0);
}



#
# SUB DEF
#

sub help(){
print <<HELP;

Usage: $filename -t {type} -j {jobid} -p {plugin} -o {plugin_output} -h {handler_output} -e {eml} -s {sms} -f {snapfile} -r {repeat} -i {sysinfo} -d

type ~  post,  plugin,  config,  heartbeat, sysinfo

HELP
}

sub log {
  my $message = shift;
  my $time = time;
  my $localtime = strftime("%Y-%m-%d_%H:%M:%S", localtime time); 
  if(open my $fhlog, ">>", $postlog) {
  	print $fhlog "$time $localtime $message\n";
  	close $fhlog if $fhlog;
  }else {
	return;
  }
}

sub parted_output {
  my $part = shift;
  my $content = shift;
  exit(1) if (!$part || $part =~ /\D/);
  exit(1) if ($part > 6 || $part < 1); 
  exit(1) if (!defined $content);
  $content =~ m/{\s*(\w+)\s*}\s*:\s*{\s*(\w+)\s*}\s*:\s*{\s*(([^\|]+)(\|([^\|]+))?(\|([^\|]+))?)\s*}/i;
  my $result = ''; 
  if($1 && $part eq '1') { $result = $1; };
  if($2 && $part eq '2') { $result = $2; };
  if($3 && $part eq '3') { $result = $3; };
  if($4 && $part eq '4') { $result = $4; };
  if($6 && $part eq '5') { $result = $6; };
  if($8 && $part eq '6') { $result = $8; };
  $result =~ s/\A\s+//g if ($result);   # trim head \s
  return ($result);
}

sub filter_html {
        my $content = shift || return;
        ### before_filter: $content
        $content =~ s/href\s*=\s*.+?script\s*://gi;
        $content =~ s/src\s*=\s*.+?script\s*://gi;
        $content =~ s/src\s*=\s*.+?\.(js|vbs|asp|aspx|php|php4|php5|jsp)//gi;
        $content =~ s/<script.+<\/script([^>])*>//gi;
        $content =~ s/<iframe.+<\/iframe([^>])*>//gi;
        $content =~ s/<frameset.+<\/frameset([^>])*>//gi;
        $content =~ s/on(blur|c(hange|lick)|dblclick|focus|keypress)//gi;
        $content =~ s/on((key|mouse)(down|up)|(un)?load|mouse(move|o(ut|ver))|reset|s(elect|ubmit))//gi;
        ### after_filter: $content
	return $content;
}

sub hrformat_policy {
	my $policy = shift || return;
	my $part = shift || return;
	unless (defined $part && $part ne '') {
		return;
	}
	## input_policy: $policy
	## wanted_part: $part

	my $output;

	if ($part eq 'range') {
		open my $fh_tmp, qq($mole ifunc get_policy_analysize " \\"$policy\\" range hrformat" 2>&- |);
		if ($fh_tmp) {
			while(<$fh_tmp>){
				chomp; $output = $_;
				last;
			}
			close $fh_tmp if ($fh_tmp);
		}
	} elsif ($part eq 'rtime') {
		open my $fh_tmp0, qq($mole ifunc get_policy_analysize " \\"$policy\\" rtime" 2>&- |);
		if ($fh_tmp0) {
			while(<$fh_tmp0>){
				chomp; $output = "$_";
				last;
			}
			close $fh_tmp0 if ($fh_tmp0);
		}
	}

	## output_policy: $output
	return $output;
}

sub genjson_post {
  my ($plugin,$jobid,$output,$houtput,$eml,$sms,$snapfile,$repeat) = @_;

  $output = &filter_html($output);
  $houtput = &filter_html($houtput);

  my %result = (
	'type'		=> 'post',
	'parter_id'	=> $parter_id,
	'hid'		=> $hid,
	'hname'		=> $hname,
	'pname'		=> $plugin,
	'job'		=> '',
	'data'		=> '',
  );
  &log("DEBUG: $logfrom set type=[post]") if $debug;
  &log("DEBUG: $logfrom set parter_id=[$parter_id]") if $debug;
  &log("DEBUG: $logfrom set hid=[$hid]") if $debug;
  &log("DEBUG: $logfrom set hname=[$hname]") if $debug;

  # set job
  my @raw_job = ($jobid,time());
  $result{'job'} = \@raw_job;
  &log("DEBUG: $logfrom set job=[[@raw_job]]") if $debug;

  # initial raw data
  my %raw_data = (
	'res'			=> '0',
	'act'			=> '',
	'snap'			=> '',
	'level'			=> '',
	'repeat'		=> $repeat,
	'ret'			=> '',
	'title'			=> '',
	'summary'		=> '',
	'detail'		=> '',
	'auto'			=> '',
	'extra'			=> '',
  );

  # set data-> {res / act}
  my ($mailflag,$smsflag,$mail_banreason,$sms_banreason) = (0,0,'','');
  my @arrsucceml = ();
  my @arrfaileml = ();
  my @arrsuccsms = ();
  my @arrfailsms = ();
  if (defined $eml && $eml ne '') {
	&log("DEBUG: $logfrom receive args eml=[$eml]") if $debug;
	my $s_mail = (split(/\s+###/,$eml))[0];		# yes,no,banned	=> enabled: 1,0,2
	if (defined $s_mail && $s_mail ne '') {
		$s_mail =~ s/\A\s+//;
		if ($s_mail eq 'banned') {
			$mailflag = 2;
			$mail_banreason = (split(/\s+###/,$eml))[1];
		} else {
			$mailflag = ($s_mail eq 'yes') ? 1 : 0;
			my ($succeml,$faileml) = (split(/\s+###/,$eml))[1,2];
			$succeml =~ s/\A\s+//; $faileml =~ s/\A\s+//;
  			if (defined $faileml && $faileml ne ''){
				$raw_data{'res'} = 1;
  			}
  			@arrsucceml = split(/\s+/,$succeml) if ($succeml);
  			@arrfaileml = split(/\s+/,$faileml) if ($faileml);
		}
	}
  }
  if (defined $sms && $sms ne '') {
	&log("DEBUG: $logfrom receive args sms=[$sms]") if $debug;
	my $s_sms = (split(/\s+###/,$sms))[0];
	if (defined $s_sms && $s_sms ne '') {
		$s_sms =~ s/\A\s+//;
		if ($s_sms eq 'banned') {
			$smsflag = 2;
			$sms_banreason = (split(/\s+###/,$sms))[1];
		} else {
			$smsflag = ($s_sms eq 'yes') ? 1 : 0;
  			my ($succsms,$failsms) = (split(/\s+###/,$sms))[1,2];
  			$succsms =~ s/\A\s+//; $failsms =~ s/\A\s+//;
  			if (defined $failsms && $failsms ne ''){
				$raw_data{'res'} = 1;
  			}
  			@arrsuccsms = split(/\s+/,$succsms) if ($succsms);
  			@arrfailsms = split(/\s+/,$failsms) if ($failsms);
		}
	}
  }
  my %raw_eml = (
	'enabled'	=> $mailflag,
	'succ'		=> \@arrsucceml,
	'fail'		=> \@arrfaileml,
	'reason'	=> $mail_banreason,
  );
  my %raw_sms = (
	'enabled'	=> $smsflag,
	'succ'		=> \@arrsuccsms,
	'fail'		=> \@arrfailsms,
	'reason'	=> $sms_banreason,
  );
  my %raw_act = (
	'mail'		=> \%raw_eml,
	'sms'		=> \%raw_sms,
  );
  my $json_act = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_act);
  $raw_data{'act'} = $json_act;
  &log("DEBUG: $logfrom set data.res=[$raw_data{'res'}]") if $debug;
  &log("DEBUG: $logfrom set data.act=[$raw_data{'act'}]") if $debug;
  
  # set data->snap
  my ($snapflag,$snappath) = (0,'');
  if (defined $snapfile && $snapfile ne '') {
  	chomp $snapfile;
	&log("DEBUG: $logfrom receive args snapfile=[$snapfile]") if $debug;
	my ($s_snap,$path) = split(/\s+###/,$snapfile);
	$s_snap =~ s/\A\s+//; $path =~ s/\A\s+//;
	$snapflag = (defined $s_snap && $s_snap eq 'yes') ? 1 : 0;
	$snappath = $path if ($path);
  }
  my %raw_snap = (
	'enabled'	=> $snapflag,
	'path'		=> $snappath,
  );
  my $json_snap = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_snap);
  $raw_data{'snap'} = $json_snap;
  &log("DEBUG: $logfrom set data.snap=[$raw_data{'snap'}]") if $debug;

  # set data->level
  my $level = &parted_output(1,$output);
  if (defined $level && $level ne '') {
  	$raw_data{'level'} = $level;
  }
  &log("DEBUG: $logfrom set data.level=[$raw_data{'level'}]") if $debug;

  # set data->ret
  my $ret = &parted_output(2,$output);
  if (defined $ret && $ret ne '') {
	if ($ret eq 'str' || $ret eq 'file') {
  		$raw_data{'ret'} = $ret;
	} else {
		&log("CRIT: $logfrom data.level must be str or file. RETURN") if $debug;
		$result{'data'} = \%raw_data;
		return %result;
	}
  } else {
	&log("CRIT: $logfrom data.level not defined. RETURN") if $debug;
	$result{'data'} = \%raw_data;
	return %result;
  }
  &log("DEBUG: $logfrom set data.ret=[$raw_data{'ret'}]") if $debug;

  # set data-> {title/ summary/ detail}
  if ($ret eq 'str') {
	my $title   = &parted_output(4,$output);
	if (defined $title && $title ne '') {
		$raw_data{'title'} = $title;
		&log("DEBUG: $logfrom set data.title=[$raw_data{'title'}]") if $debug;
	}

	my $summary = &parted_output(5,$output);
	if (defined $summary && $summary ne '') {
		$raw_data{'summary'} = $summary;
		&log("DEBUG: $logfrom set data.summary=[$raw_data{'summary'}]") if $debug;
	}

	my $detail  = &parted_output(6,$output);
	my @json_detail;
	if (defined $detail && $detail ne '') {
		my @lines = split(/###/, $detail);
		for (@lines) {
			my ($color,$content) = ('','');
			# Notice: must be the whole-line matches  <font color=(\w+)>content</font>
			if (m/\A\s*(<\s*font\s+color=(\w+)\s*>)\s*(.+?)\s*(<\s*\/font\s*>)\s*\Z/) {
				($color,$content) = ($2,$3);
			} else {
				$content = $_;
			}
			if (defined $content && $content ne '') {
				$content =~ s/[\r\n]//g;
				$content =~ s/&nbsp;/ /g;
				$content =~ s/(\A\s+|\s+\Z)//g;
			}
			my %line = (
				'color' 	=> $color,
				'title'		=> '',
				'val'		=> $content,
			);
			push @json_detail, \%line;
		}
		my $json_detail = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\@json_detail);
		$raw_data{'detail'} = $json_detail;
		&log("DEBUG: $logfrom set data.detail=[$raw_data{'detail'}]") if $debug;
	}
  }

  if ($ret eq 'file') {
	my $detail = &parted_output(3,$output);
	my @json_detail;
	if (defined $detail && $detail ne '') {
		my @files = split(/###/, $detail);
		for (@files) {
			my %file = (
				'color'		=> '',
				'title'		=> '',
				'val'		=> $_,
			);
			push @json_detail, \%file;
		}
		my $json_detail = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\@json_detail);
		$raw_data{'detail'} = $json_detail;
		&log("DEBUG: $logfrom set data.detail=[$raw_data{'detail'}]") if $debug;
	}
  }

  # set data->auto 
  my %raw_auto = (
	'enabled'	=> 0,
	'result'	=> '',
  );
  if (defined $houtput && $houtput ne '') {
	my @lines = split(/###/, $houtput);
	if (defined $lines[0] && $lines[0] =~ m/\A\s*disabled\s*\Z/i) {
		$raw_auto{'enabled'} = 0;
	} else {
		$raw_auto{'enabled'} = 1;
		my @json_auto_result = ();
		for (@lines) {
			my %line = (
				'color'		=> '',
				'title'		=> '',
				'val'		=> $_,
			);
			push @json_auto_result, \%line;
		}
		my $json_auto_result = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\@json_auto_result);
		$raw_auto{'result'} = $json_auto_result;
	}
  }
  my $json_auto = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_auto);
  $raw_data{'auto'} = $json_auto;
  &log("DEBUG: $logfrom set data.auto=[$raw_data{'auto'}]") if $debug;

  # set data->extra
  $raw_data{'extra'} = '';
  &log("DEBUG: $logfrom set data.extra=[$raw_data{'extra'}]") if $debug;

  # set data
  $result{'data'} = \%raw_data;

  return %result;
}

sub genjson_plugin() {
  my %result = (
	'type'		=> 'plugin',
	'parter_id'	=> $parter_id,
	'hid'		=> $hid,
	'hname'		=> $hname,
	'data'		=> '',
  );
  &log("INFO: $logfrom set type=[plugin]") if $debug;
  &log("INFO: $logfrom set parter_id=[$parter_id]") if $debug;
  &log("INFO: $logfrom set hid=[$hid]") if $debug;
  &log("INFO: $logfrom set hname=[$hname]") if $debug;

  my @raw_data = ();
  my @array_plugins = ();
  open my $fh, "$mole ln 2>&- | ";
  if($fh){
	while(<$fh>){
		chomp;
		next if m/\A\s*\Z/;
		push @array_plugins, $_;
	}
  }

  unless(@array_plugins) {
	&log("INFO: $logfrom plugin list is empty") if $debug;
  	$result{'data'} = \@raw_data;
  	return %result;
  } else {
  	&log("INFO: $logfrom plugin array=[@array_plugins]") if $debug;
  }

  foreach my $plugin (@array_plugins) {
  	my %single_plugin = (
		'name'		=> $plugin,
		'enable'	=> 'enable',
		'comment'	=> 'comment',
		'freq'		=> 'frequency',
		'timeout'	=> 'exec_tmout',
		'errnum'	=> 'maxerr_times',
		'snap'		=> 'take_snapshot',
		'mail'		=> 'mail_notify',
		'sms'		=> 'sms_notify',
		'post'		=> 'post_notify',
		'auto'		=> 'auto_handle',
		'attsnap'	=> 'attsnap_mail',
		'debug'		=> 'debug',
		'mail_rec'	=> 'mail_receviers',
		'sms_rec'	=> 'sms_receviers',
		'handler'	=> 'auto_handler',
		'locale'	=> 'locale',
		'udef'		=> '',
		'conf_info'	=> '',
		'mailplc_range'	=> '',
		'mailplc_rtime'	=> '',
		'smsplc_range'	=> '',
		'smsplc_rtime'	=> '',
  	);

	my %conf_info = ();
	foreach my $key (keys %single_plugin) {
		next if $key eq 'name';
		next if $key eq 'udef';
		next if $key eq 'conf_info';
		next if $key eq 'mailplc_range';
		next if $key eq 'mailplc_rtime';
		next if $key eq 'smsplc_range';
		next if $key eq 'smsplc_rtime';

		my $default_flag = 0;
		my $value = read_plugin_config($plugin,$single_plugin{$key});
		if (!defined $value || $value eq '') {
			$default_flag = 1;
			my $default_value = read_mole_config('default',$single_plugin{$key}); 
			if (defined $default_value && $default_value ne '') {
				$single_plugin{$key} = $default_value;
			} else {
				$single_plugin{$key} = '';
			}
		} else {
			$single_plugin{$key} = $value; 
		}

		if ($default_flag) {
			push @{$conf_info{'default'}}, $key;
			&log("DEBUG: $logfrom plugin-config [$plugin.$key]=[$single_plugin{$key}] (default)") if $debug;
		} else {
			push @{$conf_info{'customize'}}, $key;
			&log("DEBUG: $logfrom plugin-config [$plugin.$key]=[$single_plugin{$key}]") if $debug;
		}
	}

	# process mail_rec|sms_rec
	if ($single_plugin{'mail_rec'} =~ m/\A\s*file:/i) {
		$single_plugin{'mail_rec'} = read_file_recvlst($single_plugin{'mail_rec'},'#') || '';
	}
	if ($single_plugin{'sms_rec'} =~ m/\A\s*file:/i) {
		$single_plugin{'sms_rec'} = read_file_recvlst($single_plugin{'sms_rec'},'#') || '';
	}

	# add key:  mailplc_[range|rtime]_
	my $mail_policy;
	my $value = read_plugin_config($plugin,'mail_policy');
	if (!defined $value || $value eq '') {
		push @{$conf_info{'default'}}, ('mailplc_range','mailplc_rtime');
		my $default_value = read_mole_config('default','mail_policy');
		if (defined $default_value && $default_value ne '') {
			$mail_policy = $default_value;
		}
	} else {
		$mail_policy = $value;
		push @{$conf_info{'customize'}}, ('mailplc_range','mailplc_rtime');
	}
	if (defined $mail_policy && $mail_policy ne '') {
		$single_plugin{'mailplc_range'} = &hrformat_policy($mail_policy,'range');
		&log("DEBUG: $logfrom plugin-config [$plugin.mailplc_range]=[$single_plugin{'mailplc_range'}]") if $debug;
		$single_plugin{'mailplc_rtime'} = &hrformat_policy($mail_policy,'rtime');
		&log("DEBUG: $logfrom plugin-config [$plugin.mailplc_rtime]=[$single_plugin{'mailplc_rtime'}]") if $debug;
	}

	# add key:  smsplc_[range|rtime]_
	my $sms_policy;
	$value = read_plugin_config($plugin,'sms_policy');
	if (!defined $value || $value eq '') {
		push @{$conf_info{'default'}}, ('smsplc_range','smsplc_rtime');
		my $default_value = read_mole_config('default','sms_policy');
		if (defined $default_value && $default_value ne '') {
			$sms_policy = $default_value;
		}
	} else {
		$sms_policy = $value;
		push @{$conf_info{'customize'}}, ('smsplc_range','smsplc_rtime');
	}
	if (defined $sms_policy && $sms_policy ne '') {
		$single_plugin{'smsplc_range'} = &hrformat_policy($sms_policy,'range');
		&log("DEBUG: $logfrom plugin-config [$plugin.smsplc_range]=[$single_plugin{'smsplc_range'}]") if $debug;
		$single_plugin{'smsplc_rtime'} = &hrformat_policy($sms_policy,'rtime');
		&log("DEBUG: $logfrom plugin-config [$plugin.smsplc_rtime]=[$single_plugin{'smsplc_rtime'}]") if $debug;
	}

	# set key: {conf_info}
	## %conf_info
	my $json_confinfo = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%conf_info);
	$single_plugin{'conf_info'} = $json_confinfo;
 	&log("DEBUG: $logfrom plugin-config [$plugin.conf_info]=[$single_plugin{'conf_info'}]") if $debug;

	# convert yes|no  to 1|0
	$single_plugin{'enable'}  = (defined $single_plugin{'enable'} && $single_plugin{'enable'} eq 'yes') ? 1 : 0;
	$single_plugin{'attsnap'} = (defined $single_plugin{'attsnap'} && $single_plugin{'attsnap'} eq 'yes') ? 1 : 0;
	$single_plugin{'debug'}   = (defined $single_plugin{'debug'} && $single_plugin{'debug'} eq 'yes') ? 1 : 0;

	# add key: {name} at last
	$single_plugin{'name'} = $plugin;

	# set key: udef
	$single_plugin{'udef'} = '';
	open my $fh, "$mole udef $plugin 2>&- | ";
	if($fh) {
		my @udef_array = ();
		while(<$fh>){
			my %udef = (
				'flag'		=> '',
				'title'		=> '',
				'val'		=> '',
			);
			my @arrline = split /\s+/;
			if (@arrline) {
				my $key = shift @arrline;
				my $value = "@arrline";
				$udef{'flag'} = $key if ($key);	
				$udef{'title'} = $key if ($key);
				$udef{'val'} = $value if (defined $value && $value ne '');
			}
			push @udef_array, \%udef;
		}
		my $json_udef = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\@udef_array);
        	$single_plugin{'udef'} = $json_udef;
		&log("DEBUG: $logfrom plugin-config [$plugin.udef]=[$single_plugin{'udef'}]") if $debug;
	}

	### %single_plugin
  	push @raw_data, \%single_plugin;
  }

  $result{'data'} = \@raw_data;

  return %result;
}

sub genjson_config() {
  my %result = (
	'type'			=> 'config',
	'parter_id'		=> $parter_id,
	'hid'			=> $hid,
	'hname'			=> $hname,
	'data'			=> '',
  );

  &log("INFO: $logfrom set type=[config]") if $debug;
  &log("INFO: $logfrom set parter_id=[$parter_id]") if $debug;
  &log("INFO: $logfrom set hid=[$hid]") if $debug;
  &log("INFO: $logfrom set hname=[$hname]") if $debug;

  my %raw_data = (
	'global'		=> '',
	'default'		=> '',
	'sendmail'		=> '',
	'postlog'		=> '',
	'takesnap'		=> '',
	'sendsms'		=> '',
	'clear_overdue'		=> '',
	'log_rotate'		=> '',
	'self_check'		=> '',
	'iam_alive'		=> '',
	'check_remote'		=> '',
	'report_conf'		=> '',
  );

  my %raw_global = (
	'mole_version'		=> '',
	'proxy_version'		=> '',
	'scan_interval'		=> '', 
	'attach_ini_mail'	=> '',
	'sysload_uplimit'	=> '',
	'max_kidsnum'		=> '',
	'plugin_maxlen'		=> '',
	'handler_maxlen'	=> '',
	'notify_onmisform'	=> '',
	'locale'		=> '',
  );

  my $fh;
  open $fh, "$mole version 2>&- |";
  if($fh) {
	while(<$fh>){
		chomp; $raw_global{'mole_version'} = $_; $raw_global{'proxy_version'} = $_;
		last;
	}
  }
  open $fh, "$mole view global 2>&- |";
  if($fh) {
	while(<$fh>){
		chomp;
		if(/\A\s*scan_interval\s+(.+)\Z/){
			$raw_global{'scan_interval'} = $1;
			next;
		}
		if(/\A\s*attach_ini_mail\s+(.+)\Z/){
			$raw_global{'attach_ini_mail'} = $1;
			$raw_global{'attach_ini_mail'} = (defined $raw_global{'attach_ini_mail'} && $raw_global{'attach_ini_mail'} eq 'yes') ? 1 : 0;
			next;
		}
		if(/\A\s*sysload_uplimit\s+(.+)\Z/){
			$raw_global{'sysload_uplimit'} = $1;
			next;
		}
		if(/\A\s*max_kidsnum\s+(.+)\Z/){
			$raw_global{'max_kidsnum'} = $1;
			next;
		}
		if(/\A\s*plugin_maxlen\s+(.+)\Z/){
			$raw_global{'plugin_maxlen'} = $1;
			next;
		}
		if(/\A\s*handler_maxlen\s+(.+)\Z/){
			$raw_global{'handler_maxlen'} = $1;
			next;
		}
		if(/\A\s*notify_onmisform\s+(.+)\Z/){
			$raw_global{'notify_onmisform'} = $1;
			$raw_global{'notify_onmisform'} = (defined $raw_global{'notify_onmisform'} && $raw_global{'notify_onmisform'} eq 'yes') ? 1 : 0;
			next;
		}
		if(/\A\s*locale\s+(.+)\Z/){
			$raw_global{'locale'} = $1;
			next;
		}
	}
  }
  my $json_global = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_global);

  my %raw_default = (
	'enable'		=> '',
	'comment'		=> '',
	'freq'			=> '',
	'timeout'		=> '',
	'errnum'		=> '',
	'snap'			=> '',
	'mail'			=> '',
	'sms'			=> '',
	'post'			=> '',
	'auto'			=> '',
	'attsnap'		=> '',
	'debug'			=> '',
	'mail_rec'		=> '',
	'sms_rec'		=> '',
	'mailplc_range'		=> '',
	'mailplc_rtime'		=> '',
	'smsplc_range'		=> '',
	'smsplc_rtime'		=> '',
	'handler'		=> '',
	'locale'		=> '',
  );
  open $fh, "$mole view default 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
                if(/\A\s*enable\s+(.+)\Z/){
                        $raw_default{'enable'} = $1; 
			$raw_default{'enable'} = (defined $raw_default{'enable'} && $raw_default{'enable'} eq 'yes') ? 1 : 0;
                        next;
                }
                if(/\A\s*comment\s+(.+)\Z/){
                        $raw_default{'comment'} = $1; 
                        next;
                }
                if(/\A\s*frequency\s+(.+)\Z/){
                        $raw_default{'freq'} = $1; 
                        next;
                }
                if(/\A\s*exec_tmout\s+(.+)\Z/){
                        $raw_default{'timeout'} = $1; 
                        next;
                }
                if(/\A\s*maxerr_times\s+(.+)\Z/){
                        $raw_default{'errnum'} = $1; 
                        next;
                }
                if(/\A\s*take_snapshot\s+(.+)\Z/){
                        $raw_default{'snap'} = $1; 
                        next;
                }
                if(/\A\s*mail_notify\s+(.+)\Z/){
                        $raw_default{'mail'} = $1; 
                        next;
                }
                if(/\A\s*sms_notify\s+(.+)\Z/){
                        $raw_default{'sms'} = $1; 
                        next;
                }
                if(/\A\s*post_notify\s+(.+)\Z/){
                        $raw_default{'post'} = $1; 
                        next;
                }
                if(/\A\s*auto_handle\s+(.+)\Z/){
                        $raw_default{'auto'} = $1; 
                        next;
                }
                if(/\A\s*attsnap_mail\s+(.+)\Z/){
                        $raw_default{'attsnap'} = $1; 
			$raw_default{'attsnap'} = (defined $raw_default{'attsnap'} && $raw_default{'attsnap'} eq 'yes') ? 1 : 0;
                        next;
                }
                if(/\A\s*debug\s+(.+)\Z/){
                        $raw_default{'debug'} = $1; 
			$raw_default{'debug'} = (defined $raw_default{'debug'} && $raw_default{'debug'} eq 'yes') ? 1 : 0;
                        next;
                }
                if(/\A\s*mail_receviers\s+(.+)\Z/){
                        $raw_default{'mail_rec'} = $1; 
			if ($raw_default{'mail_rec'} =~ m/\A\s*file:/i) {
				$raw_default{'mail_rec'} = read_file_recvlst($raw_default{'mail_rec'},'#') || '';
			}
                        next;
                }
                if(/\A\s*sms_receviers\s+(.+)\Z/){
                        $raw_default{'sms_rec'} = $1; 
			if ($raw_default{'sms_rec'} =~ m/\A\s*file:/i) {
				$raw_default{'sms_rec'} = read_file_recvlst($raw_default{'sms_rec'},'#') || '';
			}
                        next;
                }
                if(/\A\s*mail_policy\s+(.+)\Z/){
			$raw_default{'mailplc_range'} = &hrformat_policy($1,'range');
			$raw_default{'mailplc_rtime'} = &hrformat_policy($1,'rtime');
                        next;
                }
                if(/\A\s*sms_policy\s+(.+)\Z/){
			$raw_default{'smsplc_range'} = &hrformat_policy($1,'range');
			$raw_default{'smsplc_rtime'} = &hrformat_policy($1,'rtime');
                        next;
                }
                if(/\A\s*auto_handler\s+(.+)\Z/){
                        $raw_default{'handler'} = $1; 
                        next;
                }
                if(/\A\s*locale\s+(.+)\Z/){
                        $raw_default{'locale'} = $1; 
                        next;
                }
	}
  }
  my $json_default = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_default);

  my %raw_sendmail = (
	'smtp_server'		=> '',
	'smtp_server_port'	=> '',
	'auth_user'		=> '',
	'auth_pass'		=> '',
	'timeout'		=> '',
	'charset'		=> '',
  );
  open $fh, "$mole view sendmail 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
		foreach my $key (keys %raw_sendmail){
                	if(/\A\s*$key\s+(.+)\Z/){
                        	$raw_sendmail{$key} = $1; 
				goto MAIL_END;
                	}
		}
		MAIL_END: {
			next;
		}
	}
  }
  my $json_sendmail = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_sendmail);
  
  my %raw_postlog = (
	'post_server'		=> '',
	'post_server_port'	=> '',
	'post_port_type'	=> '',
	'post_timeout'		=> '',
	'post_max_length'	=> '',
	'post_debug'		=> '',
  );
  open $fh, "$mole view postlog 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
		foreach my $key (keys %raw_postlog){
                	if(/\A\s*$key\s+(.+)\Z/){
                        	$raw_postlog{$key} = $1; 
				goto POST_END;
                	}
		}
		POST_END: {
			next;
		}
	}
  }
  $raw_postlog{'post_debug'}  = (defined $raw_postlog{'post_debug'} && $raw_postlog{'post_debug'} eq 'yes') ? 1 : 0;
  my $json_postlog = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_postlog);

  my %raw_takesnap = (
  );
  open $fh, "$mole view takesnap 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
	}
  }
  my $json_takesnap = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_takesnap);

  my %raw_sendsms = (
	'sms_handler'	=> '',
	'cnpc_smspath'	=> '',
	'sms_maxlen'	=> '',
	'character_set'	=> '',
	'timeout'	=> '',
  );
  open $fh, "$mole view sms 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
		foreach my $key (keys %raw_sendsms) {
			if(/\A\s*$key\s+(.+)\Z/){
				$raw_sendsms{$key} = $1;
				goto POST_END;
			}
		}
		POST_END: {
			next;
		}
	}
  }
  my $json_sendsms = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_sendsms);

  my %raw_clear_overdue = (
	'frequency'		=> '',
	'exec_tmout'		=> '',
	'tmpfile_reserve_time'	=> '',
	'logfile_reserve_time'	=> '',
	'snapfile_reserve_time'	=> '',
	'snapdir_maxsize'	=> '',
  );
  open $fh, "$mole view mole_clear_overdue 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
		foreach my $key (keys %raw_clear_overdue){
                	if(/\A\s*$key\s+(.+)\Z/){
                        	$raw_clear_overdue{$key} = $1; 
				goto POST_END;
                	}
		}
		POST_END: {
			next;
		}
	}
  }
  my $json_clear_overdue = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_clear_overdue);

  my %raw_log_rotate = (
	'frequency'		=> '',
	'exec_tmout'		=> '',
	'force_size_uplimit'	=> '',
	'take_over_proxylog'	=> '',
  );
  open $fh, "$mole view mole_log_rotate 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
		foreach my $key (keys %raw_log_rotate){
                	if(/\A\s*$key\s+(.+)\Z/){
                        	$raw_log_rotate{$key} = $1; 
				goto POST_END;
                	}
		}
		POST_END: {
			next;
		}
	}
  }
  $raw_log_rotate{'take_over_proxylog'}  = (defined $raw_log_rotate{'take_over_proxylog'} && $raw_log_rotate{'take_over_proxylog'} eq 'yes') ? 1 : 0;
  my $json_log_rotate = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_log_rotate);

  my %raw_self_check = (
	'frequency'		=> '',
	'exec_tmout'		=> '',
  );
  open $fh, "$mole view mole_self_check 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
		foreach my $key (keys %raw_self_check){
                	if(/\A\s*$key\s+(.+)\Z/){
                        	$raw_self_check{$key} = $1; 
				goto POST_END;
                	}
		}
		POST_END: {
			next;
		}
	}
  }
  my $json_self_check = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_self_check);

  my %raw_iam_alive = (
	'frequency'		=> '',
	'exec_tmout'		=> '',
  );
  open $fh, "$mole view mole_iam_alive 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
		foreach my $key (keys %raw_iam_alive){
                	if(/\A\s*$key\s+(.+)\Z/){
                        	$raw_iam_alive{$key} = $1; 
				goto POST_END;
                	}
		}
		POST_END: {
			next;
		}
	}
  }
  my $json_iam_alive = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_iam_alive);

  my %raw_check_remote = (
	'frequency'		=> '',
	'exec_tmout'		=> '',
  );
  open $fh, "$mole view mole_check_remote 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
		foreach my $key (keys %raw_check_remote){
                	if(/\A\s*$key\s+(.+)\Z/){
                        	$raw_check_remote{$key} = $1; 
				goto POST_END;
                	}
		}
		POST_END: {
			next;
		}
	}
  }
  my $json_check_remote = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_check_remote);

  my %raw_report_conf = (
	'frequency'		=> '',
	'exec_tmout'		=> '',
  );
  open $fh, "$mole view mole_report_conf 2>&- |";
  if($fh) {
        while(<$fh>){
                chomp;
		foreach my $key (keys %raw_report_conf){
                	if(/\A\s*$key\s+(.+)\Z/){
                        	$raw_report_conf{$key} = $1; 
				goto POST_END;
                	}
		}
		POST_END: {
			next;
		}
	}
  }
  my $json_report_conf = JSON->new->allow_nonref->utf8(1)->ascii(1)->encode(\%raw_report_conf);

  close $fh if ($fh);


  %raw_data = (
	'global'		=> $json_global,
	'default'		=> $json_default,
	'sendmail'		=> $json_sendmail,
	'postlog'		=> $json_postlog,
	'takesnap'		=> $json_takesnap, 
	'sendsms'		=> $json_sendsms,
	'clear_overdue'		=> $json_clear_overdue,
	'log_rotate'		=> $json_log_rotate,
	'self_check'		=> $json_self_check,
	'iam_alive'		=> $json_iam_alive,
	'check_remote'		=> $json_check_remote,
	'report_conf'		=> $json_report_conf,
  );

  $result{'data'} = \%raw_data;

  return %result;
}

sub genjson_heartbeat() {

  my ($jobid) = @_;

  my %result = (
        'type'                  => 'noop',
        'parter_id'             => $parter_id,
        'hid'                   => $hid,
        'hname'                 => $hname,
	'job'			=> '',
        'data'                  => '',
  );

  &log("INFO: $logfrom set type=[noop]") if $debug;
  &log("INFO: $logfrom set parter_id=[$parter_id]") if $debug;
  &log("INFO: $logfrom set hid=[$hid]") if $debug;
  &log("INFO: $logfrom set hname=[$hname]") if $debug;

  # set job
  my @raw_job = ($jobid,time());
  $result{'job'} = \@raw_job;
  &log("DEBUG: $logfrom set job=[[@raw_job]]") if $debug;

  # set data
  my %raw_data = (
        'interval'                => '60',
  );
  open my $fh, "$mole view mole_iam_alive frequency 2>&- | ";
  if($fh){
	while(<$fh>){
		chomp; 
		if(m/\A\s*(\d+)min/i){
			$raw_data{'interval'} = $1*60;
		}elsif(m/\A\s*(\d+)sec/i){
			$raw_data{'interval'} = $1;
		}elsif(m/\A\s*(\d+)hour/i){
			$raw_data{'interval'} = $1*3600;
		}elsif(m/\A\s*(\d+)day/i){
			$raw_data{'interval'} = $1*86400;
		}else{
			$raw_data{'interval'} = 60;
		}
		last;
	}
  }
  $result{'data'} = \%raw_data;

  return %result;
}

sub genjson_sysinfo {

  my ($jobid,$sysinfo) = @_;

  my %result = (
        'type'                  => 'sysinfo',
        'parter_id'             => $parter_id,
        'hid'                   => $hid,
        'hname'                 => $hname,
	'dtype'			=> '',
        'data'                  => '',
  );

  &log("INFO: $logfrom set type=[sysinfo]") if $debug;
  &log("INFO: $logfrom set parter_id=[$parter_id]") if $debug;
  &log("INFO: $logfrom set hid=[$hid]") if $debug;
  &log("INFO: $logfrom set hname=[$hname]") if $debug;

  if ($sysinfo =~ m/\A(.+?) (.*)\Z/m) {
  	# set dtype
	unless ($1 eq 'full' || $1 eq 'diff') {
		&log("CRIT: $logfrom data type is [$1], must be full or diff, exit");
		exit (1);
	}
  	$result{'dtype'} = $1;
  	&log("INFO: $logfrom set dtype=[$1]");

  	# set data
  	my $sysinfo_data; 
	eval { $sysinfo_data = JSON->new->allow_nonref->utf8(1)->ascii(1)->decode($2); };
	if ($@) {
		&log("CRIT: $logfrom json decode sysinfo data failed, [$2], exit");
		exit (1);
	}
	&log("INFO: $logfrom json decode sysinfo data succeed.");
  	$result{'data'} = \%{$sysinfo_data};
  } else {
	&log("CRIT: $logfrom sysinfo format not matched, exit");
	exit (1);
  }

  return %result;
}
